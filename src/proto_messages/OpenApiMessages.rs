// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 33.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `OpenApiMessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:ProtoOAApplicationAuthReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAApplicationAuthReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAApplicationAuthReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAApplicationAuthReq.clientId)
    pub clientId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAApplicationAuthReq.clientSecret)
    pub clientSecret: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAApplicationAuthReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAApplicationAuthReq {
    fn default() -> &'a ProtoOAApplicationAuthReq {
        <ProtoOAApplicationAuthReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAApplicationAuthReq {
    pub fn new() -> ProtoOAApplicationAuthReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string clientId = 2;

    pub fn clientId(&self) -> &str {
        match self.clientId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientId(&mut self) {
        self.clientId = ::std::option::Option::None;
    }

    pub fn has_clientId(&self) -> bool {
        self.clientId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientId(&mut self, v: ::std::string::String) {
        self.clientId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientId(&mut self) -> &mut ::std::string::String {
        if self.clientId.is_none() {
            self.clientId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientId.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientId(&mut self) -> ::std::string::String {
        self.clientId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string clientSecret = 3;

    pub fn clientSecret(&self) -> &str {
        match self.clientSecret.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientSecret(&mut self) {
        self.clientSecret = ::std::option::Option::None;
    }

    pub fn has_clientSecret(&self) -> bool {
        self.clientSecret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientSecret(&mut self, v: ::std::string::String) {
        self.clientSecret = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientSecret(&mut self) -> &mut ::std::string::String {
        if self.clientSecret.is_none() {
            self.clientSecret = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientSecret.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientSecret(&mut self) -> ::std::string::String {
        self.clientSecret.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAApplicationAuthReq| { &m.payloadType },
            |m: &mut ProtoOAApplicationAuthReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientId",
            |m: &ProtoOAApplicationAuthReq| { &m.clientId },
            |m: &mut ProtoOAApplicationAuthReq| { &mut m.clientId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientSecret",
            |m: &ProtoOAApplicationAuthReq| { &m.clientSecret },
            |m: &mut ProtoOAApplicationAuthReq| { &mut m.clientSecret },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAApplicationAuthReq>(
            "ProtoOAApplicationAuthReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAApplicationAuthReq {
    const NAME: &'static str = "ProtoOAApplicationAuthReq";

    fn is_initialized(&self) -> bool {
        if self.clientId.is_none() {
            return false;
        }
        if self.clientSecret.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.clientId = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.clientSecret = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.clientId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.clientSecret.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.clientId.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.clientSecret.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAApplicationAuthReq {
        ProtoOAApplicationAuthReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.clientId = ::std::option::Option::None;
        self.clientSecret = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAApplicationAuthReq {
        static instance: ProtoOAApplicationAuthReq = ProtoOAApplicationAuthReq {
            payloadType: ::std::option::Option::None,
            clientId: ::std::option::Option::None,
            clientSecret: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAApplicationAuthReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAApplicationAuthReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAApplicationAuthReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAApplicationAuthReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAApplicationAuthRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAApplicationAuthRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAApplicationAuthRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAApplicationAuthRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAApplicationAuthRes {
    fn default() -> &'a ProtoOAApplicationAuthRes {
        <ProtoOAApplicationAuthRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAApplicationAuthRes {
    pub fn new() -> ProtoOAApplicationAuthRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAApplicationAuthRes| { &m.payloadType },
            |m: &mut ProtoOAApplicationAuthRes| { &mut m.payloadType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAApplicationAuthRes>(
            "ProtoOAApplicationAuthRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAApplicationAuthRes {
    const NAME: &'static str = "ProtoOAApplicationAuthRes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAApplicationAuthRes {
        ProtoOAApplicationAuthRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAApplicationAuthRes {
        static instance: ProtoOAApplicationAuthRes = ProtoOAApplicationAuthRes {
            payloadType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAApplicationAuthRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAApplicationAuthRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAApplicationAuthRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAApplicationAuthRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAccountAuthReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAccountAuthReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAccountAuthReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAccountAuthReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAccountAuthReq.accessToken)
    pub accessToken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAccountAuthReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAccountAuthReq {
    fn default() -> &'a ProtoOAAccountAuthReq {
        <ProtoOAAccountAuthReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAccountAuthReq {
    pub fn new() -> ProtoOAAccountAuthReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required string accessToken = 3;

    pub fn accessToken(&self) -> &str {
        match self.accessToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accessToken(&mut self) {
        self.accessToken = ::std::option::Option::None;
    }

    pub fn has_accessToken(&self) -> bool {
        self.accessToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessToken(&mut self, v: ::std::string::String) {
        self.accessToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessToken(&mut self) -> &mut ::std::string::String {
        if self.accessToken.is_none() {
            self.accessToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accessToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_accessToken(&mut self) -> ::std::string::String {
        self.accessToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAccountAuthReq| { &m.payloadType },
            |m: &mut ProtoOAAccountAuthReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAccountAuthReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAccountAuthReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accessToken",
            |m: &ProtoOAAccountAuthReq| { &m.accessToken },
            |m: &mut ProtoOAAccountAuthReq| { &mut m.accessToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAccountAuthReq>(
            "ProtoOAAccountAuthReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAccountAuthReq {
    const NAME: &'static str = "ProtoOAAccountAuthReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.accessToken.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.accessToken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.accessToken.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.accessToken.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAccountAuthReq {
        ProtoOAAccountAuthReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.accessToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAccountAuthReq {
        static instance: ProtoOAAccountAuthReq = ProtoOAAccountAuthReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            accessToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAccountAuthReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAccountAuthReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAccountAuthReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAccountAuthReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAccountAuthRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAccountAuthRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAccountAuthRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAccountAuthRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAccountAuthRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAccountAuthRes {
    fn default() -> &'a ProtoOAAccountAuthRes {
        <ProtoOAAccountAuthRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAccountAuthRes {
    pub fn new() -> ProtoOAAccountAuthRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAccountAuthRes| { &m.payloadType },
            |m: &mut ProtoOAAccountAuthRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAccountAuthRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAccountAuthRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAccountAuthRes>(
            "ProtoOAAccountAuthRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAccountAuthRes {
    const NAME: &'static str = "ProtoOAAccountAuthRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAccountAuthRes {
        ProtoOAAccountAuthRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAccountAuthRes {
        static instance: ProtoOAAccountAuthRes = ProtoOAAccountAuthRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAccountAuthRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAccountAuthRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAccountAuthRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAccountAuthRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAErrorRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAErrorRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAErrorRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAErrorRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAErrorRes.errorCode)
    pub errorCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAErrorRes.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAErrorRes.maintenanceEndTimestamp)
    pub maintenanceEndTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAErrorRes.retryAfter)
    pub retryAfter: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAErrorRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAErrorRes {
    fn default() -> &'a ProtoOAErrorRes {
        <ProtoOAErrorRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAErrorRes {
    pub fn new() -> ProtoOAErrorRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ERROR_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ERROR_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required string errorCode = 3;

    pub fn errorCode(&self) -> &str {
        match self.errorCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: ::std::string::String) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorCode(&mut self) -> &mut ::std::string::String {
        if self.errorCode.is_none() {
            self.errorCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errorCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorCode(&mut self) -> ::std::string::String {
        self.errorCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 maintenanceEndTimestamp = 5;

    pub fn maintenanceEndTimestamp(&self) -> i64 {
        self.maintenanceEndTimestamp.unwrap_or(0)
    }

    pub fn clear_maintenanceEndTimestamp(&mut self) {
        self.maintenanceEndTimestamp = ::std::option::Option::None;
    }

    pub fn has_maintenanceEndTimestamp(&self) -> bool {
        self.maintenanceEndTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maintenanceEndTimestamp(&mut self, v: i64) {
        self.maintenanceEndTimestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 retryAfter = 6;

    pub fn retryAfter(&self) -> u64 {
        self.retryAfter.unwrap_or(0)
    }

    pub fn clear_retryAfter(&mut self) {
        self.retryAfter = ::std::option::Option::None;
    }

    pub fn has_retryAfter(&self) -> bool {
        self.retryAfter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retryAfter(&mut self, v: u64) {
        self.retryAfter = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAErrorRes| { &m.payloadType },
            |m: &mut ProtoOAErrorRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAErrorRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAErrorRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errorCode",
            |m: &ProtoOAErrorRes| { &m.errorCode },
            |m: &mut ProtoOAErrorRes| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ProtoOAErrorRes| { &m.description },
            |m: &mut ProtoOAErrorRes| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maintenanceEndTimestamp",
            |m: &ProtoOAErrorRes| { &m.maintenanceEndTimestamp },
            |m: &mut ProtoOAErrorRes| { &mut m.maintenanceEndTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "retryAfter",
            |m: &ProtoOAErrorRes| { &m.retryAfter },
            |m: &mut ProtoOAErrorRes| { &mut m.retryAfter },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAErrorRes>(
            "ProtoOAErrorRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAErrorRes {
    const NAME: &'static str = "ProtoOAErrorRes";

    fn is_initialized(&self) -> bool {
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.errorCode = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.maintenanceEndTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.retryAfter = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.errorCode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.maintenanceEndTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.retryAfter {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.errorCode.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.maintenanceEndTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.retryAfter {
            os.write_uint64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAErrorRes {
        ProtoOAErrorRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.errorCode = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.maintenanceEndTimestamp = ::std::option::Option::None;
        self.retryAfter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAErrorRes {
        static instance: ProtoOAErrorRes = ProtoOAErrorRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            errorCode: ::std::option::Option::None,
            description: ::std::option::Option::None,
            maintenanceEndTimestamp: ::std::option::Option::None,
            retryAfter: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAErrorRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAErrorRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAErrorRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAErrorRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAClientDisconnectEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAClientDisconnectEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAClientDisconnectEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAClientDisconnectEvent.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAClientDisconnectEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAClientDisconnectEvent {
    fn default() -> &'a ProtoOAClientDisconnectEvent {
        <ProtoOAClientDisconnectEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAClientDisconnectEvent {
    pub fn new() -> ProtoOAClientDisconnectEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CLIENT_DISCONNECT_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CLIENT_DISCONNECT_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reason = 2;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAClientDisconnectEvent| { &m.payloadType },
            |m: &mut ProtoOAClientDisconnectEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ProtoOAClientDisconnectEvent| { &m.reason },
            |m: &mut ProtoOAClientDisconnectEvent| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAClientDisconnectEvent>(
            "ProtoOAClientDisconnectEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAClientDisconnectEvent {
    const NAME: &'static str = "ProtoOAClientDisconnectEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.reason.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAClientDisconnectEvent {
        ProtoOAClientDisconnectEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAClientDisconnectEvent {
        static instance: ProtoOAClientDisconnectEvent = ProtoOAClientDisconnectEvent {
            payloadType: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAClientDisconnectEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAClientDisconnectEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAClientDisconnectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAClientDisconnectEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAccountsTokenInvalidatedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAccountsTokenInvalidatedEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAccountsTokenInvalidatedEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAccountsTokenInvalidatedEvent.ctidTraderAccountIds)
    pub ctidTraderAccountIds: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:ProtoOAAccountsTokenInvalidatedEvent.reason)
    pub reason: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAccountsTokenInvalidatedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAccountsTokenInvalidatedEvent {
    fn default() -> &'a ProtoOAAccountsTokenInvalidatedEvent {
        <ProtoOAAccountsTokenInvalidatedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAccountsTokenInvalidatedEvent {
    pub fn new() -> ProtoOAAccountsTokenInvalidatedEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string reason = 3;

    pub fn reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason = ::std::option::Option::Some(::std::string::String::new());
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAccountsTokenInvalidatedEvent| { &m.payloadType },
            |m: &mut ProtoOAAccountsTokenInvalidatedEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ctidTraderAccountIds",
            |m: &ProtoOAAccountsTokenInvalidatedEvent| { &m.ctidTraderAccountIds },
            |m: &mut ProtoOAAccountsTokenInvalidatedEvent| { &mut m.ctidTraderAccountIds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &ProtoOAAccountsTokenInvalidatedEvent| { &m.reason },
            |m: &mut ProtoOAAccountsTokenInvalidatedEvent| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAccountsTokenInvalidatedEvent>(
            "ProtoOAAccountsTokenInvalidatedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAccountsTokenInvalidatedEvent {
    const NAME: &'static str = "ProtoOAAccountsTokenInvalidatedEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_int64_into(&mut self.ctidTraderAccountIds)?;
                },
                16 => {
                    self.ctidTraderAccountIds.push(is.read_int64()?);
                },
                26 => {
                    self.reason = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.ctidTraderAccountIds {
            my_size += ::protobuf::rt::int64_size(2, *value);
        };
        if let Some(v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.ctidTraderAccountIds {
            os.write_int64(2, *v)?;
        };
        if let Some(v) = self.reason.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAccountsTokenInvalidatedEvent {
        ProtoOAAccountsTokenInvalidatedEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountIds.clear();
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAccountsTokenInvalidatedEvent {
        static instance: ProtoOAAccountsTokenInvalidatedEvent = ProtoOAAccountsTokenInvalidatedEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountIds: ::std::vec::Vec::new(),
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAccountsTokenInvalidatedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAccountsTokenInvalidatedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAccountsTokenInvalidatedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAccountsTokenInvalidatedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAVersionReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAVersionReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAVersionReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAVersionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAVersionReq {
    fn default() -> &'a ProtoOAVersionReq {
        <ProtoOAVersionReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAVersionReq {
    pub fn new() -> ProtoOAVersionReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_VERSION_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_VERSION_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAVersionReq| { &m.payloadType },
            |m: &mut ProtoOAVersionReq| { &mut m.payloadType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAVersionReq>(
            "ProtoOAVersionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAVersionReq {
    const NAME: &'static str = "ProtoOAVersionReq";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAVersionReq {
        ProtoOAVersionReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAVersionReq {
        static instance: ProtoOAVersionReq = ProtoOAVersionReq {
            payloadType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAVersionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAVersionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAVersionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAVersionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAVersionRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAVersionRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAVersionRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAVersionRes.version)
    pub version: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAVersionRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAVersionRes {
    fn default() -> &'a ProtoOAVersionRes {
        <ProtoOAVersionRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAVersionRes {
    pub fn new() -> ProtoOAVersionRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_VERSION_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_VERSION_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string version = 2;

    pub fn version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAVersionRes| { &m.payloadType },
            |m: &mut ProtoOAVersionRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &ProtoOAVersionRes| { &m.version },
            |m: &mut ProtoOAVersionRes| { &mut m.version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAVersionRes>(
            "ProtoOAVersionRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAVersionRes {
    const NAME: &'static str = "ProtoOAVersionRes";

    fn is_initialized(&self) -> bool {
        if self.version.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.version = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.version.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAVersionRes {
        ProtoOAVersionRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAVersionRes {
        static instance: ProtoOAVersionRes = ProtoOAVersionRes {
            payloadType: ::std::option::Option::None,
            version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAVersionRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAVersionRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAVersionRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAVersionRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOANewOrderReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOANewOrderReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.orderType)
    pub orderType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAOrderType>>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.tradeSide)
    pub tradeSide: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOATradeSide>>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.limitPrice)
    pub limitPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.stopPrice)
    pub stopPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.timeInForce)
    pub timeInForce: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOATimeInForce>>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.expirationTimestamp)
    pub expirationTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.stopLoss)
    pub stopLoss: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.takeProfit)
    pub takeProfit: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.baseSlippagePrice)
    pub baseSlippagePrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.slippageInPoints)
    pub slippageInPoints: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.clientOrderId)
    pub clientOrderId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.relativeStopLoss)
    pub relativeStopLoss: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.relativeTakeProfit)
    pub relativeTakeProfit: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.guaranteedStopLoss)
    pub guaranteedStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.trailingStopLoss)
    pub trailingStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOANewOrderReq.stopTriggerMethod)
    pub stopTriggerMethod: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAOrderTriggerMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOANewOrderReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOANewOrderReq {
    fn default() -> &'a ProtoOANewOrderReq {
        <ProtoOANewOrderReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOANewOrderReq {
    pub fn new() -> ProtoOANewOrderReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_NEW_ORDER_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_NEW_ORDER_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 symbolId = 3;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // required .ProtoOAOrderType orderType = 4;

    pub fn orderType(&self) -> super::OpenApiModelMessages::ProtoOAOrderType {
        match self.orderType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAOrderType::MARKET),
            None => super::OpenApiModelMessages::ProtoOAOrderType::MARKET,
        }
    }

    pub fn clear_orderType(&mut self) {
        self.orderType = ::std::option::Option::None;
    }

    pub fn has_orderType(&self) -> bool {
        self.orderType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderType(&mut self, v: super::OpenApiModelMessages::ProtoOAOrderType) {
        self.orderType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .ProtoOATradeSide tradeSide = 5;

    pub fn tradeSide(&self) -> super::OpenApiModelMessages::ProtoOATradeSide {
        match self.tradeSide {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOATradeSide::BUY),
            None => super::OpenApiModelMessages::ProtoOATradeSide::BUY,
        }
    }

    pub fn clear_tradeSide(&mut self) {
        self.tradeSide = ::std::option::Option::None;
    }

    pub fn has_tradeSide(&self) -> bool {
        self.tradeSide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tradeSide(&mut self, v: super::OpenApiModelMessages::ProtoOATradeSide) {
        self.tradeSide = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 volume = 6;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // optional double limitPrice = 7;

    pub fn limitPrice(&self) -> f64 {
        self.limitPrice.unwrap_or(0.)
    }

    pub fn clear_limitPrice(&mut self) {
        self.limitPrice = ::std::option::Option::None;
    }

    pub fn has_limitPrice(&self) -> bool {
        self.limitPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitPrice(&mut self, v: f64) {
        self.limitPrice = ::std::option::Option::Some(v);
    }

    // optional double stopPrice = 8;

    pub fn stopPrice(&self) -> f64 {
        self.stopPrice.unwrap_or(0.)
    }

    pub fn clear_stopPrice(&mut self) {
        self.stopPrice = ::std::option::Option::None;
    }

    pub fn has_stopPrice(&self) -> bool {
        self.stopPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopPrice(&mut self, v: f64) {
        self.stopPrice = ::std::option::Option::Some(v);
    }

    // optional .ProtoOATimeInForce timeInForce = 9;

    pub fn timeInForce(&self) -> super::OpenApiModelMessages::ProtoOATimeInForce {
        match self.timeInForce {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOATimeInForce::GOOD_TILL_CANCEL),
            None => super::OpenApiModelMessages::ProtoOATimeInForce::GOOD_TILL_CANCEL,
        }
    }

    pub fn clear_timeInForce(&mut self) {
        self.timeInForce = ::std::option::Option::None;
    }

    pub fn has_timeInForce(&self) -> bool {
        self.timeInForce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeInForce(&mut self, v: super::OpenApiModelMessages::ProtoOATimeInForce) {
        self.timeInForce = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 expirationTimestamp = 10;

    pub fn expirationTimestamp(&self) -> i64 {
        self.expirationTimestamp.unwrap_or(0)
    }

    pub fn clear_expirationTimestamp(&mut self) {
        self.expirationTimestamp = ::std::option::Option::None;
    }

    pub fn has_expirationTimestamp(&self) -> bool {
        self.expirationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationTimestamp(&mut self, v: i64) {
        self.expirationTimestamp = ::std::option::Option::Some(v);
    }

    // optional double stopLoss = 11;

    pub fn stopLoss(&self) -> f64 {
        self.stopLoss.unwrap_or(0.)
    }

    pub fn clear_stopLoss(&mut self) {
        self.stopLoss = ::std::option::Option::None;
    }

    pub fn has_stopLoss(&self) -> bool {
        self.stopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLoss(&mut self, v: f64) {
        self.stopLoss = ::std::option::Option::Some(v);
    }

    // optional double takeProfit = 12;

    pub fn takeProfit(&self) -> f64 {
        self.takeProfit.unwrap_or(0.)
    }

    pub fn clear_takeProfit(&mut self) {
        self.takeProfit = ::std::option::Option::None;
    }

    pub fn has_takeProfit(&self) -> bool {
        self.takeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_takeProfit(&mut self, v: f64) {
        self.takeProfit = ::std::option::Option::Some(v);
    }

    // optional string comment = 13;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double baseSlippagePrice = 14;

    pub fn baseSlippagePrice(&self) -> f64 {
        self.baseSlippagePrice.unwrap_or(0.)
    }

    pub fn clear_baseSlippagePrice(&mut self) {
        self.baseSlippagePrice = ::std::option::Option::None;
    }

    pub fn has_baseSlippagePrice(&self) -> bool {
        self.baseSlippagePrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseSlippagePrice(&mut self, v: f64) {
        self.baseSlippagePrice = ::std::option::Option::Some(v);
    }

    // optional int32 slippageInPoints = 15;

    pub fn slippageInPoints(&self) -> i32 {
        self.slippageInPoints.unwrap_or(0)
    }

    pub fn clear_slippageInPoints(&mut self) {
        self.slippageInPoints = ::std::option::Option::None;
    }

    pub fn has_slippageInPoints(&self) -> bool {
        self.slippageInPoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slippageInPoints(&mut self, v: i32) {
        self.slippageInPoints = ::std::option::Option::Some(v);
    }

    // optional string label = 16;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 positionId = 17;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // optional string clientOrderId = 18;

    pub fn clientOrderId(&self) -> &str {
        match self.clientOrderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientOrderId(&mut self) {
        self.clientOrderId = ::std::option::Option::None;
    }

    pub fn has_clientOrderId(&self) -> bool {
        self.clientOrderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientOrderId(&mut self, v: ::std::string::String) {
        self.clientOrderId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientOrderId(&mut self) -> &mut ::std::string::String {
        if self.clientOrderId.is_none() {
            self.clientOrderId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientOrderId.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientOrderId(&mut self) -> ::std::string::String {
        self.clientOrderId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 relativeStopLoss = 19;

    pub fn relativeStopLoss(&self) -> i64 {
        self.relativeStopLoss.unwrap_or(0)
    }

    pub fn clear_relativeStopLoss(&mut self) {
        self.relativeStopLoss = ::std::option::Option::None;
    }

    pub fn has_relativeStopLoss(&self) -> bool {
        self.relativeStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relativeStopLoss(&mut self, v: i64) {
        self.relativeStopLoss = ::std::option::Option::Some(v);
    }

    // optional int64 relativeTakeProfit = 20;

    pub fn relativeTakeProfit(&self) -> i64 {
        self.relativeTakeProfit.unwrap_or(0)
    }

    pub fn clear_relativeTakeProfit(&mut self) {
        self.relativeTakeProfit = ::std::option::Option::None;
    }

    pub fn has_relativeTakeProfit(&self) -> bool {
        self.relativeTakeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relativeTakeProfit(&mut self, v: i64) {
        self.relativeTakeProfit = ::std::option::Option::Some(v);
    }

    // optional bool guaranteedStopLoss = 21;

    pub fn guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.unwrap_or(false)
    }

    pub fn clear_guaranteedStopLoss(&mut self) {
        self.guaranteedStopLoss = ::std::option::Option::None;
    }

    pub fn has_guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guaranteedStopLoss(&mut self, v: bool) {
        self.guaranteedStopLoss = ::std::option::Option::Some(v);
    }

    // optional bool trailingStopLoss = 22;

    pub fn trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.unwrap_or(false)
    }

    pub fn clear_trailingStopLoss(&mut self) {
        self.trailingStopLoss = ::std::option::Option::None;
    }

    pub fn has_trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailingStopLoss(&mut self, v: bool) {
        self.trailingStopLoss = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAOrderTriggerMethod stopTriggerMethod = 23;

    pub fn stopTriggerMethod(&self) -> super::OpenApiModelMessages::ProtoOAOrderTriggerMethod {
        match self.stopTriggerMethod {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAOrderTriggerMethod::TRADE),
            None => super::OpenApiModelMessages::ProtoOAOrderTriggerMethod::TRADE,
        }
    }

    pub fn clear_stopTriggerMethod(&mut self) {
        self.stopTriggerMethod = ::std::option::Option::None;
    }

    pub fn has_stopTriggerMethod(&self) -> bool {
        self.stopTriggerMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopTriggerMethod(&mut self, v: super::OpenApiModelMessages::ProtoOAOrderTriggerMethod) {
        self.stopTriggerMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOANewOrderReq| { &m.payloadType },
            |m: &mut ProtoOANewOrderReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOANewOrderReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOANewOrderReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOANewOrderReq| { &m.symbolId },
            |m: &mut ProtoOANewOrderReq| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderType",
            |m: &ProtoOANewOrderReq| { &m.orderType },
            |m: &mut ProtoOANewOrderReq| { &mut m.orderType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tradeSide",
            |m: &ProtoOANewOrderReq| { &m.tradeSide },
            |m: &mut ProtoOANewOrderReq| { &mut m.tradeSide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOANewOrderReq| { &m.volume },
            |m: &mut ProtoOANewOrderReq| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limitPrice",
            |m: &ProtoOANewOrderReq| { &m.limitPrice },
            |m: &mut ProtoOANewOrderReq| { &mut m.limitPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopPrice",
            |m: &ProtoOANewOrderReq| { &m.stopPrice },
            |m: &mut ProtoOANewOrderReq| { &mut m.stopPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeInForce",
            |m: &ProtoOANewOrderReq| { &m.timeInForce },
            |m: &mut ProtoOANewOrderReq| { &mut m.timeInForce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expirationTimestamp",
            |m: &ProtoOANewOrderReq| { &m.expirationTimestamp },
            |m: &mut ProtoOANewOrderReq| { &mut m.expirationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLoss",
            |m: &ProtoOANewOrderReq| { &m.stopLoss },
            |m: &mut ProtoOANewOrderReq| { &mut m.stopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "takeProfit",
            |m: &ProtoOANewOrderReq| { &m.takeProfit },
            |m: &mut ProtoOANewOrderReq| { &mut m.takeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &ProtoOANewOrderReq| { &m.comment },
            |m: &mut ProtoOANewOrderReq| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseSlippagePrice",
            |m: &ProtoOANewOrderReq| { &m.baseSlippagePrice },
            |m: &mut ProtoOANewOrderReq| { &mut m.baseSlippagePrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slippageInPoints",
            |m: &ProtoOANewOrderReq| { &m.slippageInPoints },
            |m: &mut ProtoOANewOrderReq| { &mut m.slippageInPoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &ProtoOANewOrderReq| { &m.label },
            |m: &mut ProtoOANewOrderReq| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOANewOrderReq| { &m.positionId },
            |m: &mut ProtoOANewOrderReq| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientOrderId",
            |m: &ProtoOANewOrderReq| { &m.clientOrderId },
            |m: &mut ProtoOANewOrderReq| { &mut m.clientOrderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relativeStopLoss",
            |m: &ProtoOANewOrderReq| { &m.relativeStopLoss },
            |m: &mut ProtoOANewOrderReq| { &mut m.relativeStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relativeTakeProfit",
            |m: &ProtoOANewOrderReq| { &m.relativeTakeProfit },
            |m: &mut ProtoOANewOrderReq| { &mut m.relativeTakeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guaranteedStopLoss",
            |m: &ProtoOANewOrderReq| { &m.guaranteedStopLoss },
            |m: &mut ProtoOANewOrderReq| { &mut m.guaranteedStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailingStopLoss",
            |m: &ProtoOANewOrderReq| { &m.trailingStopLoss },
            |m: &mut ProtoOANewOrderReq| { &mut m.trailingStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopTriggerMethod",
            |m: &ProtoOANewOrderReq| { &m.stopTriggerMethod },
            |m: &mut ProtoOANewOrderReq| { &mut m.stopTriggerMethod },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOANewOrderReq>(
            "ProtoOANewOrderReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOANewOrderReq {
    const NAME: &'static str = "ProtoOANewOrderReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        if self.orderType.is_none() {
            return false;
        }
        if self.tradeSide.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.orderType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.tradeSide = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                57 => {
                    self.limitPrice = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.stopPrice = ::std::option::Option::Some(is.read_double()?);
                },
                72 => {
                    self.timeInForce = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.expirationTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                89 => {
                    self.stopLoss = ::std::option::Option::Some(is.read_double()?);
                },
                97 => {
                    self.takeProfit = ::std::option::Option::Some(is.read_double()?);
                },
                106 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                113 => {
                    self.baseSlippagePrice = ::std::option::Option::Some(is.read_double()?);
                },
                120 => {
                    self.slippageInPoints = ::std::option::Option::Some(is.read_int32()?);
                },
                130 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                146 => {
                    self.clientOrderId = ::std::option::Option::Some(is.read_string()?);
                },
                152 => {
                    self.relativeStopLoss = ::std::option::Option::Some(is.read_int64()?);
                },
                160 => {
                    self.relativeTakeProfit = ::std::option::Option::Some(is.read_int64()?);
                },
                168 => {
                    self.guaranteedStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.trailingStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.stopTriggerMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.orderType {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.tradeSide {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.limitPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stopPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.timeInForce {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.expirationTimestamp {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.stopLoss {
            my_size += 1 + 8;
        }
        if let Some(v) = self.takeProfit {
            my_size += 1 + 8;
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.baseSlippagePrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.slippageInPoints {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(17, v);
        }
        if let Some(v) = self.clientOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(18, &v);
        }
        if let Some(v) = self.relativeStopLoss {
            my_size += ::protobuf::rt::int64_size(19, v);
        }
        if let Some(v) = self.relativeTakeProfit {
            my_size += ::protobuf::rt::int64_size(20, v);
        }
        if let Some(v) = self.guaranteedStopLoss {
            my_size += 2 + 1;
        }
        if let Some(v) = self.trailingStopLoss {
            my_size += 2 + 1;
        }
        if let Some(v) = self.stopTriggerMethod {
            my_size += ::protobuf::rt::int32_size(23, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.orderType {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tradeSide {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.volume {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.limitPrice {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.stopPrice {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.timeInForce {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.expirationTimestamp {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.stopLoss {
            os.write_double(11, v)?;
        }
        if let Some(v) = self.takeProfit {
            os.write_double(12, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(13, v)?;
        }
        if let Some(v) = self.baseSlippagePrice {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.slippageInPoints {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.clientOrderId.as_ref() {
            os.write_string(18, v)?;
        }
        if let Some(v) = self.relativeStopLoss {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.relativeTakeProfit {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.guaranteedStopLoss {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.trailingStopLoss {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.stopTriggerMethod {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOANewOrderReq {
        ProtoOANewOrderReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.orderType = ::std::option::Option::None;
        self.tradeSide = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.limitPrice = ::std::option::Option::None;
        self.stopPrice = ::std::option::Option::None;
        self.timeInForce = ::std::option::Option::None;
        self.expirationTimestamp = ::std::option::Option::None;
        self.stopLoss = ::std::option::Option::None;
        self.takeProfit = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.baseSlippagePrice = ::std::option::Option::None;
        self.slippageInPoints = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.clientOrderId = ::std::option::Option::None;
        self.relativeStopLoss = ::std::option::Option::None;
        self.relativeTakeProfit = ::std::option::Option::None;
        self.guaranteedStopLoss = ::std::option::Option::None;
        self.trailingStopLoss = ::std::option::Option::None;
        self.stopTriggerMethod = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOANewOrderReq {
        static instance: ProtoOANewOrderReq = ProtoOANewOrderReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            orderType: ::std::option::Option::None,
            tradeSide: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            limitPrice: ::std::option::Option::None,
            stopPrice: ::std::option::Option::None,
            timeInForce: ::std::option::Option::None,
            expirationTimestamp: ::std::option::Option::None,
            stopLoss: ::std::option::Option::None,
            takeProfit: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            baseSlippagePrice: ::std::option::Option::None,
            slippageInPoints: ::std::option::Option::None,
            label: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            clientOrderId: ::std::option::Option::None,
            relativeStopLoss: ::std::option::Option::None,
            relativeTakeProfit: ::std::option::Option::None,
            guaranteedStopLoss: ::std::option::Option::None,
            trailingStopLoss: ::std::option::Option::None,
            stopTriggerMethod: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOANewOrderReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOANewOrderReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOANewOrderReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOANewOrderReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAExecutionEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAExecutionEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.executionType)
    pub executionType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAExecutionType>>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.position)
    pub position: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOAPosition>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.order)
    pub order: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOAOrder>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.deal)
    pub deal: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOADeal>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.bonusDepositWithdraw)
    pub bonusDepositWithdraw: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOABonusDepositWithdraw>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.depositWithdraw)
    pub depositWithdraw: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOADepositWithdraw>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.errorCode)
    pub errorCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAExecutionEvent.isServerEvent)
    pub isServerEvent: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAExecutionEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAExecutionEvent {
    fn default() -> &'a ProtoOAExecutionEvent {
        <ProtoOAExecutionEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAExecutionEvent {
    pub fn new() -> ProtoOAExecutionEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_EXECUTION_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_EXECUTION_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required .ProtoOAExecutionType executionType = 3;

    pub fn executionType(&self) -> super::OpenApiModelMessages::ProtoOAExecutionType {
        match self.executionType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAExecutionType::ORDER_ACCEPTED),
            None => super::OpenApiModelMessages::ProtoOAExecutionType::ORDER_ACCEPTED,
        }
    }

    pub fn clear_executionType(&mut self) {
        self.executionType = ::std::option::Option::None;
    }

    pub fn has_executionType(&self) -> bool {
        self.executionType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionType(&mut self, v: super::OpenApiModelMessages::ProtoOAExecutionType) {
        self.executionType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string errorCode = 9;

    pub fn errorCode(&self) -> &str {
        match self.errorCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: ::std::string::String) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorCode(&mut self) -> &mut ::std::string::String {
        if self.errorCode.is_none() {
            self.errorCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errorCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorCode(&mut self) -> ::std::string::String {
        self.errorCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool isServerEvent = 10;

    pub fn isServerEvent(&self) -> bool {
        self.isServerEvent.unwrap_or(false)
    }

    pub fn clear_isServerEvent(&mut self) {
        self.isServerEvent = ::std::option::Option::None;
    }

    pub fn has_isServerEvent(&self) -> bool {
        self.isServerEvent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isServerEvent(&mut self, v: bool) {
        self.isServerEvent = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAExecutionEvent| { &m.payloadType },
            |m: &mut ProtoOAExecutionEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAExecutionEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAExecutionEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executionType",
            |m: &ProtoOAExecutionEvent| { &m.executionType },
            |m: &mut ProtoOAExecutionEvent| { &mut m.executionType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOAPosition>(
            "position",
            |m: &ProtoOAExecutionEvent| { &m.position },
            |m: &mut ProtoOAExecutionEvent| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOAOrder>(
            "order",
            |m: &ProtoOAExecutionEvent| { &m.order },
            |m: &mut ProtoOAExecutionEvent| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOADeal>(
            "deal",
            |m: &ProtoOAExecutionEvent| { &m.deal },
            |m: &mut ProtoOAExecutionEvent| { &mut m.deal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOABonusDepositWithdraw>(
            "bonusDepositWithdraw",
            |m: &ProtoOAExecutionEvent| { &m.bonusDepositWithdraw },
            |m: &mut ProtoOAExecutionEvent| { &mut m.bonusDepositWithdraw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOADepositWithdraw>(
            "depositWithdraw",
            |m: &ProtoOAExecutionEvent| { &m.depositWithdraw },
            |m: &mut ProtoOAExecutionEvent| { &mut m.depositWithdraw },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errorCode",
            |m: &ProtoOAExecutionEvent| { &m.errorCode },
            |m: &mut ProtoOAExecutionEvent| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isServerEvent",
            |m: &ProtoOAExecutionEvent| { &m.isServerEvent },
            |m: &mut ProtoOAExecutionEvent| { &mut m.isServerEvent },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAExecutionEvent>(
            "ProtoOAExecutionEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAExecutionEvent {
    const NAME: &'static str = "ProtoOAExecutionEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.executionType.is_none() {
            return false;
        }
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bonusDepositWithdraw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.depositWithdraw {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.executionType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.deal)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.bonusDepositWithdraw)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.depositWithdraw)?;
                },
                74 => {
                    self.errorCode = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.isServerEvent = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.executionType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.deal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bonusDepositWithdraw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.depositWithdraw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.errorCode.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.isServerEvent {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.executionType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.deal.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bonusDepositWithdraw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.depositWithdraw.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.errorCode.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.isServerEvent {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAExecutionEvent {
        ProtoOAExecutionEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.executionType = ::std::option::Option::None;
        self.position.clear();
        self.order.clear();
        self.deal.clear();
        self.bonusDepositWithdraw.clear();
        self.depositWithdraw.clear();
        self.errorCode = ::std::option::Option::None;
        self.isServerEvent = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAExecutionEvent {
        static instance: ProtoOAExecutionEvent = ProtoOAExecutionEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            executionType: ::std::option::Option::None,
            position: ::protobuf::MessageField::none(),
            order: ::protobuf::MessageField::none(),
            deal: ::protobuf::MessageField::none(),
            bonusDepositWithdraw: ::protobuf::MessageField::none(),
            depositWithdraw: ::protobuf::MessageField::none(),
            errorCode: ::std::option::Option::None,
            isServerEvent: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAExecutionEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAExecutionEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAExecutionEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAExecutionEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOACancelOrderReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOACancelOrderReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOACancelOrderReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOACancelOrderReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACancelOrderReq.orderId)
    pub orderId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOACancelOrderReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOACancelOrderReq {
    fn default() -> &'a ProtoOACancelOrderReq {
        <ProtoOACancelOrderReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOACancelOrderReq {
    pub fn new() -> ProtoOACancelOrderReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CANCEL_ORDER_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CANCEL_ORDER_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 orderId = 3;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOACancelOrderReq| { &m.payloadType },
            |m: &mut ProtoOACancelOrderReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOACancelOrderReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOACancelOrderReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOACancelOrderReq| { &m.orderId },
            |m: &mut ProtoOACancelOrderReq| { &mut m.orderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOACancelOrderReq>(
            "ProtoOACancelOrderReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOACancelOrderReq {
    const NAME: &'static str = "ProtoOACancelOrderReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.orderId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.orderId {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOACancelOrderReq {
        ProtoOACancelOrderReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.orderId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOACancelOrderReq {
        static instance: ProtoOACancelOrderReq = ProtoOACancelOrderReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            orderId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOACancelOrderReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOACancelOrderReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOACancelOrderReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOACancelOrderReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAmendOrderReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAmendOrderReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.orderId)
    pub orderId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.limitPrice)
    pub limitPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.stopPrice)
    pub stopPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.expirationTimestamp)
    pub expirationTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.stopLoss)
    pub stopLoss: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.takeProfit)
    pub takeProfit: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.slippageInPoints)
    pub slippageInPoints: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.relativeStopLoss)
    pub relativeStopLoss: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.relativeTakeProfit)
    pub relativeTakeProfit: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.guaranteedStopLoss)
    pub guaranteedStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.trailingStopLoss)
    pub trailingStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAAmendOrderReq.stopTriggerMethod)
    pub stopTriggerMethod: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAOrderTriggerMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAmendOrderReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAmendOrderReq {
    fn default() -> &'a ProtoOAAmendOrderReq {
        <ProtoOAAmendOrderReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAmendOrderReq {
    pub fn new() -> ProtoOAAmendOrderReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_AMEND_ORDER_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_AMEND_ORDER_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 orderId = 3;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // optional int64 volume = 4;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // optional double limitPrice = 5;

    pub fn limitPrice(&self) -> f64 {
        self.limitPrice.unwrap_or(0.)
    }

    pub fn clear_limitPrice(&mut self) {
        self.limitPrice = ::std::option::Option::None;
    }

    pub fn has_limitPrice(&self) -> bool {
        self.limitPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitPrice(&mut self, v: f64) {
        self.limitPrice = ::std::option::Option::Some(v);
    }

    // optional double stopPrice = 6;

    pub fn stopPrice(&self) -> f64 {
        self.stopPrice.unwrap_or(0.)
    }

    pub fn clear_stopPrice(&mut self) {
        self.stopPrice = ::std::option::Option::None;
    }

    pub fn has_stopPrice(&self) -> bool {
        self.stopPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopPrice(&mut self, v: f64) {
        self.stopPrice = ::std::option::Option::Some(v);
    }

    // optional int64 expirationTimestamp = 7;

    pub fn expirationTimestamp(&self) -> i64 {
        self.expirationTimestamp.unwrap_or(0)
    }

    pub fn clear_expirationTimestamp(&mut self) {
        self.expirationTimestamp = ::std::option::Option::None;
    }

    pub fn has_expirationTimestamp(&self) -> bool {
        self.expirationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationTimestamp(&mut self, v: i64) {
        self.expirationTimestamp = ::std::option::Option::Some(v);
    }

    // optional double stopLoss = 8;

    pub fn stopLoss(&self) -> f64 {
        self.stopLoss.unwrap_or(0.)
    }

    pub fn clear_stopLoss(&mut self) {
        self.stopLoss = ::std::option::Option::None;
    }

    pub fn has_stopLoss(&self) -> bool {
        self.stopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLoss(&mut self, v: f64) {
        self.stopLoss = ::std::option::Option::Some(v);
    }

    // optional double takeProfit = 9;

    pub fn takeProfit(&self) -> f64 {
        self.takeProfit.unwrap_or(0.)
    }

    pub fn clear_takeProfit(&mut self) {
        self.takeProfit = ::std::option::Option::None;
    }

    pub fn has_takeProfit(&self) -> bool {
        self.takeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_takeProfit(&mut self, v: f64) {
        self.takeProfit = ::std::option::Option::Some(v);
    }

    // optional int32 slippageInPoints = 10;

    pub fn slippageInPoints(&self) -> i32 {
        self.slippageInPoints.unwrap_or(0)
    }

    pub fn clear_slippageInPoints(&mut self) {
        self.slippageInPoints = ::std::option::Option::None;
    }

    pub fn has_slippageInPoints(&self) -> bool {
        self.slippageInPoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slippageInPoints(&mut self, v: i32) {
        self.slippageInPoints = ::std::option::Option::Some(v);
    }

    // optional int64 relativeStopLoss = 11;

    pub fn relativeStopLoss(&self) -> i64 {
        self.relativeStopLoss.unwrap_or(0)
    }

    pub fn clear_relativeStopLoss(&mut self) {
        self.relativeStopLoss = ::std::option::Option::None;
    }

    pub fn has_relativeStopLoss(&self) -> bool {
        self.relativeStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relativeStopLoss(&mut self, v: i64) {
        self.relativeStopLoss = ::std::option::Option::Some(v);
    }

    // optional int64 relativeTakeProfit = 12;

    pub fn relativeTakeProfit(&self) -> i64 {
        self.relativeTakeProfit.unwrap_or(0)
    }

    pub fn clear_relativeTakeProfit(&mut self) {
        self.relativeTakeProfit = ::std::option::Option::None;
    }

    pub fn has_relativeTakeProfit(&self) -> bool {
        self.relativeTakeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relativeTakeProfit(&mut self, v: i64) {
        self.relativeTakeProfit = ::std::option::Option::Some(v);
    }

    // optional bool guaranteedStopLoss = 13;

    pub fn guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.unwrap_or(false)
    }

    pub fn clear_guaranteedStopLoss(&mut self) {
        self.guaranteedStopLoss = ::std::option::Option::None;
    }

    pub fn has_guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guaranteedStopLoss(&mut self, v: bool) {
        self.guaranteedStopLoss = ::std::option::Option::Some(v);
    }

    // optional bool trailingStopLoss = 14;

    pub fn trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.unwrap_or(false)
    }

    pub fn clear_trailingStopLoss(&mut self) {
        self.trailingStopLoss = ::std::option::Option::None;
    }

    pub fn has_trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailingStopLoss(&mut self, v: bool) {
        self.trailingStopLoss = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAOrderTriggerMethod stopTriggerMethod = 15;

    pub fn stopTriggerMethod(&self) -> super::OpenApiModelMessages::ProtoOAOrderTriggerMethod {
        match self.stopTriggerMethod {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAOrderTriggerMethod::TRADE),
            None => super::OpenApiModelMessages::ProtoOAOrderTriggerMethod::TRADE,
        }
    }

    pub fn clear_stopTriggerMethod(&mut self) {
        self.stopTriggerMethod = ::std::option::Option::None;
    }

    pub fn has_stopTriggerMethod(&self) -> bool {
        self.stopTriggerMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopTriggerMethod(&mut self, v: super::OpenApiModelMessages::ProtoOAOrderTriggerMethod) {
        self.stopTriggerMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAmendOrderReq| { &m.payloadType },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAmendOrderReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOAAmendOrderReq| { &m.orderId },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOAAmendOrderReq| { &m.volume },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limitPrice",
            |m: &ProtoOAAmendOrderReq| { &m.limitPrice },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.limitPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopPrice",
            |m: &ProtoOAAmendOrderReq| { &m.stopPrice },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.stopPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expirationTimestamp",
            |m: &ProtoOAAmendOrderReq| { &m.expirationTimestamp },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.expirationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLoss",
            |m: &ProtoOAAmendOrderReq| { &m.stopLoss },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.stopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "takeProfit",
            |m: &ProtoOAAmendOrderReq| { &m.takeProfit },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.takeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slippageInPoints",
            |m: &ProtoOAAmendOrderReq| { &m.slippageInPoints },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.slippageInPoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relativeStopLoss",
            |m: &ProtoOAAmendOrderReq| { &m.relativeStopLoss },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.relativeStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relativeTakeProfit",
            |m: &ProtoOAAmendOrderReq| { &m.relativeTakeProfit },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.relativeTakeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guaranteedStopLoss",
            |m: &ProtoOAAmendOrderReq| { &m.guaranteedStopLoss },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.guaranteedStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailingStopLoss",
            |m: &ProtoOAAmendOrderReq| { &m.trailingStopLoss },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.trailingStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopTriggerMethod",
            |m: &ProtoOAAmendOrderReq| { &m.stopTriggerMethod },
            |m: &mut ProtoOAAmendOrderReq| { &mut m.stopTriggerMethod },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAmendOrderReq>(
            "ProtoOAAmendOrderReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAmendOrderReq {
    const NAME: &'static str = "ProtoOAAmendOrderReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.orderId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                41 => {
                    self.limitPrice = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.stopPrice = ::std::option::Option::Some(is.read_double()?);
                },
                56 => {
                    self.expirationTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                65 => {
                    self.stopLoss = ::std::option::Option::Some(is.read_double()?);
                },
                73 => {
                    self.takeProfit = ::std::option::Option::Some(is.read_double()?);
                },
                80 => {
                    self.slippageInPoints = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.relativeStopLoss = ::std::option::Option::Some(is.read_int64()?);
                },
                96 => {
                    self.relativeTakeProfit = ::std::option::Option::Some(is.read_int64()?);
                },
                104 => {
                    self.guaranteedStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.trailingStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.stopTriggerMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.limitPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stopPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expirationTimestamp {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.stopLoss {
            my_size += 1 + 8;
        }
        if let Some(v) = self.takeProfit {
            my_size += 1 + 8;
        }
        if let Some(v) = self.slippageInPoints {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.relativeStopLoss {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        if let Some(v) = self.relativeTakeProfit {
            my_size += ::protobuf::rt::int64_size(12, v);
        }
        if let Some(v) = self.guaranteedStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trailingStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stopTriggerMethod {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.orderId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.limitPrice {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.stopPrice {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.expirationTimestamp {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.stopLoss {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.takeProfit {
            os.write_double(9, v)?;
        }
        if let Some(v) = self.slippageInPoints {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.relativeStopLoss {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.relativeTakeProfit {
            os.write_int64(12, v)?;
        }
        if let Some(v) = self.guaranteedStopLoss {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.trailingStopLoss {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.stopTriggerMethod {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAmendOrderReq {
        ProtoOAAmendOrderReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.orderId = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.limitPrice = ::std::option::Option::None;
        self.stopPrice = ::std::option::Option::None;
        self.expirationTimestamp = ::std::option::Option::None;
        self.stopLoss = ::std::option::Option::None;
        self.takeProfit = ::std::option::Option::None;
        self.slippageInPoints = ::std::option::Option::None;
        self.relativeStopLoss = ::std::option::Option::None;
        self.relativeTakeProfit = ::std::option::Option::None;
        self.guaranteedStopLoss = ::std::option::Option::None;
        self.trailingStopLoss = ::std::option::Option::None;
        self.stopTriggerMethod = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAmendOrderReq {
        static instance: ProtoOAAmendOrderReq = ProtoOAAmendOrderReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            orderId: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            limitPrice: ::std::option::Option::None,
            stopPrice: ::std::option::Option::None,
            expirationTimestamp: ::std::option::Option::None,
            stopLoss: ::std::option::Option::None,
            takeProfit: ::std::option::Option::None,
            slippageInPoints: ::std::option::Option::None,
            relativeStopLoss: ::std::option::Option::None,
            relativeTakeProfit: ::std::option::Option::None,
            guaranteedStopLoss: ::std::option::Option::None,
            trailingStopLoss: ::std::option::Option::None,
            stopTriggerMethod: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAmendOrderReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAmendOrderReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAmendOrderReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAmendOrderReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAmendPositionSLTPReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAmendPositionSLTPReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.stopLoss)
    pub stopLoss: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.takeProfit)
    pub takeProfit: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.guaranteedStopLoss)
    pub guaranteedStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.trailingStopLoss)
    pub trailingStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAAmendPositionSLTPReq.stopLossTriggerMethod)
    pub stopLossTriggerMethod: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAOrderTriggerMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAmendPositionSLTPReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAmendPositionSLTPReq {
    fn default() -> &'a ProtoOAAmendPositionSLTPReq {
        <ProtoOAAmendPositionSLTPReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAmendPositionSLTPReq {
    pub fn new() -> ProtoOAAmendPositionSLTPReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_AMEND_POSITION_SLTP_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_AMEND_POSITION_SLTP_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 positionId = 3;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // optional double stopLoss = 4;

    pub fn stopLoss(&self) -> f64 {
        self.stopLoss.unwrap_or(0.)
    }

    pub fn clear_stopLoss(&mut self) {
        self.stopLoss = ::std::option::Option::None;
    }

    pub fn has_stopLoss(&self) -> bool {
        self.stopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLoss(&mut self, v: f64) {
        self.stopLoss = ::std::option::Option::Some(v);
    }

    // optional double takeProfit = 5;

    pub fn takeProfit(&self) -> f64 {
        self.takeProfit.unwrap_or(0.)
    }

    pub fn clear_takeProfit(&mut self) {
        self.takeProfit = ::std::option::Option::None;
    }

    pub fn has_takeProfit(&self) -> bool {
        self.takeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_takeProfit(&mut self, v: f64) {
        self.takeProfit = ::std::option::Option::Some(v);
    }

    // optional bool guaranteedStopLoss = 7;

    pub fn guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.unwrap_or(false)
    }

    pub fn clear_guaranteedStopLoss(&mut self) {
        self.guaranteedStopLoss = ::std::option::Option::None;
    }

    pub fn has_guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guaranteedStopLoss(&mut self, v: bool) {
        self.guaranteedStopLoss = ::std::option::Option::Some(v);
    }

    // optional bool trailingStopLoss = 8;

    pub fn trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.unwrap_or(false)
    }

    pub fn clear_trailingStopLoss(&mut self) {
        self.trailingStopLoss = ::std::option::Option::None;
    }

    pub fn has_trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailingStopLoss(&mut self, v: bool) {
        self.trailingStopLoss = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAOrderTriggerMethod stopLossTriggerMethod = 9;

    pub fn stopLossTriggerMethod(&self) -> super::OpenApiModelMessages::ProtoOAOrderTriggerMethod {
        match self.stopLossTriggerMethod {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAOrderTriggerMethod::TRADE),
            None => super::OpenApiModelMessages::ProtoOAOrderTriggerMethod::TRADE,
        }
    }

    pub fn clear_stopLossTriggerMethod(&mut self) {
        self.stopLossTriggerMethod = ::std::option::Option::None;
    }

    pub fn has_stopLossTriggerMethod(&self) -> bool {
        self.stopLossTriggerMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLossTriggerMethod(&mut self, v: super::OpenApiModelMessages::ProtoOAOrderTriggerMethod) {
        self.stopLossTriggerMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.payloadType },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.positionId },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLoss",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.stopLoss },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.stopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "takeProfit",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.takeProfit },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.takeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guaranteedStopLoss",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.guaranteedStopLoss },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.guaranteedStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailingStopLoss",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.trailingStopLoss },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.trailingStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLossTriggerMethod",
            |m: &ProtoOAAmendPositionSLTPReq| { &m.stopLossTriggerMethod },
            |m: &mut ProtoOAAmendPositionSLTPReq| { &mut m.stopLossTriggerMethod },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAmendPositionSLTPReq>(
            "ProtoOAAmendPositionSLTPReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAmendPositionSLTPReq {
    const NAME: &'static str = "ProtoOAAmendPositionSLTPReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                33 => {
                    self.stopLoss = ::std::option::Option::Some(is.read_double()?);
                },
                41 => {
                    self.takeProfit = ::std::option::Option::Some(is.read_double()?);
                },
                56 => {
                    self.guaranteedStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.trailingStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.stopLossTriggerMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.stopLoss {
            my_size += 1 + 8;
        }
        if let Some(v) = self.takeProfit {
            my_size += 1 + 8;
        }
        if let Some(v) = self.guaranteedStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trailingStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.stopLossTriggerMethod {
            my_size += ::protobuf::rt::int32_size(9, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.stopLoss {
            os.write_double(4, v)?;
        }
        if let Some(v) = self.takeProfit {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.guaranteedStopLoss {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.trailingStopLoss {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.stopLossTriggerMethod {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAmendPositionSLTPReq {
        ProtoOAAmendPositionSLTPReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.stopLoss = ::std::option::Option::None;
        self.takeProfit = ::std::option::Option::None;
        self.guaranteedStopLoss = ::std::option::Option::None;
        self.trailingStopLoss = ::std::option::Option::None;
        self.stopLossTriggerMethod = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAmendPositionSLTPReq {
        static instance: ProtoOAAmendPositionSLTPReq = ProtoOAAmendPositionSLTPReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            stopLoss: ::std::option::Option::None,
            takeProfit: ::std::option::Option::None,
            guaranteedStopLoss: ::std::option::Option::None,
            trailingStopLoss: ::std::option::Option::None,
            stopLossTriggerMethod: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAmendPositionSLTPReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAmendPositionSLTPReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAmendPositionSLTPReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAmendPositionSLTPReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAClosePositionReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAClosePositionReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAClosePositionReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionReq.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionReq.volume)
    pub volume: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAClosePositionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAClosePositionReq {
    fn default() -> &'a ProtoOAClosePositionReq {
        <ProtoOAClosePositionReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAClosePositionReq {
    pub fn new() -> ProtoOAClosePositionReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CLOSE_POSITION_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CLOSE_POSITION_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 positionId = 3;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // required int64 volume = 4;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAClosePositionReq| { &m.payloadType },
            |m: &mut ProtoOAClosePositionReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAClosePositionReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAClosePositionReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAClosePositionReq| { &m.positionId },
            |m: &mut ProtoOAClosePositionReq| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOAClosePositionReq| { &m.volume },
            |m: &mut ProtoOAClosePositionReq| { &mut m.volume },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAClosePositionReq>(
            "ProtoOAClosePositionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAClosePositionReq {
    const NAME: &'static str = "ProtoOAClosePositionReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAClosePositionReq {
        ProtoOAClosePositionReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAClosePositionReq {
        static instance: ProtoOAClosePositionReq = ProtoOAClosePositionReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAClosePositionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAClosePositionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAClosePositionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAClosePositionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATrailingSLChangedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATrailingSLChangedEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATrailingSLChangedEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOATrailingSLChangedEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrailingSLChangedEvent.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrailingSLChangedEvent.orderId)
    pub orderId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrailingSLChangedEvent.stopPrice)
    pub stopPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOATrailingSLChangedEvent.utcLastUpdateTimestamp)
    pub utcLastUpdateTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATrailingSLChangedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATrailingSLChangedEvent {
    fn default() -> &'a ProtoOATrailingSLChangedEvent {
        <ProtoOATrailingSLChangedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATrailingSLChangedEvent {
    pub fn new() -> ProtoOATrailingSLChangedEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRAILING_SL_CHANGED_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRAILING_SL_CHANGED_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 positionId = 3;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // required int64 orderId = 4;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // required double stopPrice = 5;

    pub fn stopPrice(&self) -> f64 {
        self.stopPrice.unwrap_or(0.)
    }

    pub fn clear_stopPrice(&mut self) {
        self.stopPrice = ::std::option::Option::None;
    }

    pub fn has_stopPrice(&self) -> bool {
        self.stopPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopPrice(&mut self, v: f64) {
        self.stopPrice = ::std::option::Option::Some(v);
    }

    // required int64 utcLastUpdateTimestamp = 6;

    pub fn utcLastUpdateTimestamp(&self) -> i64 {
        self.utcLastUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_utcLastUpdateTimestamp(&mut self) {
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_utcLastUpdateTimestamp(&self) -> bool {
        self.utcLastUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcLastUpdateTimestamp(&mut self, v: i64) {
        self.utcLastUpdateTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOATrailingSLChangedEvent| { &m.payloadType },
            |m: &mut ProtoOATrailingSLChangedEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOATrailingSLChangedEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOATrailingSLChangedEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOATrailingSLChangedEvent| { &m.positionId },
            |m: &mut ProtoOATrailingSLChangedEvent| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOATrailingSLChangedEvent| { &m.orderId },
            |m: &mut ProtoOATrailingSLChangedEvent| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopPrice",
            |m: &ProtoOATrailingSLChangedEvent| { &m.stopPrice },
            |m: &mut ProtoOATrailingSLChangedEvent| { &mut m.stopPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcLastUpdateTimestamp",
            |m: &ProtoOATrailingSLChangedEvent| { &m.utcLastUpdateTimestamp },
            |m: &mut ProtoOATrailingSLChangedEvent| { &mut m.utcLastUpdateTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATrailingSLChangedEvent>(
            "ProtoOATrailingSLChangedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATrailingSLChangedEvent {
    const NAME: &'static str = "ProtoOATrailingSLChangedEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        if self.orderId.is_none() {
            return false;
        }
        if self.stopPrice.is_none() {
            return false;
        }
        if self.utcLastUpdateTimestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                41 => {
                    self.stopPrice = ::std::option::Option::Some(is.read_double()?);
                },
                48 => {
                    self.utcLastUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.stopPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.orderId {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.stopPrice {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATrailingSLChangedEvent {
        ProtoOATrailingSLChangedEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.orderId = ::std::option::Option::None;
        self.stopPrice = ::std::option::Option::None;
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATrailingSLChangedEvent {
        static instance: ProtoOATrailingSLChangedEvent = ProtoOATrailingSLChangedEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            orderId: ::std::option::Option::None,
            stopPrice: ::std::option::Option::None,
            utcLastUpdateTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATrailingSLChangedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATrailingSLChangedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATrailingSLChangedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATrailingSLChangedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAssetListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAssetListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAssetListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAssetListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAssetListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAssetListReq {
    fn default() -> &'a ProtoOAAssetListReq {
        <ProtoOAAssetListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAssetListReq {
    pub fn new() -> ProtoOAAssetListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAssetListReq| { &m.payloadType },
            |m: &mut ProtoOAAssetListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAssetListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAssetListReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAssetListReq>(
            "ProtoOAAssetListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAssetListReq {
    const NAME: &'static str = "ProtoOAAssetListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAssetListReq {
        ProtoOAAssetListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAssetListReq {
        static instance: ProtoOAAssetListReq = ProtoOAAssetListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAssetListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAssetListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAssetListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAssetListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAssetListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAssetListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAssetListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAssetListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAssetListRes.asset)
    pub asset: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAAsset>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAssetListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAssetListRes {
    fn default() -> &'a ProtoOAAssetListRes {
        <ProtoOAAssetListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAssetListRes {
    pub fn new() -> ProtoOAAssetListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAssetListRes| { &m.payloadType },
            |m: &mut ProtoOAAssetListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAssetListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAssetListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "asset",
            |m: &ProtoOAAssetListRes| { &m.asset },
            |m: &mut ProtoOAAssetListRes| { &mut m.asset },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAssetListRes>(
            "ProtoOAAssetListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAssetListRes {
    const NAME: &'static str = "ProtoOAAssetListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.asset {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.asset.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.asset {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.asset {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAssetListRes {
        ProtoOAAssetListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.asset.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAssetListRes {
        static instance: ProtoOAAssetListRes = ProtoOAAssetListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            asset: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAssetListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAssetListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAssetListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAssetListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolsListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolsListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolsListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolsListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolsListReq.includeArchivedSymbols)
    pub includeArchivedSymbols: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolsListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolsListReq {
    fn default() -> &'a ProtoOASymbolsListReq {
        <ProtoOASymbolsListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolsListReq {
    pub fn new() -> ProtoOASymbolsListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional bool includeArchivedSymbols = 3;

    pub fn includeArchivedSymbols(&self) -> bool {
        self.includeArchivedSymbols.unwrap_or(false)
    }

    pub fn clear_includeArchivedSymbols(&mut self) {
        self.includeArchivedSymbols = ::std::option::Option::None;
    }

    pub fn has_includeArchivedSymbols(&self) -> bool {
        self.includeArchivedSymbols.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeArchivedSymbols(&mut self, v: bool) {
        self.includeArchivedSymbols = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolsListReq| { &m.payloadType },
            |m: &mut ProtoOASymbolsListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolsListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolsListReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "includeArchivedSymbols",
            |m: &ProtoOASymbolsListReq| { &m.includeArchivedSymbols },
            |m: &mut ProtoOASymbolsListReq| { &mut m.includeArchivedSymbols },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolsListReq>(
            "ProtoOASymbolsListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolsListReq {
    const NAME: &'static str = "ProtoOASymbolsListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.includeArchivedSymbols = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.includeArchivedSymbols {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.includeArchivedSymbols {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolsListReq {
        ProtoOASymbolsListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.includeArchivedSymbols = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolsListReq {
        static instance: ProtoOASymbolsListReq = ProtoOASymbolsListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            includeArchivedSymbols: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolsListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolsListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolsListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolsListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolsListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolsListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolsListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolsListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolsListRes.symbol)
    pub symbol: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOALightSymbol>,
    // @@protoc_insertion_point(field:ProtoOASymbolsListRes.archivedSymbol)
    pub archivedSymbol: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAArchivedSymbol>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolsListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolsListRes {
    fn default() -> &'a ProtoOASymbolsListRes {
        <ProtoOASymbolsListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolsListRes {
    pub fn new() -> ProtoOASymbolsListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolsListRes| { &m.payloadType },
            |m: &mut ProtoOASymbolsListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolsListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolsListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbol",
            |m: &ProtoOASymbolsListRes| { &m.symbol },
            |m: &mut ProtoOASymbolsListRes| { &mut m.symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "archivedSymbol",
            |m: &ProtoOASymbolsListRes| { &m.archivedSymbol },
            |m: &mut ProtoOASymbolsListRes| { &mut m.archivedSymbol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolsListRes>(
            "ProtoOASymbolsListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolsListRes {
    const NAME: &'static str = "ProtoOASymbolsListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.symbol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.archivedSymbol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.symbol.push(is.read_message()?);
                },
                34 => {
                    self.archivedSymbol.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbol {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.archivedSymbol {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbol {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.archivedSymbol {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolsListRes {
        ProtoOASymbolsListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbol.clear();
        self.archivedSymbol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolsListRes {
        static instance: ProtoOASymbolsListRes = ProtoOASymbolsListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbol: ::std::vec::Vec::new(),
            archivedSymbol: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolsListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolsListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolsListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolsListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolByIdReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolByIdReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolByIdReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolByIdReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolByIdReq.symbolId)
    pub symbolId: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolByIdReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolByIdReq {
    fn default() -> &'a ProtoOASymbolByIdReq {
        <ProtoOASymbolByIdReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolByIdReq {
    pub fn new() -> ProtoOASymbolByIdReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolByIdReq| { &m.payloadType },
            |m: &mut ProtoOASymbolByIdReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolByIdReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolByIdReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASymbolByIdReq| { &m.symbolId },
            |m: &mut ProtoOASymbolByIdReq| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolByIdReq>(
            "ProtoOASymbolByIdReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolByIdReq {
    const NAME: &'static str = "ProtoOASymbolByIdReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.symbolId)?;
                },
                24 => {
                    self.symbolId.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolId {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolByIdReq {
        ProtoOASymbolByIdReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolByIdReq {
        static instance: ProtoOASymbolByIdReq = ProtoOASymbolByIdReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolByIdReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolByIdReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolByIdReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolByIdReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolByIdRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolByIdRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolByIdRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolByIdRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolByIdRes.symbol)
    pub symbol: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOASymbol>,
    // @@protoc_insertion_point(field:ProtoOASymbolByIdRes.archivedSymbol)
    pub archivedSymbol: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAArchivedSymbol>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolByIdRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolByIdRes {
    fn default() -> &'a ProtoOASymbolByIdRes {
        <ProtoOASymbolByIdRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolByIdRes {
    pub fn new() -> ProtoOASymbolByIdRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolByIdRes| { &m.payloadType },
            |m: &mut ProtoOASymbolByIdRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolByIdRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolByIdRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbol",
            |m: &ProtoOASymbolByIdRes| { &m.symbol },
            |m: &mut ProtoOASymbolByIdRes| { &mut m.symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "archivedSymbol",
            |m: &ProtoOASymbolByIdRes| { &m.archivedSymbol },
            |m: &mut ProtoOASymbolByIdRes| { &mut m.archivedSymbol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolByIdRes>(
            "ProtoOASymbolByIdRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolByIdRes {
    const NAME: &'static str = "ProtoOASymbolByIdRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.symbol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.archivedSymbol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.symbol.push(is.read_message()?);
                },
                34 => {
                    self.archivedSymbol.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbol {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.archivedSymbol {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbol {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.archivedSymbol {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolByIdRes {
        ProtoOASymbolByIdRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbol.clear();
        self.archivedSymbol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolByIdRes {
        static instance: ProtoOASymbolByIdRes = ProtoOASymbolByIdRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbol: ::std::vec::Vec::new(),
            archivedSymbol: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolByIdRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolByIdRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolByIdRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolByIdRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolsForConversionReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolsForConversionReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionReq.firstAssetId)
    pub firstAssetId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionReq.lastAssetId)
    pub lastAssetId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolsForConversionReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolsForConversionReq {
    fn default() -> &'a ProtoOASymbolsForConversionReq {
        <ProtoOASymbolsForConversionReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolsForConversionReq {
    pub fn new() -> ProtoOASymbolsForConversionReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 firstAssetId = 3;

    pub fn firstAssetId(&self) -> i64 {
        self.firstAssetId.unwrap_or(0)
    }

    pub fn clear_firstAssetId(&mut self) {
        self.firstAssetId = ::std::option::Option::None;
    }

    pub fn has_firstAssetId(&self) -> bool {
        self.firstAssetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstAssetId(&mut self, v: i64) {
        self.firstAssetId = ::std::option::Option::Some(v);
    }

    // required int64 lastAssetId = 4;

    pub fn lastAssetId(&self) -> i64 {
        self.lastAssetId.unwrap_or(0)
    }

    pub fn clear_lastAssetId(&mut self) {
        self.lastAssetId = ::std::option::Option::None;
    }

    pub fn has_lastAssetId(&self) -> bool {
        self.lastAssetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastAssetId(&mut self, v: i64) {
        self.lastAssetId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolsForConversionReq| { &m.payloadType },
            |m: &mut ProtoOASymbolsForConversionReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolsForConversionReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolsForConversionReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "firstAssetId",
            |m: &ProtoOASymbolsForConversionReq| { &m.firstAssetId },
            |m: &mut ProtoOASymbolsForConversionReq| { &mut m.firstAssetId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastAssetId",
            |m: &ProtoOASymbolsForConversionReq| { &m.lastAssetId },
            |m: &mut ProtoOASymbolsForConversionReq| { &mut m.lastAssetId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolsForConversionReq>(
            "ProtoOASymbolsForConversionReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolsForConversionReq {
    const NAME: &'static str = "ProtoOASymbolsForConversionReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.firstAssetId.is_none() {
            return false;
        }
        if self.lastAssetId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.firstAssetId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.lastAssetId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.firstAssetId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.lastAssetId {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.firstAssetId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.lastAssetId {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolsForConversionReq {
        ProtoOASymbolsForConversionReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.firstAssetId = ::std::option::Option::None;
        self.lastAssetId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolsForConversionReq {
        static instance: ProtoOASymbolsForConversionReq = ProtoOASymbolsForConversionReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            firstAssetId: ::std::option::Option::None,
            lastAssetId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolsForConversionReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolsForConversionReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolsForConversionReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolsForConversionReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolsForConversionRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolsForConversionRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolsForConversionRes.symbol)
    pub symbol: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOALightSymbol>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolsForConversionRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolsForConversionRes {
    fn default() -> &'a ProtoOASymbolsForConversionRes {
        <ProtoOASymbolsForConversionRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolsForConversionRes {
    pub fn new() -> ProtoOASymbolsForConversionRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolsForConversionRes| { &m.payloadType },
            |m: &mut ProtoOASymbolsForConversionRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolsForConversionRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolsForConversionRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbol",
            |m: &ProtoOASymbolsForConversionRes| { &m.symbol },
            |m: &mut ProtoOASymbolsForConversionRes| { &mut m.symbol },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolsForConversionRes>(
            "ProtoOASymbolsForConversionRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolsForConversionRes {
    const NAME: &'static str = "ProtoOASymbolsForConversionRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.symbol {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.symbol.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbol {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbol {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolsForConversionRes {
        ProtoOASymbolsForConversionRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbol.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolsForConversionRes {
        static instance: ProtoOASymbolsForConversionRes = ProtoOASymbolsForConversionRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbol: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolsForConversionRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolsForConversionRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolsForConversionRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolsForConversionRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolChangedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolChangedEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolChangedEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolChangedEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolChangedEvent.symbolId)
    pub symbolId: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolChangedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolChangedEvent {
    fn default() -> &'a ProtoOASymbolChangedEvent {
        <ProtoOASymbolChangedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolChangedEvent {
    pub fn new() -> ProtoOASymbolChangedEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_CHANGED_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_CHANGED_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolChangedEvent| { &m.payloadType },
            |m: &mut ProtoOASymbolChangedEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolChangedEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolChangedEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASymbolChangedEvent| { &m.symbolId },
            |m: &mut ProtoOASymbolChangedEvent| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolChangedEvent>(
            "ProtoOASymbolChangedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolChangedEvent {
    const NAME: &'static str = "ProtoOASymbolChangedEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.symbolId)?;
                },
                24 => {
                    self.symbolId.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolId {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolChangedEvent {
        ProtoOASymbolChangedEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolChangedEvent {
        static instance: ProtoOASymbolChangedEvent = ProtoOASymbolChangedEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolChangedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolChangedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolChangedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolChangedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAssetClassListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAssetClassListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAssetClassListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAssetClassListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAssetClassListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAssetClassListReq {
    fn default() -> &'a ProtoOAAssetClassListReq {
        <ProtoOAAssetClassListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAssetClassListReq {
    pub fn new() -> ProtoOAAssetClassListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAssetClassListReq| { &m.payloadType },
            |m: &mut ProtoOAAssetClassListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAssetClassListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAssetClassListReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAssetClassListReq>(
            "ProtoOAAssetClassListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAssetClassListReq {
    const NAME: &'static str = "ProtoOAAssetClassListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAssetClassListReq {
        ProtoOAAssetClassListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAssetClassListReq {
        static instance: ProtoOAAssetClassListReq = ProtoOAAssetClassListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAssetClassListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAssetClassListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAssetClassListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAssetClassListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAssetClassListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAssetClassListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAssetClassListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAssetClassListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAssetClassListRes.assetClass)
    pub assetClass: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAAssetClass>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAssetClassListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAssetClassListRes {
    fn default() -> &'a ProtoOAAssetClassListRes {
        <ProtoOAAssetClassListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAssetClassListRes {
    pub fn new() -> ProtoOAAssetClassListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAssetClassListRes| { &m.payloadType },
            |m: &mut ProtoOAAssetClassListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAssetClassListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAssetClassListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "assetClass",
            |m: &ProtoOAAssetClassListRes| { &m.assetClass },
            |m: &mut ProtoOAAssetClassListRes| { &mut m.assetClass },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAssetClassListRes>(
            "ProtoOAAssetClassListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAssetClassListRes {
    const NAME: &'static str = "ProtoOAAssetClassListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.assetClass {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.assetClass.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.assetClass {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.assetClass {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAssetClassListRes {
        ProtoOAAssetClassListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.assetClass.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAssetClassListRes {
        static instance: ProtoOAAssetClassListRes = ProtoOAAssetClassListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            assetClass: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAssetClassListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAssetClassListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAssetClassListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAssetClassListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATraderReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATraderReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATraderReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOATraderReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATraderReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATraderReq {
    fn default() -> &'a ProtoOATraderReq {
        <ProtoOATraderReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATraderReq {
    pub fn new() -> ProtoOATraderReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRADER_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRADER_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOATraderReq| { &m.payloadType },
            |m: &mut ProtoOATraderReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOATraderReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOATraderReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATraderReq>(
            "ProtoOATraderReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATraderReq {
    const NAME: &'static str = "ProtoOATraderReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATraderReq {
        ProtoOATraderReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATraderReq {
        static instance: ProtoOATraderReq = ProtoOATraderReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATraderReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATraderReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATraderReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATraderReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATraderRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATraderRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATraderRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOATraderRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATraderRes.trader)
    pub trader: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOATrader>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATraderRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATraderRes {
    fn default() -> &'a ProtoOATraderRes {
        <ProtoOATraderRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATraderRes {
    pub fn new() -> ProtoOATraderRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRADER_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRADER_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOATraderRes| { &m.payloadType },
            |m: &mut ProtoOATraderRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOATraderRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOATraderRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOATrader>(
            "trader",
            |m: &ProtoOATraderRes| { &m.trader },
            |m: &mut ProtoOATraderRes| { &mut m.trader },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATraderRes>(
            "ProtoOATraderRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATraderRes {
    const NAME: &'static str = "ProtoOATraderRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.trader.is_none() {
            return false;
        }
        for v in &self.trader {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trader)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.trader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.trader.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATraderRes {
        ProtoOATraderRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.trader.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATraderRes {
        static instance: ProtoOATraderRes = ProtoOATraderRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            trader: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATraderRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATraderRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATraderRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATraderRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATraderUpdatedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATraderUpdatedEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATraderUpdatedEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOATraderUpdatedEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATraderUpdatedEvent.trader)
    pub trader: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOATrader>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATraderUpdatedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATraderUpdatedEvent {
    fn default() -> &'a ProtoOATraderUpdatedEvent {
        <ProtoOATraderUpdatedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATraderUpdatedEvent {
    pub fn new() -> ProtoOATraderUpdatedEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRADER_UPDATE_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_TRADER_UPDATE_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOATraderUpdatedEvent| { &m.payloadType },
            |m: &mut ProtoOATraderUpdatedEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOATraderUpdatedEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOATraderUpdatedEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOATrader>(
            "trader",
            |m: &ProtoOATraderUpdatedEvent| { &m.trader },
            |m: &mut ProtoOATraderUpdatedEvent| { &mut m.trader },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATraderUpdatedEvent>(
            "ProtoOATraderUpdatedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATraderUpdatedEvent {
    const NAME: &'static str = "ProtoOATraderUpdatedEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.trader.is_none() {
            return false;
        }
        for v in &self.trader {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.trader)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.trader.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.trader.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATraderUpdatedEvent {
        ProtoOATraderUpdatedEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.trader.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATraderUpdatedEvent {
        static instance: ProtoOATraderUpdatedEvent = ProtoOATraderUpdatedEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            trader: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATraderUpdatedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATraderUpdatedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATraderUpdatedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATraderUpdatedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAReconcileReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAReconcileReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAReconcileReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAReconcileReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAReconcileReq.returnProtectionOrders)
    pub returnProtectionOrders: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAReconcileReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAReconcileReq {
    fn default() -> &'a ProtoOAReconcileReq {
        <ProtoOAReconcileReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAReconcileReq {
    pub fn new() -> ProtoOAReconcileReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_RECONCILE_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_RECONCILE_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional bool returnProtectionOrders = 3;

    pub fn returnProtectionOrders(&self) -> bool {
        self.returnProtectionOrders.unwrap_or(false)
    }

    pub fn clear_returnProtectionOrders(&mut self) {
        self.returnProtectionOrders = ::std::option::Option::None;
    }

    pub fn has_returnProtectionOrders(&self) -> bool {
        self.returnProtectionOrders.is_some()
    }

    // Param is passed by value, moved
    pub fn set_returnProtectionOrders(&mut self, v: bool) {
        self.returnProtectionOrders = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAReconcileReq| { &m.payloadType },
            |m: &mut ProtoOAReconcileReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAReconcileReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAReconcileReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "returnProtectionOrders",
            |m: &ProtoOAReconcileReq| { &m.returnProtectionOrders },
            |m: &mut ProtoOAReconcileReq| { &mut m.returnProtectionOrders },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAReconcileReq>(
            "ProtoOAReconcileReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAReconcileReq {
    const NAME: &'static str = "ProtoOAReconcileReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.returnProtectionOrders = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.returnProtectionOrders {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.returnProtectionOrders {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAReconcileReq {
        ProtoOAReconcileReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.returnProtectionOrders = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAReconcileReq {
        static instance: ProtoOAReconcileReq = ProtoOAReconcileReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            returnProtectionOrders: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAReconcileReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAReconcileReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAReconcileReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAReconcileReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAReconcileRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAReconcileRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAReconcileRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAReconcileRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAReconcileRes.position)
    pub position: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAPosition>,
    // @@protoc_insertion_point(field:ProtoOAReconcileRes.order)
    pub order: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAOrder>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAReconcileRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAReconcileRes {
    fn default() -> &'a ProtoOAReconcileRes {
        <ProtoOAReconcileRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAReconcileRes {
    pub fn new() -> ProtoOAReconcileRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_RECONCILE_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_RECONCILE_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAReconcileRes| { &m.payloadType },
            |m: &mut ProtoOAReconcileRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAReconcileRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAReconcileRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "position",
            |m: &ProtoOAReconcileRes| { &m.position },
            |m: &mut ProtoOAReconcileRes| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "order",
            |m: &ProtoOAReconcileRes| { &m.order },
            |m: &mut ProtoOAReconcileRes| { &mut m.order },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAReconcileRes>(
            "ProtoOAReconcileRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAReconcileRes {
    const NAME: &'static str = "ProtoOAReconcileRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.position.push(is.read_message()?);
                },
                34 => {
                    self.order.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.position {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.order {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.position {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.order {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAReconcileRes {
        ProtoOAReconcileRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.position.clear();
        self.order.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAReconcileRes {
        static instance: ProtoOAReconcileRes = ProtoOAReconcileRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            position: ::std::vec::Vec::new(),
            order: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAReconcileRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAReconcileRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAReconcileRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAReconcileRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderErrorEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderErrorEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderErrorEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderErrorEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderErrorEvent.errorCode)
    pub errorCode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAOrderErrorEvent.orderId)
    pub orderId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderErrorEvent.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderErrorEvent.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderErrorEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderErrorEvent {
    fn default() -> &'a ProtoOAOrderErrorEvent {
        <ProtoOAOrderErrorEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderErrorEvent {
    pub fn new() -> ProtoOAOrderErrorEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_ERROR_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_ERROR_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 5;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required string errorCode = 2;

    pub fn errorCode(&self) -> &str {
        match self.errorCode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errorCode(&mut self) {
        self.errorCode = ::std::option::Option::None;
    }

    pub fn has_errorCode(&self) -> bool {
        self.errorCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errorCode(&mut self, v: ::std::string::String) {
        self.errorCode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errorCode(&mut self) -> &mut ::std::string::String {
        if self.errorCode.is_none() {
            self.errorCode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errorCode.as_mut().unwrap()
    }

    // Take field
    pub fn take_errorCode(&mut self) -> ::std::string::String {
        self.errorCode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 orderId = 3;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // optional int64 positionId = 6;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // optional string description = 7;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderErrorEvent| { &m.payloadType },
            |m: &mut ProtoOAOrderErrorEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderErrorEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderErrorEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errorCode",
            |m: &ProtoOAOrderErrorEvent| { &m.errorCode },
            |m: &mut ProtoOAOrderErrorEvent| { &mut m.errorCode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOAOrderErrorEvent| { &m.orderId },
            |m: &mut ProtoOAOrderErrorEvent| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAOrderErrorEvent| { &m.positionId },
            |m: &mut ProtoOAOrderErrorEvent| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ProtoOAOrderErrorEvent| { &m.description },
            |m: &mut ProtoOAOrderErrorEvent| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderErrorEvent>(
            "ProtoOAOrderErrorEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderErrorEvent {
    const NAME: &'static str = "ProtoOAOrderErrorEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.errorCode.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.errorCode = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                58 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.errorCode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.errorCode.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.orderId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderErrorEvent {
        ProtoOAOrderErrorEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.errorCode = ::std::option::Option::None;
        self.orderId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderErrorEvent {
        static instance: ProtoOAOrderErrorEvent = ProtoOAOrderErrorEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            errorCode: ::std::option::Option::None,
            orderId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderErrorEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderErrorEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderErrorEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderErrorEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADealListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListReq.maxRows)
    pub maxRows: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealListReq {
    fn default() -> &'a ProtoOADealListReq {
        <ProtoOADealListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealListReq {
    pub fn new() -> ProtoOADealListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional int64 fromTimestamp = 3;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 toTimestamp = 4;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    // optional int32 maxRows = 5;

    pub fn maxRows(&self) -> i32 {
        self.maxRows.unwrap_or(0)
    }

    pub fn clear_maxRows(&mut self) {
        self.maxRows = ::std::option::Option::None;
    }

    pub fn has_maxRows(&self) -> bool {
        self.maxRows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxRows(&mut self, v: i32) {
        self.maxRows = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADealListReq| { &m.payloadType },
            |m: &mut ProtoOADealListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADealListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADealListReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOADealListReq| { &m.fromTimestamp },
            |m: &mut ProtoOADealListReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOADealListReq| { &m.toTimestamp },
            |m: &mut ProtoOADealListReq| { &mut m.toTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxRows",
            |m: &ProtoOADealListReq| { &m.maxRows },
            |m: &mut ProtoOADealListReq| { &mut m.maxRows },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealListReq>(
            "ProtoOADealListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealListReq {
    const NAME: &'static str = "ProtoOADealListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.maxRows = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.maxRows {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.maxRows {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealListReq {
        ProtoOADealListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.maxRows = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealListReq {
        static instance: ProtoOADealListReq = ProtoOADealListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            maxRows: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADealListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListRes.deal)
    pub deal: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADeal>,
    // @@protoc_insertion_point(field:ProtoOADealListRes.hasMore)
    pub hasMore: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealListRes {
    fn default() -> &'a ProtoOADealListRes {
        <ProtoOADealListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealListRes {
    pub fn new() -> ProtoOADealListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required bool hasMore = 4;

    pub fn hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADealListRes| { &m.payloadType },
            |m: &mut ProtoOADealListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADealListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADealListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deal",
            |m: &ProtoOADealListRes| { &m.deal },
            |m: &mut ProtoOADealListRes| { &mut m.deal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMore",
            |m: &ProtoOADealListRes| { &m.hasMore },
            |m: &mut ProtoOADealListRes| { &mut m.hasMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealListRes>(
            "ProtoOADealListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealListRes {
    const NAME: &'static str = "ProtoOADealListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.deal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.deal.push(is.read_message()?);
                },
                32 => {
                    self.hasMore = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.deal {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.deal {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealListRes {
        ProtoOADealListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.deal.clear();
        self.hasMore = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealListRes {
        static instance: ProtoOADealListRes = ProtoOADealListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            deal: ::std::vec::Vec::new(),
            hasMore: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderListReq {
    fn default() -> &'a ProtoOAOrderListReq {
        <ProtoOAOrderListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderListReq {
    pub fn new() -> ProtoOAOrderListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional int64 fromTimestamp = 3;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 toTimestamp = 4;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderListReq| { &m.payloadType },
            |m: &mut ProtoOAOrderListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderListReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOAOrderListReq| { &m.fromTimestamp },
            |m: &mut ProtoOAOrderListReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOAOrderListReq| { &m.toTimestamp },
            |m: &mut ProtoOAOrderListReq| { &mut m.toTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderListReq>(
            "ProtoOAOrderListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderListReq {
    const NAME: &'static str = "ProtoOAOrderListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderListReq {
        ProtoOAOrderListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderListReq {
        static instance: ProtoOAOrderListReq = ProtoOAOrderListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListRes.order)
    pub order: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAOrder>,
    // @@protoc_insertion_point(field:ProtoOAOrderListRes.hasMore)
    pub hasMore: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderListRes {
    fn default() -> &'a ProtoOAOrderListRes {
        <ProtoOAOrderListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderListRes {
    pub fn new() -> ProtoOAOrderListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required bool hasMore = 4;

    pub fn hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderListRes| { &m.payloadType },
            |m: &mut ProtoOAOrderListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "order",
            |m: &ProtoOAOrderListRes| { &m.order },
            |m: &mut ProtoOAOrderListRes| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMore",
            |m: &ProtoOAOrderListRes| { &m.hasMore },
            |m: &mut ProtoOAOrderListRes| { &mut m.hasMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderListRes>(
            "ProtoOAOrderListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderListRes {
    const NAME: &'static str = "ProtoOAOrderListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.order.push(is.read_message()?);
                },
                32 => {
                    self.hasMore = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.order {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.order {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderListRes {
        ProtoOAOrderListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.order.clear();
        self.hasMore = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderListRes {
        static instance: ProtoOAOrderListRes = ProtoOAOrderListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            order: ::std::vec::Vec::new(),
            hasMore: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAExpectedMarginReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAExpectedMarginReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginReq.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginReq.volume)
    pub volume: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAExpectedMarginReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAExpectedMarginReq {
    fn default() -> &'a ProtoOAExpectedMarginReq {
        <ProtoOAExpectedMarginReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAExpectedMarginReq {
    pub fn new() -> ProtoOAExpectedMarginReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 symbolId = 3;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAExpectedMarginReq| { &m.payloadType },
            |m: &mut ProtoOAExpectedMarginReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAExpectedMarginReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAExpectedMarginReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAExpectedMarginReq| { &m.symbolId },
            |m: &mut ProtoOAExpectedMarginReq| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volume",
            |m: &ProtoOAExpectedMarginReq| { &m.volume },
            |m: &mut ProtoOAExpectedMarginReq| { &mut m.volume },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAExpectedMarginReq>(
            "ProtoOAExpectedMarginReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAExpectedMarginReq {
    const NAME: &'static str = "ProtoOAExpectedMarginReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    is.read_repeated_packed_int64_into(&mut self.volume)?;
                },
                32 => {
                    self.volume.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        for value in &self.volume {
            my_size += ::protobuf::rt::int64_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(3, v)?;
        }
        for v in &self.volume {
            os.write_int64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAExpectedMarginReq {
        ProtoOAExpectedMarginReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.volume.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAExpectedMarginReq {
        static instance: ProtoOAExpectedMarginReq = ProtoOAExpectedMarginReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            volume: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAExpectedMarginReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAExpectedMarginReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAExpectedMarginReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAExpectedMarginReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAExpectedMarginRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAExpectedMarginRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginRes.margin)
    pub margin: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAExpectedMargin>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMarginRes.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAExpectedMarginRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAExpectedMarginRes {
    fn default() -> &'a ProtoOAExpectedMarginRes {
        <ProtoOAExpectedMarginRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAExpectedMarginRes {
    pub fn new() -> ProtoOAExpectedMarginRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional uint32 moneyDigits = 4;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAExpectedMarginRes| { &m.payloadType },
            |m: &mut ProtoOAExpectedMarginRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAExpectedMarginRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAExpectedMarginRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "margin",
            |m: &ProtoOAExpectedMarginRes| { &m.margin },
            |m: &mut ProtoOAExpectedMarginRes| { &mut m.margin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOAExpectedMarginRes| { &m.moneyDigits },
            |m: &mut ProtoOAExpectedMarginRes| { &mut m.moneyDigits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAExpectedMarginRes>(
            "ProtoOAExpectedMarginRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAExpectedMarginRes {
    const NAME: &'static str = "ProtoOAExpectedMarginRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.margin {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.margin.push(is.read_message()?);
                },
                32 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.margin {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.margin {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.moneyDigits {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAExpectedMarginRes {
        ProtoOAExpectedMarginRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.margin.clear();
        self.moneyDigits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAExpectedMarginRes {
        static instance: ProtoOAExpectedMarginRes = ProtoOAExpectedMarginRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            margin: ::std::vec::Vec::new(),
            moneyDigits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAExpectedMarginRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAExpectedMarginRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAExpectedMarginRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAExpectedMarginRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginChangedEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginChangedEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginChangedEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginChangedEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAMarginChangedEvent.positionId)
    pub positionId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOAMarginChangedEvent.usedMargin)
    pub usedMargin: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOAMarginChangedEvent.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginChangedEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginChangedEvent {
    fn default() -> &'a ProtoOAMarginChangedEvent {
        <ProtoOAMarginChangedEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginChangedEvent {
    pub fn new() -> ProtoOAMarginChangedEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CHANGED_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CHANGED_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required uint64 positionId = 3;

    pub fn positionId(&self) -> u64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: u64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // required uint64 usedMargin = 4;

    pub fn usedMargin(&self) -> u64 {
        self.usedMargin.unwrap_or(0)
    }

    pub fn clear_usedMargin(&mut self) {
        self.usedMargin = ::std::option::Option::None;
    }

    pub fn has_usedMargin(&self) -> bool {
        self.usedMargin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usedMargin(&mut self, v: u64) {
        self.usedMargin = ::std::option::Option::Some(v);
    }

    // optional uint32 moneyDigits = 5;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginChangedEvent| { &m.payloadType },
            |m: &mut ProtoOAMarginChangedEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAMarginChangedEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAMarginChangedEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAMarginChangedEvent| { &m.positionId },
            |m: &mut ProtoOAMarginChangedEvent| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usedMargin",
            |m: &ProtoOAMarginChangedEvent| { &m.usedMargin },
            |m: &mut ProtoOAMarginChangedEvent| { &mut m.usedMargin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOAMarginChangedEvent| { &m.moneyDigits },
            |m: &mut ProtoOAMarginChangedEvent| { &mut m.moneyDigits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginChangedEvent>(
            "ProtoOAMarginChangedEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginChangedEvent {
    const NAME: &'static str = "ProtoOAMarginChangedEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        if self.usedMargin.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.usedMargin = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.usedMargin {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.usedMargin {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginChangedEvent {
        ProtoOAMarginChangedEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.usedMargin = ::std::option::Option::None;
        self.moneyDigits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginChangedEvent {
        static instance: ProtoOAMarginChangedEvent = ProtoOAMarginChangedEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            usedMargin: ::std::option::Option::None,
            moneyDigits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginChangedEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginChangedEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginChangedEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginChangedEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOACashFlowHistoryListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOACashFlowHistoryListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOACashFlowHistoryListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOACashFlowHistoryListReq {
    fn default() -> &'a ProtoOACashFlowHistoryListReq {
        <ProtoOACashFlowHistoryListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOACashFlowHistoryListReq {
    pub fn new() -> ProtoOACashFlowHistoryListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 fromTimestamp = 3;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // required int64 toTimestamp = 4;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOACashFlowHistoryListReq| { &m.payloadType },
            |m: &mut ProtoOACashFlowHistoryListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOACashFlowHistoryListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOACashFlowHistoryListReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOACashFlowHistoryListReq| { &m.fromTimestamp },
            |m: &mut ProtoOACashFlowHistoryListReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOACashFlowHistoryListReq| { &m.toTimestamp },
            |m: &mut ProtoOACashFlowHistoryListReq| { &mut m.toTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOACashFlowHistoryListReq>(
            "ProtoOACashFlowHistoryListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOACashFlowHistoryListReq {
    const NAME: &'static str = "ProtoOACashFlowHistoryListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.fromTimestamp.is_none() {
            return false;
        }
        if self.toTimestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOACashFlowHistoryListReq {
        ProtoOACashFlowHistoryListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOACashFlowHistoryListReq {
        static instance: ProtoOACashFlowHistoryListReq = ProtoOACashFlowHistoryListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOACashFlowHistoryListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOACashFlowHistoryListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOACashFlowHistoryListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOACashFlowHistoryListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOACashFlowHistoryListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOACashFlowHistoryListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACashFlowHistoryListRes.depositWithdraw)
    pub depositWithdraw: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADepositWithdraw>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOACashFlowHistoryListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOACashFlowHistoryListRes {
    fn default() -> &'a ProtoOACashFlowHistoryListRes {
        <ProtoOACashFlowHistoryListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOACashFlowHistoryListRes {
    pub fn new() -> ProtoOACashFlowHistoryListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOACashFlowHistoryListRes| { &m.payloadType },
            |m: &mut ProtoOACashFlowHistoryListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOACashFlowHistoryListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOACashFlowHistoryListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "depositWithdraw",
            |m: &ProtoOACashFlowHistoryListRes| { &m.depositWithdraw },
            |m: &mut ProtoOACashFlowHistoryListRes| { &mut m.depositWithdraw },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOACashFlowHistoryListRes>(
            "ProtoOACashFlowHistoryListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOACashFlowHistoryListRes {
    const NAME: &'static str = "ProtoOACashFlowHistoryListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.depositWithdraw {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.depositWithdraw.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.depositWithdraw {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.depositWithdraw {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOACashFlowHistoryListRes {
        ProtoOACashFlowHistoryListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.depositWithdraw.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOACashFlowHistoryListRes {
        static instance: ProtoOACashFlowHistoryListRes = ProtoOACashFlowHistoryListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            depositWithdraw: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOACashFlowHistoryListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOACashFlowHistoryListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOACashFlowHistoryListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOACashFlowHistoryListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetAccountListByAccessTokenReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetAccountListByAccessTokenReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetAccountListByAccessTokenReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetAccountListByAccessTokenReq.accessToken)
    pub accessToken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetAccountListByAccessTokenReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetAccountListByAccessTokenReq {
    fn default() -> &'a ProtoOAGetAccountListByAccessTokenReq {
        <ProtoOAGetAccountListByAccessTokenReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetAccountListByAccessTokenReq {
    pub fn new() -> ProtoOAGetAccountListByAccessTokenReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string accessToken = 2;

    pub fn accessToken(&self) -> &str {
        match self.accessToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accessToken(&mut self) {
        self.accessToken = ::std::option::Option::None;
    }

    pub fn has_accessToken(&self) -> bool {
        self.accessToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessToken(&mut self, v: ::std::string::String) {
        self.accessToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessToken(&mut self) -> &mut ::std::string::String {
        if self.accessToken.is_none() {
            self.accessToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accessToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_accessToken(&mut self) -> ::std::string::String {
        self.accessToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetAccountListByAccessTokenReq| { &m.payloadType },
            |m: &mut ProtoOAGetAccountListByAccessTokenReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accessToken",
            |m: &ProtoOAGetAccountListByAccessTokenReq| { &m.accessToken },
            |m: &mut ProtoOAGetAccountListByAccessTokenReq| { &mut m.accessToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetAccountListByAccessTokenReq>(
            "ProtoOAGetAccountListByAccessTokenReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetAccountListByAccessTokenReq {
    const NAME: &'static str = "ProtoOAGetAccountListByAccessTokenReq";

    fn is_initialized(&self) -> bool {
        if self.accessToken.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.accessToken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.accessToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.accessToken.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetAccountListByAccessTokenReq {
        ProtoOAGetAccountListByAccessTokenReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.accessToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetAccountListByAccessTokenReq {
        static instance: ProtoOAGetAccountListByAccessTokenReq = ProtoOAGetAccountListByAccessTokenReq {
            payloadType: ::std::option::Option::None,
            accessToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetAccountListByAccessTokenReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetAccountListByAccessTokenReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetAccountListByAccessTokenReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetAccountListByAccessTokenReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetAccountListByAccessTokenRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetAccountListByAccessTokenRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetAccountListByAccessTokenRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetAccountListByAccessTokenRes.accessToken)
    pub accessToken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAGetAccountListByAccessTokenRes.permissionScope)
    pub permissionScope: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAClientPermissionScope>>,
    // @@protoc_insertion_point(field:ProtoOAGetAccountListByAccessTokenRes.ctidTraderAccount)
    pub ctidTraderAccount: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOACtidTraderAccount>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetAccountListByAccessTokenRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetAccountListByAccessTokenRes {
    fn default() -> &'a ProtoOAGetAccountListByAccessTokenRes {
        <ProtoOAGetAccountListByAccessTokenRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetAccountListByAccessTokenRes {
    pub fn new() -> ProtoOAGetAccountListByAccessTokenRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string accessToken = 2;

    pub fn accessToken(&self) -> &str {
        match self.accessToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accessToken(&mut self) {
        self.accessToken = ::std::option::Option::None;
    }

    pub fn has_accessToken(&self) -> bool {
        self.accessToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessToken(&mut self, v: ::std::string::String) {
        self.accessToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessToken(&mut self) -> &mut ::std::string::String {
        if self.accessToken.is_none() {
            self.accessToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accessToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_accessToken(&mut self) -> ::std::string::String {
        self.accessToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ProtoOAClientPermissionScope permissionScope = 3;

    pub fn permissionScope(&self) -> super::OpenApiModelMessages::ProtoOAClientPermissionScope {
        match self.permissionScope {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAClientPermissionScope::SCOPE_VIEW),
            None => super::OpenApiModelMessages::ProtoOAClientPermissionScope::SCOPE_VIEW,
        }
    }

    pub fn clear_permissionScope(&mut self) {
        self.permissionScope = ::std::option::Option::None;
    }

    pub fn has_permissionScope(&self) -> bool {
        self.permissionScope.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permissionScope(&mut self, v: super::OpenApiModelMessages::ProtoOAClientPermissionScope) {
        self.permissionScope = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetAccountListByAccessTokenRes| { &m.payloadType },
            |m: &mut ProtoOAGetAccountListByAccessTokenRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accessToken",
            |m: &ProtoOAGetAccountListByAccessTokenRes| { &m.accessToken },
            |m: &mut ProtoOAGetAccountListByAccessTokenRes| { &mut m.accessToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "permissionScope",
            |m: &ProtoOAGetAccountListByAccessTokenRes| { &m.permissionScope },
            |m: &mut ProtoOAGetAccountListByAccessTokenRes| { &mut m.permissionScope },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ctidTraderAccount",
            |m: &ProtoOAGetAccountListByAccessTokenRes| { &m.ctidTraderAccount },
            |m: &mut ProtoOAGetAccountListByAccessTokenRes| { &mut m.ctidTraderAccount },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetAccountListByAccessTokenRes>(
            "ProtoOAGetAccountListByAccessTokenRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetAccountListByAccessTokenRes {
    const NAME: &'static str = "ProtoOAGetAccountListByAccessTokenRes";

    fn is_initialized(&self) -> bool {
        if self.accessToken.is_none() {
            return false;
        }
        for v in &self.ctidTraderAccount {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.accessToken = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.permissionScope = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    self.ctidTraderAccount.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.accessToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.permissionScope {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        for value in &self.ctidTraderAccount {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.accessToken.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.permissionScope {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.ctidTraderAccount {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetAccountListByAccessTokenRes {
        ProtoOAGetAccountListByAccessTokenRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.accessToken = ::std::option::Option::None;
        self.permissionScope = ::std::option::Option::None;
        self.ctidTraderAccount.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetAccountListByAccessTokenRes {
        static instance: ProtoOAGetAccountListByAccessTokenRes = ProtoOAGetAccountListByAccessTokenRes {
            payloadType: ::std::option::Option::None,
            accessToken: ::std::option::Option::None,
            permissionScope: ::std::option::Option::None,
            ctidTraderAccount: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetAccountListByAccessTokenRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetAccountListByAccessTokenRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetAccountListByAccessTokenRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetAccountListByAccessTokenRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOARefreshTokenReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOARefreshTokenReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOARefreshTokenReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOARefreshTokenReq.refreshToken)
    pub refreshToken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOARefreshTokenReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOARefreshTokenReq {
    fn default() -> &'a ProtoOARefreshTokenReq {
        <ProtoOARefreshTokenReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOARefreshTokenReq {
    pub fn new() -> ProtoOARefreshTokenReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string refreshToken = 2;

    pub fn refreshToken(&self) -> &str {
        match self.refreshToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_refreshToken(&mut self) {
        self.refreshToken = ::std::option::Option::None;
    }

    pub fn has_refreshToken(&self) -> bool {
        self.refreshToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refreshToken(&mut self, v: ::std::string::String) {
        self.refreshToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refreshToken(&mut self) -> &mut ::std::string::String {
        if self.refreshToken.is_none() {
            self.refreshToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.refreshToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_refreshToken(&mut self) -> ::std::string::String {
        self.refreshToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOARefreshTokenReq| { &m.payloadType },
            |m: &mut ProtoOARefreshTokenReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "refreshToken",
            |m: &ProtoOARefreshTokenReq| { &m.refreshToken },
            |m: &mut ProtoOARefreshTokenReq| { &mut m.refreshToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOARefreshTokenReq>(
            "ProtoOARefreshTokenReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOARefreshTokenReq {
    const NAME: &'static str = "ProtoOARefreshTokenReq";

    fn is_initialized(&self) -> bool {
        if self.refreshToken.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.refreshToken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.refreshToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.refreshToken.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOARefreshTokenReq {
        ProtoOARefreshTokenReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.refreshToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOARefreshTokenReq {
        static instance: ProtoOARefreshTokenReq = ProtoOARefreshTokenReq {
            payloadType: ::std::option::Option::None,
            refreshToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOARefreshTokenReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOARefreshTokenReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOARefreshTokenReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOARefreshTokenReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOARefreshTokenRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOARefreshTokenRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOARefreshTokenRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOARefreshTokenRes.accessToken)
    pub accessToken: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOARefreshTokenRes.tokenType)
    pub tokenType: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOARefreshTokenRes.expiresIn)
    pub expiresIn: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOARefreshTokenRes.refreshToken)
    pub refreshToken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOARefreshTokenRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOARefreshTokenRes {
    fn default() -> &'a ProtoOARefreshTokenRes {
        <ProtoOARefreshTokenRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOARefreshTokenRes {
    pub fn new() -> ProtoOARefreshTokenRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string accessToken = 2;

    pub fn accessToken(&self) -> &str {
        match self.accessToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accessToken(&mut self) {
        self.accessToken = ::std::option::Option::None;
    }

    pub fn has_accessToken(&self) -> bool {
        self.accessToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessToken(&mut self, v: ::std::string::String) {
        self.accessToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessToken(&mut self) -> &mut ::std::string::String {
        if self.accessToken.is_none() {
            self.accessToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accessToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_accessToken(&mut self) -> ::std::string::String {
        self.accessToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string tokenType = 3;

    pub fn tokenType(&self) -> &str {
        match self.tokenType.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tokenType(&mut self) {
        self.tokenType = ::std::option::Option::None;
    }

    pub fn has_tokenType(&self) -> bool {
        self.tokenType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokenType(&mut self, v: ::std::string::String) {
        self.tokenType = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tokenType(&mut self) -> &mut ::std::string::String {
        if self.tokenType.is_none() {
            self.tokenType = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tokenType.as_mut().unwrap()
    }

    // Take field
    pub fn take_tokenType(&mut self) -> ::std::string::String {
        self.tokenType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 expiresIn = 4;

    pub fn expiresIn(&self) -> i64 {
        self.expiresIn.unwrap_or(0)
    }

    pub fn clear_expiresIn(&mut self) {
        self.expiresIn = ::std::option::Option::None;
    }

    pub fn has_expiresIn(&self) -> bool {
        self.expiresIn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiresIn(&mut self, v: i64) {
        self.expiresIn = ::std::option::Option::Some(v);
    }

    // required string refreshToken = 5;

    pub fn refreshToken(&self) -> &str {
        match self.refreshToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_refreshToken(&mut self) {
        self.refreshToken = ::std::option::Option::None;
    }

    pub fn has_refreshToken(&self) -> bool {
        self.refreshToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_refreshToken(&mut self, v: ::std::string::String) {
        self.refreshToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refreshToken(&mut self) -> &mut ::std::string::String {
        if self.refreshToken.is_none() {
            self.refreshToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.refreshToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_refreshToken(&mut self) -> ::std::string::String {
        self.refreshToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOARefreshTokenRes| { &m.payloadType },
            |m: &mut ProtoOARefreshTokenRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accessToken",
            |m: &ProtoOARefreshTokenRes| { &m.accessToken },
            |m: &mut ProtoOARefreshTokenRes| { &mut m.accessToken },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokenType",
            |m: &ProtoOARefreshTokenRes| { &m.tokenType },
            |m: &mut ProtoOARefreshTokenRes| { &mut m.tokenType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiresIn",
            |m: &ProtoOARefreshTokenRes| { &m.expiresIn },
            |m: &mut ProtoOARefreshTokenRes| { &mut m.expiresIn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "refreshToken",
            |m: &ProtoOARefreshTokenRes| { &m.refreshToken },
            |m: &mut ProtoOARefreshTokenRes| { &mut m.refreshToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOARefreshTokenRes>(
            "ProtoOARefreshTokenRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOARefreshTokenRes {
    const NAME: &'static str = "ProtoOARefreshTokenRes";

    fn is_initialized(&self) -> bool {
        if self.accessToken.is_none() {
            return false;
        }
        if self.tokenType.is_none() {
            return false;
        }
        if self.expiresIn.is_none() {
            return false;
        }
        if self.refreshToken.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.accessToken = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.tokenType = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.expiresIn = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.refreshToken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.accessToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.tokenType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.expiresIn {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.refreshToken.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.accessToken.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.tokenType.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.expiresIn {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.refreshToken.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOARefreshTokenRes {
        ProtoOARefreshTokenRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.accessToken = ::std::option::Option::None;
        self.tokenType = ::std::option::Option::None;
        self.expiresIn = ::std::option::Option::None;
        self.refreshToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOARefreshTokenRes {
        static instance: ProtoOARefreshTokenRes = ProtoOARefreshTokenRes {
            payloadType: ::std::option::Option::None,
            accessToken: ::std::option::Option::None,
            tokenType: ::std::option::Option::None,
            expiresIn: ::std::option::Option::None,
            refreshToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOARefreshTokenRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOARefreshTokenRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOARefreshTokenRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOARefreshTokenRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASubscribeSpotsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASubscribeSpotsReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASubscribeSpotsReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeSpotsReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASubscribeSpotsReq.symbolId)
    pub symbolId: ::std::vec::Vec<i64>,
    // @@protoc_insertion_point(field:ProtoOASubscribeSpotsReq.subscribeToSpotTimestamp)
    pub subscribeToSpotTimestamp: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASubscribeSpotsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASubscribeSpotsReq {
    fn default() -> &'a ProtoOASubscribeSpotsReq {
        <ProtoOASubscribeSpotsReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASubscribeSpotsReq {
    pub fn new() -> ProtoOASubscribeSpotsReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional bool subscribeToSpotTimestamp = 4;

    pub fn subscribeToSpotTimestamp(&self) -> bool {
        self.subscribeToSpotTimestamp.unwrap_or(false)
    }

    pub fn clear_subscribeToSpotTimestamp(&mut self) {
        self.subscribeToSpotTimestamp = ::std::option::Option::None;
    }

    pub fn has_subscribeToSpotTimestamp(&self) -> bool {
        self.subscribeToSpotTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribeToSpotTimestamp(&mut self, v: bool) {
        self.subscribeToSpotTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASubscribeSpotsReq| { &m.payloadType },
            |m: &mut ProtoOASubscribeSpotsReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASubscribeSpotsReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASubscribeSpotsReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASubscribeSpotsReq| { &m.symbolId },
            |m: &mut ProtoOASubscribeSpotsReq| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "subscribeToSpotTimestamp",
            |m: &ProtoOASubscribeSpotsReq| { &m.subscribeToSpotTimestamp },
            |m: &mut ProtoOASubscribeSpotsReq| { &mut m.subscribeToSpotTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASubscribeSpotsReq>(
            "ProtoOASubscribeSpotsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASubscribeSpotsReq {
    const NAME: &'static str = "ProtoOASubscribeSpotsReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.symbolId)?;
                },
                24 => {
                    self.symbolId.push(is.read_int64()?);
                },
                32 => {
                    self.subscribeToSpotTimestamp = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        if let Some(v) = self.subscribeToSpotTimestamp {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolId {
            os.write_int64(3, *v)?;
        };
        if let Some(v) = self.subscribeToSpotTimestamp {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASubscribeSpotsReq {
        ProtoOASubscribeSpotsReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId.clear();
        self.subscribeToSpotTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASubscribeSpotsReq {
        static instance: ProtoOASubscribeSpotsReq = ProtoOASubscribeSpotsReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::vec::Vec::new(),
            subscribeToSpotTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASubscribeSpotsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASubscribeSpotsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASubscribeSpotsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASubscribeSpotsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASubscribeSpotsRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASubscribeSpotsRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASubscribeSpotsRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeSpotsRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASubscribeSpotsRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASubscribeSpotsRes {
    fn default() -> &'a ProtoOASubscribeSpotsRes {
        <ProtoOASubscribeSpotsRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASubscribeSpotsRes {
    pub fn new() -> ProtoOASubscribeSpotsRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASubscribeSpotsRes| { &m.payloadType },
            |m: &mut ProtoOASubscribeSpotsRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASubscribeSpotsRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASubscribeSpotsRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASubscribeSpotsRes>(
            "ProtoOASubscribeSpotsRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASubscribeSpotsRes {
    const NAME: &'static str = "ProtoOASubscribeSpotsRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASubscribeSpotsRes {
        ProtoOASubscribeSpotsRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASubscribeSpotsRes {
        static instance: ProtoOASubscribeSpotsRes = ProtoOASubscribeSpotsRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASubscribeSpotsRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASubscribeSpotsRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASubscribeSpotsRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASubscribeSpotsRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAUnsubscribeSpotsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAUnsubscribeSpotsReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeSpotsReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeSpotsReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeSpotsReq.symbolId)
    pub symbolId: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAUnsubscribeSpotsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAUnsubscribeSpotsReq {
    fn default() -> &'a ProtoOAUnsubscribeSpotsReq {
        <ProtoOAUnsubscribeSpotsReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAUnsubscribeSpotsReq {
    pub fn new() -> ProtoOAUnsubscribeSpotsReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAUnsubscribeSpotsReq| { &m.payloadType },
            |m: &mut ProtoOAUnsubscribeSpotsReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAUnsubscribeSpotsReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAUnsubscribeSpotsReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAUnsubscribeSpotsReq| { &m.symbolId },
            |m: &mut ProtoOAUnsubscribeSpotsReq| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAUnsubscribeSpotsReq>(
            "ProtoOAUnsubscribeSpotsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAUnsubscribeSpotsReq {
    const NAME: &'static str = "ProtoOAUnsubscribeSpotsReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.symbolId)?;
                },
                24 => {
                    self.symbolId.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolId {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAUnsubscribeSpotsReq {
        ProtoOAUnsubscribeSpotsReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAUnsubscribeSpotsReq {
        static instance: ProtoOAUnsubscribeSpotsReq = ProtoOAUnsubscribeSpotsReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAUnsubscribeSpotsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAUnsubscribeSpotsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAUnsubscribeSpotsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAUnsubscribeSpotsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAUnsubscribeSpotsRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAUnsubscribeSpotsRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeSpotsRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeSpotsRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAUnsubscribeSpotsRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAUnsubscribeSpotsRes {
    fn default() -> &'a ProtoOAUnsubscribeSpotsRes {
        <ProtoOAUnsubscribeSpotsRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAUnsubscribeSpotsRes {
    pub fn new() -> ProtoOAUnsubscribeSpotsRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAUnsubscribeSpotsRes| { &m.payloadType },
            |m: &mut ProtoOAUnsubscribeSpotsRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAUnsubscribeSpotsRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAUnsubscribeSpotsRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAUnsubscribeSpotsRes>(
            "ProtoOAUnsubscribeSpotsRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAUnsubscribeSpotsRes {
    const NAME: &'static str = "ProtoOAUnsubscribeSpotsRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAUnsubscribeSpotsRes {
        ProtoOAUnsubscribeSpotsRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAUnsubscribeSpotsRes {
        static instance: ProtoOAUnsubscribeSpotsRes = ProtoOAUnsubscribeSpotsRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAUnsubscribeSpotsRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAUnsubscribeSpotsRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAUnsubscribeSpotsRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAUnsubscribeSpotsRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASpotEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASpotEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASpotEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.bid)
    pub bid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.ask)
    pub ask: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.trendbar)
    pub trendbar: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOATrendbar>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.sessionClose)
    pub sessionClose: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOASpotEvent.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASpotEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASpotEvent {
    fn default() -> &'a ProtoOASpotEvent {
        <ProtoOASpotEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASpotEvent {
    pub fn new() -> ProtoOASpotEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SPOT_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SPOT_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 symbolId = 3;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // optional uint64 bid = 4;

    pub fn bid(&self) -> u64 {
        self.bid.unwrap_or(0)
    }

    pub fn clear_bid(&mut self) {
        self.bid = ::std::option::Option::None;
    }

    pub fn has_bid(&self) -> bool {
        self.bid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bid(&mut self, v: u64) {
        self.bid = ::std::option::Option::Some(v);
    }

    // optional uint64 ask = 5;

    pub fn ask(&self) -> u64 {
        self.ask.unwrap_or(0)
    }

    pub fn clear_ask(&mut self) {
        self.ask = ::std::option::Option::None;
    }

    pub fn has_ask(&self) -> bool {
        self.ask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: u64) {
        self.ask = ::std::option::Option::Some(v);
    }

    // optional uint64 sessionClose = 7;

    pub fn sessionClose(&self) -> u64 {
        self.sessionClose.unwrap_or(0)
    }

    pub fn clear_sessionClose(&mut self) {
        self.sessionClose = ::std::option::Option::None;
    }

    pub fn has_sessionClose(&self) -> bool {
        self.sessionClose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionClose(&mut self, v: u64) {
        self.sessionClose = ::std::option::Option::Some(v);
    }

    // optional int64 timestamp = 8;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASpotEvent| { &m.payloadType },
            |m: &mut ProtoOASpotEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASpotEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASpotEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASpotEvent| { &m.symbolId },
            |m: &mut ProtoOASpotEvent| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bid",
            |m: &ProtoOASpotEvent| { &m.bid },
            |m: &mut ProtoOASpotEvent| { &mut m.bid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ask",
            |m: &ProtoOASpotEvent| { &m.ask },
            |m: &mut ProtoOASpotEvent| { &mut m.ask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trendbar",
            |m: &ProtoOASpotEvent| { &m.trendbar },
            |m: &mut ProtoOASpotEvent| { &mut m.trendbar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sessionClose",
            |m: &ProtoOASpotEvent| { &m.sessionClose },
            |m: &mut ProtoOASpotEvent| { &mut m.sessionClose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ProtoOASpotEvent| { &m.timestamp },
            |m: &mut ProtoOASpotEvent| { &mut m.timestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASpotEvent>(
            "ProtoOASpotEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASpotEvent {
    const NAME: &'static str = "ProtoOASpotEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        for v in &self.trendbar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.bid = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.ask = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.trendbar.push(is.read_message()?);
                },
                56 => {
                    self.sessionClose = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.bid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.ask {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        for value in &self.trendbar {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.sessionClose {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.bid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.ask {
            os.write_uint64(5, v)?;
        }
        for v in &self.trendbar {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.sessionClose {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASpotEvent {
        ProtoOASpotEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.bid = ::std::option::Option::None;
        self.ask = ::std::option::Option::None;
        self.trendbar.clear();
        self.sessionClose = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASpotEvent {
        static instance: ProtoOASpotEvent = ProtoOASpotEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            bid: ::std::option::Option::None,
            ask: ::std::option::Option::None,
            trendbar: ::std::vec::Vec::new(),
            sessionClose: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASpotEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASpotEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASpotEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASpotEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASubscribeLiveTrendbarReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASubscribeLiveTrendbarReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASubscribeLiveTrendbarReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeLiveTrendbarReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASubscribeLiveTrendbarReq.period)
    pub period: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOATrendbarPeriod>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeLiveTrendbarReq.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASubscribeLiveTrendbarReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASubscribeLiveTrendbarReq {
    fn default() -> &'a ProtoOASubscribeLiveTrendbarReq {
        <ProtoOASubscribeLiveTrendbarReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASubscribeLiveTrendbarReq {
    pub fn new() -> ProtoOASubscribeLiveTrendbarReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required .ProtoOATrendbarPeriod period = 3;

    pub fn period(&self) -> super::OpenApiModelMessages::ProtoOATrendbarPeriod {
        match self.period {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1),
            None => super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1,
        }
    }

    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: super::OpenApiModelMessages::ProtoOATrendbarPeriod) {
        self.period = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 symbolId = 4;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASubscribeLiveTrendbarReq| { &m.payloadType },
            |m: &mut ProtoOASubscribeLiveTrendbarReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASubscribeLiveTrendbarReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASubscribeLiveTrendbarReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "period",
            |m: &ProtoOASubscribeLiveTrendbarReq| { &m.period },
            |m: &mut ProtoOASubscribeLiveTrendbarReq| { &mut m.period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASubscribeLiveTrendbarReq| { &m.symbolId },
            |m: &mut ProtoOASubscribeLiveTrendbarReq| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASubscribeLiveTrendbarReq>(
            "ProtoOASubscribeLiveTrendbarReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASubscribeLiveTrendbarReq {
    const NAME: &'static str = "ProtoOASubscribeLiveTrendbarReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.period.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.period = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.period {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASubscribeLiveTrendbarReq {
        ProtoOASubscribeLiveTrendbarReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.period = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASubscribeLiveTrendbarReq {
        static instance: ProtoOASubscribeLiveTrendbarReq = ProtoOASubscribeLiveTrendbarReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            period: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASubscribeLiveTrendbarReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASubscribeLiveTrendbarReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASubscribeLiveTrendbarReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASubscribeLiveTrendbarReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASubscribeLiveTrendbarRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASubscribeLiveTrendbarRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASubscribeLiveTrendbarRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeLiveTrendbarRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASubscribeLiveTrendbarRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASubscribeLiveTrendbarRes {
    fn default() -> &'a ProtoOASubscribeLiveTrendbarRes {
        <ProtoOASubscribeLiveTrendbarRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASubscribeLiveTrendbarRes {
    pub fn new() -> ProtoOASubscribeLiveTrendbarRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASubscribeLiveTrendbarRes| { &m.payloadType },
            |m: &mut ProtoOASubscribeLiveTrendbarRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASubscribeLiveTrendbarRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASubscribeLiveTrendbarRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASubscribeLiveTrendbarRes>(
            "ProtoOASubscribeLiveTrendbarRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASubscribeLiveTrendbarRes {
    const NAME: &'static str = "ProtoOASubscribeLiveTrendbarRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASubscribeLiveTrendbarRes {
        ProtoOASubscribeLiveTrendbarRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASubscribeLiveTrendbarRes {
        static instance: ProtoOASubscribeLiveTrendbarRes = ProtoOASubscribeLiveTrendbarRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASubscribeLiveTrendbarRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASubscribeLiveTrendbarRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASubscribeLiveTrendbarRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASubscribeLiveTrendbarRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAUnsubscribeLiveTrendbarReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAUnsubscribeLiveTrendbarReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeLiveTrendbarReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeLiveTrendbarReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeLiveTrendbarReq.period)
    pub period: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOATrendbarPeriod>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeLiveTrendbarReq.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAUnsubscribeLiveTrendbarReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAUnsubscribeLiveTrendbarReq {
    fn default() -> &'a ProtoOAUnsubscribeLiveTrendbarReq {
        <ProtoOAUnsubscribeLiveTrendbarReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAUnsubscribeLiveTrendbarReq {
    pub fn new() -> ProtoOAUnsubscribeLiveTrendbarReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required .ProtoOATrendbarPeriod period = 3;

    pub fn period(&self) -> super::OpenApiModelMessages::ProtoOATrendbarPeriod {
        match self.period {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1),
            None => super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1,
        }
    }

    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: super::OpenApiModelMessages::ProtoOATrendbarPeriod) {
        self.period = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 symbolId = 4;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAUnsubscribeLiveTrendbarReq| { &m.payloadType },
            |m: &mut ProtoOAUnsubscribeLiveTrendbarReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAUnsubscribeLiveTrendbarReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAUnsubscribeLiveTrendbarReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "period",
            |m: &ProtoOAUnsubscribeLiveTrendbarReq| { &m.period },
            |m: &mut ProtoOAUnsubscribeLiveTrendbarReq| { &mut m.period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAUnsubscribeLiveTrendbarReq| { &m.symbolId },
            |m: &mut ProtoOAUnsubscribeLiveTrendbarReq| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAUnsubscribeLiveTrendbarReq>(
            "ProtoOAUnsubscribeLiveTrendbarReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAUnsubscribeLiveTrendbarReq {
    const NAME: &'static str = "ProtoOAUnsubscribeLiveTrendbarReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.period.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.period = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.period {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAUnsubscribeLiveTrendbarReq {
        ProtoOAUnsubscribeLiveTrendbarReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.period = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAUnsubscribeLiveTrendbarReq {
        static instance: ProtoOAUnsubscribeLiveTrendbarReq = ProtoOAUnsubscribeLiveTrendbarReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            period: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAUnsubscribeLiveTrendbarReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAUnsubscribeLiveTrendbarReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAUnsubscribeLiveTrendbarReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAUnsubscribeLiveTrendbarReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAUnsubscribeLiveTrendbarRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAUnsubscribeLiveTrendbarRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeLiveTrendbarRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeLiveTrendbarRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAUnsubscribeLiveTrendbarRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAUnsubscribeLiveTrendbarRes {
    fn default() -> &'a ProtoOAUnsubscribeLiveTrendbarRes {
        <ProtoOAUnsubscribeLiveTrendbarRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAUnsubscribeLiveTrendbarRes {
    pub fn new() -> ProtoOAUnsubscribeLiveTrendbarRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAUnsubscribeLiveTrendbarRes| { &m.payloadType },
            |m: &mut ProtoOAUnsubscribeLiveTrendbarRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAUnsubscribeLiveTrendbarRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAUnsubscribeLiveTrendbarRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAUnsubscribeLiveTrendbarRes>(
            "ProtoOAUnsubscribeLiveTrendbarRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAUnsubscribeLiveTrendbarRes {
    const NAME: &'static str = "ProtoOAUnsubscribeLiveTrendbarRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAUnsubscribeLiveTrendbarRes {
        ProtoOAUnsubscribeLiveTrendbarRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAUnsubscribeLiveTrendbarRes {
        static instance: ProtoOAUnsubscribeLiveTrendbarRes = ProtoOAUnsubscribeLiveTrendbarRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAUnsubscribeLiveTrendbarRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAUnsubscribeLiveTrendbarRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAUnsubscribeLiveTrendbarRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAUnsubscribeLiveTrendbarRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetTrendbarsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetTrendbarsReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.period)
    pub period: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOATrendbarPeriod>>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsReq.count)
    pub count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetTrendbarsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetTrendbarsReq {
    fn default() -> &'a ProtoOAGetTrendbarsReq {
        <ProtoOAGetTrendbarsReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetTrendbarsReq {
    pub fn new() -> ProtoOAGetTrendbarsReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional int64 fromTimestamp = 3;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 toTimestamp = 4;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    // required .ProtoOATrendbarPeriod period = 5;

    pub fn period(&self) -> super::OpenApiModelMessages::ProtoOATrendbarPeriod {
        match self.period {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1),
            None => super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1,
        }
    }

    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: super::OpenApiModelMessages::ProtoOATrendbarPeriod) {
        self.period = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 symbolId = 6;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 7;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetTrendbarsReq| { &m.payloadType },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetTrendbarsReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOAGetTrendbarsReq| { &m.fromTimestamp },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOAGetTrendbarsReq| { &m.toTimestamp },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.toTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "period",
            |m: &ProtoOAGetTrendbarsReq| { &m.period },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAGetTrendbarsReq| { &m.symbolId },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "count",
            |m: &ProtoOAGetTrendbarsReq| { &m.count },
            |m: &mut ProtoOAGetTrendbarsReq| { &mut m.count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetTrendbarsReq>(
            "ProtoOAGetTrendbarsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetTrendbarsReq {
    const NAME: &'static str = "ProtoOAGetTrendbarsReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.period.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.period = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.period {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetTrendbarsReq {
        ProtoOAGetTrendbarsReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.period = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetTrendbarsReq {
        static instance: ProtoOAGetTrendbarsReq = ProtoOAGetTrendbarsReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            period: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            count: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetTrendbarsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetTrendbarsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetTrendbarsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetTrendbarsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetTrendbarsRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetTrendbarsRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.period)
    pub period: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOATrendbarPeriod>>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.trendbar)
    pub trendbar: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOATrendbar>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTrendbarsRes.hasMore)
    pub hasMore: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetTrendbarsRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetTrendbarsRes {
    fn default() -> &'a ProtoOAGetTrendbarsRes {
        <ProtoOAGetTrendbarsRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetTrendbarsRes {
    pub fn new() -> ProtoOAGetTrendbarsRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required .ProtoOATrendbarPeriod period = 3;

    pub fn period(&self) -> super::OpenApiModelMessages::ProtoOATrendbarPeriod {
        match self.period {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1),
            None => super::OpenApiModelMessages::ProtoOATrendbarPeriod::M1,
        }
    }

    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: super::OpenApiModelMessages::ProtoOATrendbarPeriod) {
        self.period = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 timestamp = 4;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional int64 symbolId = 6;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // optional bool hasMore = 7;

    pub fn hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetTrendbarsRes| { &m.payloadType },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetTrendbarsRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "period",
            |m: &ProtoOAGetTrendbarsRes| { &m.period },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ProtoOAGetTrendbarsRes| { &m.timestamp },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trendbar",
            |m: &ProtoOAGetTrendbarsRes| { &m.trendbar },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.trendbar },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAGetTrendbarsRes| { &m.symbolId },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMore",
            |m: &ProtoOAGetTrendbarsRes| { &m.hasMore },
            |m: &mut ProtoOAGetTrendbarsRes| { &mut m.hasMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetTrendbarsRes>(
            "ProtoOAGetTrendbarsRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetTrendbarsRes {
    const NAME: &'static str = "ProtoOAGetTrendbarsRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.period.is_none() {
            return false;
        }
        for v in &self.trendbar {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.period = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.trendbar.push(is.read_message()?);
                },
                48 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.hasMore = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        for value in &self.trendbar {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.hasMore {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.period {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_int64(4, v)?;
        }
        for v in &self.trendbar {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.symbolId {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.hasMore {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetTrendbarsRes {
        ProtoOAGetTrendbarsRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.period = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.trendbar.clear();
        self.symbolId = ::std::option::Option::None;
        self.hasMore = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetTrendbarsRes {
        static instance: ProtoOAGetTrendbarsRes = ProtoOAGetTrendbarsRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            period: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            trendbar: ::std::vec::Vec::new(),
            symbolId: ::std::option::Option::None,
            hasMore: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetTrendbarsRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetTrendbarsRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetTrendbarsRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetTrendbarsRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetTickDataReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetTickDataReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetTickDataReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataReq.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataReq.type)
    pub type_: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAQuoteType>>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetTickDataReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetTickDataReq {
    fn default() -> &'a ProtoOAGetTickDataReq {
        <ProtoOAGetTickDataReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetTickDataReq {
    pub fn new() -> ProtoOAGetTickDataReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 symbolId = 3;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // required .ProtoOAQuoteType type = 4;

    pub fn type_(&self) -> super::OpenApiModelMessages::ProtoOAQuoteType {
        match self.type_ {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAQuoteType::BID),
            None => super::OpenApiModelMessages::ProtoOAQuoteType::BID,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: super::OpenApiModelMessages::ProtoOAQuoteType) {
        self.type_ = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 fromTimestamp = 5;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 toTimestamp = 6;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetTickDataReq| { &m.payloadType },
            |m: &mut ProtoOAGetTickDataReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetTickDataReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetTickDataReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAGetTickDataReq| { &m.symbolId },
            |m: &mut ProtoOAGetTickDataReq| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &ProtoOAGetTickDataReq| { &m.type_ },
            |m: &mut ProtoOAGetTickDataReq| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOAGetTickDataReq| { &m.fromTimestamp },
            |m: &mut ProtoOAGetTickDataReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOAGetTickDataReq| { &m.toTimestamp },
            |m: &mut ProtoOAGetTickDataReq| { &mut m.toTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetTickDataReq>(
            "ProtoOAGetTickDataReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetTickDataReq {
    const NAME: &'static str = "ProtoOAGetTickDataReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        if self.type_.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetTickDataReq {
        ProtoOAGetTickDataReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetTickDataReq {
        static instance: ProtoOAGetTickDataReq = ProtoOAGetTickDataReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetTickDataReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetTickDataReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetTickDataReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetTickDataReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetTickDataRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetTickDataRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetTickDataRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataRes.tickData)
    pub tickData: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOATickData>,
    // @@protoc_insertion_point(field:ProtoOAGetTickDataRes.hasMore)
    pub hasMore: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetTickDataRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetTickDataRes {
    fn default() -> &'a ProtoOAGetTickDataRes {
        <ProtoOAGetTickDataRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetTickDataRes {
    pub fn new() -> ProtoOAGetTickDataRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required bool hasMore = 4;

    pub fn hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetTickDataRes| { &m.payloadType },
            |m: &mut ProtoOAGetTickDataRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetTickDataRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetTickDataRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tickData",
            |m: &ProtoOAGetTickDataRes| { &m.tickData },
            |m: &mut ProtoOAGetTickDataRes| { &mut m.tickData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMore",
            |m: &ProtoOAGetTickDataRes| { &m.hasMore },
            |m: &mut ProtoOAGetTickDataRes| { &mut m.hasMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetTickDataRes>(
            "ProtoOAGetTickDataRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetTickDataRes {
    const NAME: &'static str = "ProtoOAGetTickDataRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.tickData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.tickData.push(is.read_message()?);
                },
                32 => {
                    self.hasMore = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.tickData {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.tickData {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetTickDataRes {
        ProtoOAGetTickDataRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.tickData.clear();
        self.hasMore = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetTickDataRes {
        static instance: ProtoOAGetTickDataRes = ProtoOAGetTickDataRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            tickData: ::std::vec::Vec::new(),
            hasMore: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetTickDataRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetTickDataRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetTickDataRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetTickDataRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetCtidProfileByTokenReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetCtidProfileByTokenReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetCtidProfileByTokenReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetCtidProfileByTokenReq.accessToken)
    pub accessToken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetCtidProfileByTokenReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetCtidProfileByTokenReq {
    fn default() -> &'a ProtoOAGetCtidProfileByTokenReq {
        <ProtoOAGetCtidProfileByTokenReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetCtidProfileByTokenReq {
    pub fn new() -> ProtoOAGetCtidProfileByTokenReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required string accessToken = 2;

    pub fn accessToken(&self) -> &str {
        match self.accessToken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_accessToken(&mut self) {
        self.accessToken = ::std::option::Option::None;
    }

    pub fn has_accessToken(&self) -> bool {
        self.accessToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessToken(&mut self, v: ::std::string::String) {
        self.accessToken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accessToken(&mut self) -> &mut ::std::string::String {
        if self.accessToken.is_none() {
            self.accessToken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.accessToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_accessToken(&mut self) -> ::std::string::String {
        self.accessToken.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetCtidProfileByTokenReq| { &m.payloadType },
            |m: &mut ProtoOAGetCtidProfileByTokenReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accessToken",
            |m: &ProtoOAGetCtidProfileByTokenReq| { &m.accessToken },
            |m: &mut ProtoOAGetCtidProfileByTokenReq| { &mut m.accessToken },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetCtidProfileByTokenReq>(
            "ProtoOAGetCtidProfileByTokenReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetCtidProfileByTokenReq {
    const NAME: &'static str = "ProtoOAGetCtidProfileByTokenReq";

    fn is_initialized(&self) -> bool {
        if self.accessToken.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.accessToken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.accessToken.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.accessToken.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetCtidProfileByTokenReq {
        ProtoOAGetCtidProfileByTokenReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.accessToken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetCtidProfileByTokenReq {
        static instance: ProtoOAGetCtidProfileByTokenReq = ProtoOAGetCtidProfileByTokenReq {
            payloadType: ::std::option::Option::None,
            accessToken: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetCtidProfileByTokenReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetCtidProfileByTokenReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetCtidProfileByTokenReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetCtidProfileByTokenReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetCtidProfileByTokenRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetCtidProfileByTokenRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetCtidProfileByTokenRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetCtidProfileByTokenRes.profile)
    pub profile: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOACtidProfile>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetCtidProfileByTokenRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetCtidProfileByTokenRes {
    fn default() -> &'a ProtoOAGetCtidProfileByTokenRes {
        <ProtoOAGetCtidProfileByTokenRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetCtidProfileByTokenRes {
    pub fn new() -> ProtoOAGetCtidProfileByTokenRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetCtidProfileByTokenRes| { &m.payloadType },
            |m: &mut ProtoOAGetCtidProfileByTokenRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOACtidProfile>(
            "profile",
            |m: &ProtoOAGetCtidProfileByTokenRes| { &m.profile },
            |m: &mut ProtoOAGetCtidProfileByTokenRes| { &mut m.profile },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetCtidProfileByTokenRes>(
            "ProtoOAGetCtidProfileByTokenRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetCtidProfileByTokenRes {
    const NAME: &'static str = "ProtoOAGetCtidProfileByTokenRes";

    fn is_initialized(&self) -> bool {
        if self.profile.is_none() {
            return false;
        }
        for v in &self.profile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.profile)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.profile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.profile.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetCtidProfileByTokenRes {
        ProtoOAGetCtidProfileByTokenRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.profile.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetCtidProfileByTokenRes {
        static instance: ProtoOAGetCtidProfileByTokenRes = ProtoOAGetCtidProfileByTokenRes {
            payloadType: ::std::option::Option::None,
            profile: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetCtidProfileByTokenRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetCtidProfileByTokenRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetCtidProfileByTokenRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetCtidProfileByTokenRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADepthEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADepthEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADepthEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADepthEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepthEvent.symbolId)
    pub symbolId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOADepthEvent.newQuotes)
    pub newQuotes: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADepthQuote>,
    // @@protoc_insertion_point(field:ProtoOADepthEvent.deletedQuotes)
    pub deletedQuotes: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADepthEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADepthEvent {
    fn default() -> &'a ProtoOADepthEvent {
        <ProtoOADepthEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADepthEvent {
    pub fn new() -> ProtoOADepthEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEPTH_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEPTH_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required uint64 symbolId = 3;

    pub fn symbolId(&self) -> u64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: u64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADepthEvent| { &m.payloadType },
            |m: &mut ProtoOADepthEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADepthEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADepthEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOADepthEvent| { &m.symbolId },
            |m: &mut ProtoOADepthEvent| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "newQuotes",
            |m: &ProtoOADepthEvent| { &m.newQuotes },
            |m: &mut ProtoOADepthEvent| { &mut m.newQuotes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deletedQuotes",
            |m: &ProtoOADepthEvent| { &m.deletedQuotes },
            |m: &mut ProtoOADepthEvent| { &mut m.deletedQuotes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADepthEvent>(
            "ProtoOADepthEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADepthEvent {
    const NAME: &'static str = "ProtoOADepthEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        for v in &self.newQuotes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.symbolId = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.newQuotes.push(is.read_message()?);
                },
                42 => {
                    is.read_repeated_packed_uint64_into(&mut self.deletedQuotes)?;
                },
                40 => {
                    self.deletedQuotes.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.newQuotes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::vec_packed_uint64_size(5, &self.deletedQuotes);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.symbolId {
            os.write_uint64(3, v)?;
        }
        for v in &self.newQuotes {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_repeated_packed_uint64(5, &self.deletedQuotes)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADepthEvent {
        ProtoOADepthEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.newQuotes.clear();
        self.deletedQuotes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADepthEvent {
        static instance: ProtoOADepthEvent = ProtoOADepthEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            newQuotes: ::std::vec::Vec::new(),
            deletedQuotes: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADepthEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADepthEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADepthEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADepthEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASubscribeDepthQuotesReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASubscribeDepthQuotesReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASubscribeDepthQuotesReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeDepthQuotesReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASubscribeDepthQuotesReq.symbolId)
    pub symbolId: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASubscribeDepthQuotesReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASubscribeDepthQuotesReq {
    fn default() -> &'a ProtoOASubscribeDepthQuotesReq {
        <ProtoOASubscribeDepthQuotesReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASubscribeDepthQuotesReq {
    pub fn new() -> ProtoOASubscribeDepthQuotesReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASubscribeDepthQuotesReq| { &m.payloadType },
            |m: &mut ProtoOASubscribeDepthQuotesReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASubscribeDepthQuotesReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASubscribeDepthQuotesReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASubscribeDepthQuotesReq| { &m.symbolId },
            |m: &mut ProtoOASubscribeDepthQuotesReq| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASubscribeDepthQuotesReq>(
            "ProtoOASubscribeDepthQuotesReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASubscribeDepthQuotesReq {
    const NAME: &'static str = "ProtoOASubscribeDepthQuotesReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.symbolId)?;
                },
                24 => {
                    self.symbolId.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolId {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASubscribeDepthQuotesReq {
        ProtoOASubscribeDepthQuotesReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASubscribeDepthQuotesReq {
        static instance: ProtoOASubscribeDepthQuotesReq = ProtoOASubscribeDepthQuotesReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASubscribeDepthQuotesReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASubscribeDepthQuotesReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASubscribeDepthQuotesReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASubscribeDepthQuotesReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASubscribeDepthQuotesRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASubscribeDepthQuotesRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASubscribeDepthQuotesRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASubscribeDepthQuotesRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASubscribeDepthQuotesRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASubscribeDepthQuotesRes {
    fn default() -> &'a ProtoOASubscribeDepthQuotesRes {
        <ProtoOASubscribeDepthQuotesRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASubscribeDepthQuotesRes {
    pub fn new() -> ProtoOASubscribeDepthQuotesRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASubscribeDepthQuotesRes| { &m.payloadType },
            |m: &mut ProtoOASubscribeDepthQuotesRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASubscribeDepthQuotesRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASubscribeDepthQuotesRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASubscribeDepthQuotesRes>(
            "ProtoOASubscribeDepthQuotesRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASubscribeDepthQuotesRes {
    const NAME: &'static str = "ProtoOASubscribeDepthQuotesRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASubscribeDepthQuotesRes {
        ProtoOASubscribeDepthQuotesRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASubscribeDepthQuotesRes {
        static instance: ProtoOASubscribeDepthQuotesRes = ProtoOASubscribeDepthQuotesRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASubscribeDepthQuotesRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASubscribeDepthQuotesRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASubscribeDepthQuotesRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASubscribeDepthQuotesRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAUnsubscribeDepthQuotesReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAUnsubscribeDepthQuotesReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeDepthQuotesReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeDepthQuotesReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeDepthQuotesReq.symbolId)
    pub symbolId: ::std::vec::Vec<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAUnsubscribeDepthQuotesReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAUnsubscribeDepthQuotesReq {
    fn default() -> &'a ProtoOAUnsubscribeDepthQuotesReq {
        <ProtoOAUnsubscribeDepthQuotesReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAUnsubscribeDepthQuotesReq {
    pub fn new() -> ProtoOAUnsubscribeDepthQuotesReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAUnsubscribeDepthQuotesReq| { &m.payloadType },
            |m: &mut ProtoOAUnsubscribeDepthQuotesReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAUnsubscribeDepthQuotesReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAUnsubscribeDepthQuotesReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAUnsubscribeDepthQuotesReq| { &m.symbolId },
            |m: &mut ProtoOAUnsubscribeDepthQuotesReq| { &mut m.symbolId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAUnsubscribeDepthQuotesReq>(
            "ProtoOAUnsubscribeDepthQuotesReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAUnsubscribeDepthQuotesReq {
    const NAME: &'static str = "ProtoOAUnsubscribeDepthQuotesReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    is.read_repeated_packed_int64_into(&mut self.symbolId)?;
                },
                24 => {
                    self.symbolId.push(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolId {
            my_size += ::protobuf::rt::int64_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolId {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAUnsubscribeDepthQuotesReq {
        ProtoOAUnsubscribeDepthQuotesReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolId.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAUnsubscribeDepthQuotesReq {
        static instance: ProtoOAUnsubscribeDepthQuotesReq = ProtoOAUnsubscribeDepthQuotesReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolId: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAUnsubscribeDepthQuotesReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAUnsubscribeDepthQuotesReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAUnsubscribeDepthQuotesReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAUnsubscribeDepthQuotesReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAUnsubscribeDepthQuotesRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAUnsubscribeDepthQuotesRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeDepthQuotesRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAUnsubscribeDepthQuotesRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAUnsubscribeDepthQuotesRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAUnsubscribeDepthQuotesRes {
    fn default() -> &'a ProtoOAUnsubscribeDepthQuotesRes {
        <ProtoOAUnsubscribeDepthQuotesRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAUnsubscribeDepthQuotesRes {
    pub fn new() -> ProtoOAUnsubscribeDepthQuotesRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAUnsubscribeDepthQuotesRes| { &m.payloadType },
            |m: &mut ProtoOAUnsubscribeDepthQuotesRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAUnsubscribeDepthQuotesRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAUnsubscribeDepthQuotesRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAUnsubscribeDepthQuotesRes>(
            "ProtoOAUnsubscribeDepthQuotesRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAUnsubscribeDepthQuotesRes {
    const NAME: &'static str = "ProtoOAUnsubscribeDepthQuotesRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAUnsubscribeDepthQuotesRes {
        ProtoOAUnsubscribeDepthQuotesRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAUnsubscribeDepthQuotesRes {
        static instance: ProtoOAUnsubscribeDepthQuotesRes = ProtoOAUnsubscribeDepthQuotesRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAUnsubscribeDepthQuotesRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAUnsubscribeDepthQuotesRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAUnsubscribeDepthQuotesRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAUnsubscribeDepthQuotesRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolCategoryListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolCategoryListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolCategoryListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolCategoryListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolCategoryListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolCategoryListReq {
    fn default() -> &'a ProtoOASymbolCategoryListReq {
        <ProtoOASymbolCategoryListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolCategoryListReq {
    pub fn new() -> ProtoOASymbolCategoryListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolCategoryListReq| { &m.payloadType },
            |m: &mut ProtoOASymbolCategoryListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolCategoryListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolCategoryListReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolCategoryListReq>(
            "ProtoOASymbolCategoryListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolCategoryListReq {
    const NAME: &'static str = "ProtoOASymbolCategoryListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolCategoryListReq {
        ProtoOASymbolCategoryListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolCategoryListReq {
        static instance: ProtoOASymbolCategoryListReq = ProtoOASymbolCategoryListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolCategoryListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolCategoryListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolCategoryListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolCategoryListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolCategoryListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolCategoryListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolCategoryListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOASymbolCategoryListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolCategoryListRes.symbolCategory)
    pub symbolCategory: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOASymbolCategory>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolCategoryListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolCategoryListRes {
    fn default() -> &'a ProtoOASymbolCategoryListRes {
        <ProtoOASymbolCategoryListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolCategoryListRes {
    pub fn new() -> ProtoOASymbolCategoryListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOASymbolCategoryListRes| { &m.payloadType },
            |m: &mut ProtoOASymbolCategoryListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOASymbolCategoryListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOASymbolCategoryListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "symbolCategory",
            |m: &ProtoOASymbolCategoryListRes| { &m.symbolCategory },
            |m: &mut ProtoOASymbolCategoryListRes| { &mut m.symbolCategory },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolCategoryListRes>(
            "ProtoOASymbolCategoryListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolCategoryListRes {
    const NAME: &'static str = "ProtoOASymbolCategoryListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.symbolCategory {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.symbolCategory.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.symbolCategory {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.symbolCategory {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolCategoryListRes {
        ProtoOASymbolCategoryListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.symbolCategory.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolCategoryListRes {
        static instance: ProtoOASymbolCategoryListRes = ProtoOASymbolCategoryListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            symbolCategory: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolCategoryListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolCategoryListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolCategoryListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolCategoryListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAccountLogoutReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAccountLogoutReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAccountLogoutReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAccountLogoutReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAccountLogoutReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAccountLogoutReq {
    fn default() -> &'a ProtoOAAccountLogoutReq {
        <ProtoOAAccountLogoutReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAccountLogoutReq {
    pub fn new() -> ProtoOAAccountLogoutReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAccountLogoutReq| { &m.payloadType },
            |m: &mut ProtoOAAccountLogoutReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAccountLogoutReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAccountLogoutReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAccountLogoutReq>(
            "ProtoOAAccountLogoutReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAccountLogoutReq {
    const NAME: &'static str = "ProtoOAAccountLogoutReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAccountLogoutReq {
        ProtoOAAccountLogoutReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAccountLogoutReq {
        static instance: ProtoOAAccountLogoutReq = ProtoOAAccountLogoutReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAccountLogoutReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAccountLogoutReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAccountLogoutReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAccountLogoutReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAccountLogoutRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAccountLogoutRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAccountLogoutRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAccountLogoutRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAccountLogoutRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAccountLogoutRes {
    fn default() -> &'a ProtoOAAccountLogoutRes {
        <ProtoOAAccountLogoutRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAccountLogoutRes {
    pub fn new() -> ProtoOAAccountLogoutRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAccountLogoutRes| { &m.payloadType },
            |m: &mut ProtoOAAccountLogoutRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAccountLogoutRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAccountLogoutRes| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAccountLogoutRes>(
            "ProtoOAAccountLogoutRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAccountLogoutRes {
    const NAME: &'static str = "ProtoOAAccountLogoutRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAccountLogoutRes {
        ProtoOAAccountLogoutRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAccountLogoutRes {
        static instance: ProtoOAAccountLogoutRes = ProtoOAAccountLogoutRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAccountLogoutRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAccountLogoutRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAccountLogoutRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAccountLogoutRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAccountDisconnectEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAccountDisconnectEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAccountDisconnectEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAAccountDisconnectEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAccountDisconnectEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAccountDisconnectEvent {
    fn default() -> &'a ProtoOAAccountDisconnectEvent {
        <ProtoOAAccountDisconnectEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAccountDisconnectEvent {
    pub fn new() -> ProtoOAAccountDisconnectEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_DISCONNECT_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ACCOUNT_DISCONNECT_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAAccountDisconnectEvent| { &m.payloadType },
            |m: &mut ProtoOAAccountDisconnectEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAAccountDisconnectEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAAccountDisconnectEvent| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAccountDisconnectEvent>(
            "ProtoOAAccountDisconnectEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAccountDisconnectEvent {
    const NAME: &'static str = "ProtoOAAccountDisconnectEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAccountDisconnectEvent {
        ProtoOAAccountDisconnectEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAccountDisconnectEvent {
        static instance: ProtoOAAccountDisconnectEvent = ProtoOAAccountDisconnectEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAccountDisconnectEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAccountDisconnectEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAccountDisconnectEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAccountDisconnectEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCallListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCallListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCallListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCallListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCallListReq {
    fn default() -> &'a ProtoOAMarginCallListReq {
        <ProtoOAMarginCallListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCallListReq {
    pub fn new() -> ProtoOAMarginCallListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginCallListReq| { &m.payloadType },
            |m: &mut ProtoOAMarginCallListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAMarginCallListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAMarginCallListReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCallListReq>(
            "ProtoOAMarginCallListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCallListReq {
    const NAME: &'static str = "ProtoOAMarginCallListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCallListReq {
        ProtoOAMarginCallListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCallListReq {
        static instance: ProtoOAMarginCallListReq = ProtoOAMarginCallListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCallListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCallListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCallListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCallListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCallListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCallListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCallListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallListRes.marginCall)
    pub marginCall: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAMarginCall>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCallListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCallListRes {
    fn default() -> &'a ProtoOAMarginCallListRes {
        <ProtoOAMarginCallListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCallListRes {
    pub fn new() -> ProtoOAMarginCallListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginCallListRes| { &m.payloadType },
            |m: &mut ProtoOAMarginCallListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "marginCall",
            |m: &ProtoOAMarginCallListRes| { &m.marginCall },
            |m: &mut ProtoOAMarginCallListRes| { &mut m.marginCall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCallListRes>(
            "ProtoOAMarginCallListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCallListRes {
    const NAME: &'static str = "ProtoOAMarginCallListRes";

    fn is_initialized(&self) -> bool {
        for v in &self.marginCall {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.marginCall.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.marginCall {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.marginCall {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCallListRes {
        ProtoOAMarginCallListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.marginCall.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCallListRes {
        static instance: ProtoOAMarginCallListRes = ProtoOAMarginCallListRes {
            payloadType: ::std::option::Option::None,
            marginCall: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCallListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCallListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCallListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCallListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCallUpdateReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCallUpdateReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateReq.marginCall)
    pub marginCall: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOAMarginCall>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCallUpdateReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCallUpdateReq {
    fn default() -> &'a ProtoOAMarginCallUpdateReq {
        <ProtoOAMarginCallUpdateReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCallUpdateReq {
    pub fn new() -> ProtoOAMarginCallUpdateReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginCallUpdateReq| { &m.payloadType },
            |m: &mut ProtoOAMarginCallUpdateReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAMarginCallUpdateReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAMarginCallUpdateReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOAMarginCall>(
            "marginCall",
            |m: &ProtoOAMarginCallUpdateReq| { &m.marginCall },
            |m: &mut ProtoOAMarginCallUpdateReq| { &mut m.marginCall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCallUpdateReq>(
            "ProtoOAMarginCallUpdateReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCallUpdateReq {
    const NAME: &'static str = "ProtoOAMarginCallUpdateReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.marginCall.is_none() {
            return false;
        }
        for v in &self.marginCall {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.marginCall)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.marginCall.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.marginCall.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCallUpdateReq {
        ProtoOAMarginCallUpdateReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.marginCall.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCallUpdateReq {
        static instance: ProtoOAMarginCallUpdateReq = ProtoOAMarginCallUpdateReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            marginCall: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCallUpdateReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCallUpdateReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCallUpdateReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCallUpdateReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCallUpdateRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCallUpdateRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCallUpdateRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCallUpdateRes {
    fn default() -> &'a ProtoOAMarginCallUpdateRes {
        <ProtoOAMarginCallUpdateRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCallUpdateRes {
    pub fn new() -> ProtoOAMarginCallUpdateRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginCallUpdateRes| { &m.payloadType },
            |m: &mut ProtoOAMarginCallUpdateRes| { &mut m.payloadType },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCallUpdateRes>(
            "ProtoOAMarginCallUpdateRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCallUpdateRes {
    const NAME: &'static str = "ProtoOAMarginCallUpdateRes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCallUpdateRes {
        ProtoOAMarginCallUpdateRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCallUpdateRes {
        static instance: ProtoOAMarginCallUpdateRes = ProtoOAMarginCallUpdateRes {
            payloadType: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCallUpdateRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCallUpdateRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCallUpdateRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCallUpdateRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCallUpdateEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCallUpdateEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallUpdateEvent.marginCall)
    pub marginCall: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOAMarginCall>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCallUpdateEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCallUpdateEvent {
    fn default() -> &'a ProtoOAMarginCallUpdateEvent {
        <ProtoOAMarginCallUpdateEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCallUpdateEvent {
    pub fn new() -> ProtoOAMarginCallUpdateEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginCallUpdateEvent| { &m.payloadType },
            |m: &mut ProtoOAMarginCallUpdateEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAMarginCallUpdateEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAMarginCallUpdateEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOAMarginCall>(
            "marginCall",
            |m: &ProtoOAMarginCallUpdateEvent| { &m.marginCall },
            |m: &mut ProtoOAMarginCallUpdateEvent| { &mut m.marginCall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCallUpdateEvent>(
            "ProtoOAMarginCallUpdateEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCallUpdateEvent {
    const NAME: &'static str = "ProtoOAMarginCallUpdateEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.marginCall.is_none() {
            return false;
        }
        for v in &self.marginCall {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.marginCall)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.marginCall.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.marginCall.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCallUpdateEvent {
        ProtoOAMarginCallUpdateEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.marginCall.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCallUpdateEvent {
        static instance: ProtoOAMarginCallUpdateEvent = ProtoOAMarginCallUpdateEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            marginCall: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCallUpdateEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCallUpdateEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCallUpdateEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCallUpdateEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCallTriggerEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCallTriggerEvent {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCallTriggerEvent.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallTriggerEvent.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAMarginCallTriggerEvent.marginCall)
    pub marginCall: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOAMarginCall>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCallTriggerEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCallTriggerEvent {
    fn default() -> &'a ProtoOAMarginCallTriggerEvent {
        <ProtoOAMarginCallTriggerEvent as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCallTriggerEvent {
    pub fn new() -> ProtoOAMarginCallTriggerEvent {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_TRIGGER_EVENT),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_TRIGGER_EVENT,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAMarginCallTriggerEvent| { &m.payloadType },
            |m: &mut ProtoOAMarginCallTriggerEvent| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAMarginCallTriggerEvent| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAMarginCallTriggerEvent| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOAMarginCall>(
            "marginCall",
            |m: &ProtoOAMarginCallTriggerEvent| { &m.marginCall },
            |m: &mut ProtoOAMarginCallTriggerEvent| { &mut m.marginCall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCallTriggerEvent>(
            "ProtoOAMarginCallTriggerEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCallTriggerEvent {
    const NAME: &'static str = "ProtoOAMarginCallTriggerEvent";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.marginCall.is_none() {
            return false;
        }
        for v in &self.marginCall {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.marginCall)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.marginCall.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.marginCall.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCallTriggerEvent {
        ProtoOAMarginCallTriggerEvent::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.marginCall.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCallTriggerEvent {
        static instance: ProtoOAMarginCallTriggerEvent = ProtoOAMarginCallTriggerEvent {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            marginCall: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCallTriggerEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCallTriggerEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCallTriggerEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCallTriggerEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetDynamicLeverageByIDReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetDynamicLeverageByIDReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetDynamicLeverageByIDReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetDynamicLeverageByIDReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetDynamicLeverageByIDReq.leverageId)
    pub leverageId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetDynamicLeverageByIDReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetDynamicLeverageByIDReq {
    fn default() -> &'a ProtoOAGetDynamicLeverageByIDReq {
        <ProtoOAGetDynamicLeverageByIDReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetDynamicLeverageByIDReq {
    pub fn new() -> ProtoOAGetDynamicLeverageByIDReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 leverageId = 3;

    pub fn leverageId(&self) -> i64 {
        self.leverageId.unwrap_or(0)
    }

    pub fn clear_leverageId(&mut self) {
        self.leverageId = ::std::option::Option::None;
    }

    pub fn has_leverageId(&self) -> bool {
        self.leverageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leverageId(&mut self, v: i64) {
        self.leverageId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetDynamicLeverageByIDReq| { &m.payloadType },
            |m: &mut ProtoOAGetDynamicLeverageByIDReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetDynamicLeverageByIDReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetDynamicLeverageByIDReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leverageId",
            |m: &ProtoOAGetDynamicLeverageByIDReq| { &m.leverageId },
            |m: &mut ProtoOAGetDynamicLeverageByIDReq| { &mut m.leverageId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetDynamicLeverageByIDReq>(
            "ProtoOAGetDynamicLeverageByIDReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetDynamicLeverageByIDReq {
    const NAME: &'static str = "ProtoOAGetDynamicLeverageByIDReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.leverageId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.leverageId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.leverageId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.leverageId {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetDynamicLeverageByIDReq {
        ProtoOAGetDynamicLeverageByIDReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.leverageId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetDynamicLeverageByIDReq {
        static instance: ProtoOAGetDynamicLeverageByIDReq = ProtoOAGetDynamicLeverageByIDReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            leverageId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetDynamicLeverageByIDReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetDynamicLeverageByIDReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetDynamicLeverageByIDReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetDynamicLeverageByIDReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetDynamicLeverageByIDRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetDynamicLeverageByIDRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetDynamicLeverageByIDRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetDynamicLeverageByIDRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetDynamicLeverageByIDRes.leverage)
    pub leverage: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOADynamicLeverage>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetDynamicLeverageByIDRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetDynamicLeverageByIDRes {
    fn default() -> &'a ProtoOAGetDynamicLeverageByIDRes {
        <ProtoOAGetDynamicLeverageByIDRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetDynamicLeverageByIDRes {
    pub fn new() -> ProtoOAGetDynamicLeverageByIDRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetDynamicLeverageByIDRes| { &m.payloadType },
            |m: &mut ProtoOAGetDynamicLeverageByIDRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetDynamicLeverageByIDRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetDynamicLeverageByIDRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOADynamicLeverage>(
            "leverage",
            |m: &ProtoOAGetDynamicLeverageByIDRes| { &m.leverage },
            |m: &mut ProtoOAGetDynamicLeverageByIDRes| { &mut m.leverage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetDynamicLeverageByIDRes>(
            "ProtoOAGetDynamicLeverageByIDRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetDynamicLeverageByIDRes {
    const NAME: &'static str = "ProtoOAGetDynamicLeverageByIDRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.leverage.is_none() {
            return false;
        }
        for v in &self.leverage {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.leverage)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.leverage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.leverage.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetDynamicLeverageByIDRes {
        ProtoOAGetDynamicLeverageByIDRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.leverage.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetDynamicLeverageByIDRes {
        static instance: ProtoOAGetDynamicLeverageByIDRes = ProtoOAGetDynamicLeverageByIDRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            leverage: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetDynamicLeverageByIDRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetDynamicLeverageByIDRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetDynamicLeverageByIDRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetDynamicLeverageByIDRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealListByPositionIdReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealListByPositionIdReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdReq.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealListByPositionIdReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealListByPositionIdReq {
    fn default() -> &'a ProtoOADealListByPositionIdReq {
        <ProtoOADealListByPositionIdReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealListByPositionIdReq {
    pub fn new() -> ProtoOADealListByPositionIdReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 positionId = 3;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // optional int64 fromTimestamp = 4;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 toTimestamp = 5;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADealListByPositionIdReq| { &m.payloadType },
            |m: &mut ProtoOADealListByPositionIdReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADealListByPositionIdReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADealListByPositionIdReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOADealListByPositionIdReq| { &m.positionId },
            |m: &mut ProtoOADealListByPositionIdReq| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOADealListByPositionIdReq| { &m.fromTimestamp },
            |m: &mut ProtoOADealListByPositionIdReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOADealListByPositionIdReq| { &m.toTimestamp },
            |m: &mut ProtoOADealListByPositionIdReq| { &mut m.toTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealListByPositionIdReq>(
            "ProtoOADealListByPositionIdReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealListByPositionIdReq {
    const NAME: &'static str = "ProtoOADealListByPositionIdReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealListByPositionIdReq {
        ProtoOADealListByPositionIdReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealListByPositionIdReq {
        static instance: ProtoOADealListByPositionIdReq = ProtoOADealListByPositionIdReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealListByPositionIdReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealListByPositionIdReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealListByPositionIdReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealListByPositionIdReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealListByPositionIdRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealListByPositionIdRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdRes.deal)
    pub deal: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADeal>,
    // @@protoc_insertion_point(field:ProtoOADealListByPositionIdRes.hasMore)
    pub hasMore: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealListByPositionIdRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealListByPositionIdRes {
    fn default() -> &'a ProtoOADealListByPositionIdRes {
        <ProtoOADealListByPositionIdRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealListByPositionIdRes {
    pub fn new() -> ProtoOADealListByPositionIdRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required bool hasMore = 4;

    pub fn hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADealListByPositionIdRes| { &m.payloadType },
            |m: &mut ProtoOADealListByPositionIdRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADealListByPositionIdRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADealListByPositionIdRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deal",
            |m: &ProtoOADealListByPositionIdRes| { &m.deal },
            |m: &mut ProtoOADealListByPositionIdRes| { &mut m.deal },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMore",
            |m: &ProtoOADealListByPositionIdRes| { &m.hasMore },
            |m: &mut ProtoOADealListByPositionIdRes| { &mut m.hasMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealListByPositionIdRes>(
            "ProtoOADealListByPositionIdRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealListByPositionIdRes {
    const NAME: &'static str = "ProtoOADealListByPositionIdRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.deal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.deal.push(is.read_message()?);
                },
                32 => {
                    self.hasMore = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.deal {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.deal {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealListByPositionIdRes {
        ProtoOADealListByPositionIdRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.deal.clear();
        self.hasMore = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealListByPositionIdRes {
        static instance: ProtoOADealListByPositionIdRes = ProtoOADealListByPositionIdRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            deal: ::std::vec::Vec::new(),
            hasMore: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealListByPositionIdRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealListByPositionIdRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealListByPositionIdRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealListByPositionIdRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderDetailsReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderDetailsReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsReq.orderId)
    pub orderId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderDetailsReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderDetailsReq {
    fn default() -> &'a ProtoOAOrderDetailsReq {
        <ProtoOAOrderDetailsReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderDetailsReq {
    pub fn new() -> ProtoOAOrderDetailsReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 orderId = 3;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderDetailsReq| { &m.payloadType },
            |m: &mut ProtoOAOrderDetailsReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderDetailsReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderDetailsReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOAOrderDetailsReq| { &m.orderId },
            |m: &mut ProtoOAOrderDetailsReq| { &mut m.orderId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderDetailsReq>(
            "ProtoOAOrderDetailsReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderDetailsReq {
    const NAME: &'static str = "ProtoOAOrderDetailsReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.orderId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.orderId {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderDetailsReq {
        ProtoOAOrderDetailsReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.orderId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderDetailsReq {
        static instance: ProtoOAOrderDetailsReq = ProtoOAOrderDetailsReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            orderId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderDetailsReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderDetailsReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderDetailsReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderDetailsReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderDetailsRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderDetailsRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsRes.order)
    pub order: ::protobuf::MessageField<super::OpenApiModelMessages::ProtoOAOrder>,
    // @@protoc_insertion_point(field:ProtoOAOrderDetailsRes.deal)
    pub deal: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADeal>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderDetailsRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderDetailsRes {
    fn default() -> &'a ProtoOAOrderDetailsRes {
        <ProtoOAOrderDetailsRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderDetailsRes {
    pub fn new() -> ProtoOAOrderDetailsRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderDetailsRes| { &m.payloadType },
            |m: &mut ProtoOAOrderDetailsRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderDetailsRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderDetailsRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::OpenApiModelMessages::ProtoOAOrder>(
            "order",
            |m: &ProtoOAOrderDetailsRes| { &m.order },
            |m: &mut ProtoOAOrderDetailsRes| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deal",
            |m: &ProtoOAOrderDetailsRes| { &m.deal },
            |m: &mut ProtoOAOrderDetailsRes| { &mut m.deal },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderDetailsRes>(
            "ProtoOAOrderDetailsRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderDetailsRes {
    const NAME: &'static str = "ProtoOAOrderDetailsRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.order.is_none() {
            return false;
        }
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.order)?;
                },
                34 => {
                    self.deal.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.order.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.deal {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.order.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.deal {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderDetailsRes {
        ProtoOAOrderDetailsRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.order.clear();
        self.deal.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderDetailsRes {
        static instance: ProtoOAOrderDetailsRes = ProtoOAOrderDetailsRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            order: ::protobuf::MessageField::none(),
            deal: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderDetailsRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderDetailsRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderDetailsRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderDetailsRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderListByPositionIdReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderListByPositionIdReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdReq.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdReq.fromTimestamp)
    pub fromTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdReq.toTimestamp)
    pub toTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderListByPositionIdReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderListByPositionIdReq {
    fn default() -> &'a ProtoOAOrderListByPositionIdReq {
        <ProtoOAOrderListByPositionIdReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderListByPositionIdReq {
    pub fn new() -> ProtoOAOrderListByPositionIdReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 positionId = 3;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // optional int64 fromTimestamp = 4;

    pub fn fromTimestamp(&self) -> i64 {
        self.fromTimestamp.unwrap_or(0)
    }

    pub fn clear_fromTimestamp(&mut self) {
        self.fromTimestamp = ::std::option::Option::None;
    }

    pub fn has_fromTimestamp(&self) -> bool {
        self.fromTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fromTimestamp(&mut self, v: i64) {
        self.fromTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 toTimestamp = 5;

    pub fn toTimestamp(&self) -> i64 {
        self.toTimestamp.unwrap_or(0)
    }

    pub fn clear_toTimestamp(&mut self) {
        self.toTimestamp = ::std::option::Option::None;
    }

    pub fn has_toTimestamp(&self) -> bool {
        self.toTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toTimestamp(&mut self, v: i64) {
        self.toTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderListByPositionIdReq| { &m.payloadType },
            |m: &mut ProtoOAOrderListByPositionIdReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderListByPositionIdReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderListByPositionIdReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAOrderListByPositionIdReq| { &m.positionId },
            |m: &mut ProtoOAOrderListByPositionIdReq| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fromTimestamp",
            |m: &ProtoOAOrderListByPositionIdReq| { &m.fromTimestamp },
            |m: &mut ProtoOAOrderListByPositionIdReq| { &mut m.fromTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "toTimestamp",
            |m: &ProtoOAOrderListByPositionIdReq| { &m.toTimestamp },
            |m: &mut ProtoOAOrderListByPositionIdReq| { &mut m.toTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderListByPositionIdReq>(
            "ProtoOAOrderListByPositionIdReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderListByPositionIdReq {
    const NAME: &'static str = "ProtoOAOrderListByPositionIdReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.fromTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.toTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.fromTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.toTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.fromTimestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.toTimestamp {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderListByPositionIdReq {
        ProtoOAOrderListByPositionIdReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.fromTimestamp = ::std::option::Option::None;
        self.toTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderListByPositionIdReq {
        static instance: ProtoOAOrderListByPositionIdReq = ProtoOAOrderListByPositionIdReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            fromTimestamp: ::std::option::Option::None,
            toTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderListByPositionIdReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderListByPositionIdReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderListByPositionIdReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderListByPositionIdReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrderListByPositionIdRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrderListByPositionIdRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdRes.order)
    pub order: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAOrder>,
    // @@protoc_insertion_point(field:ProtoOAOrderListByPositionIdRes.hasMore)
    pub hasMore: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrderListByPositionIdRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrderListByPositionIdRes {
    fn default() -> &'a ProtoOAOrderListByPositionIdRes {
        <ProtoOAOrderListByPositionIdRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrderListByPositionIdRes {
    pub fn new() -> ProtoOAOrderListByPositionIdRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required bool hasMore = 4;

    pub fn hasMore(&self) -> bool {
        self.hasMore.unwrap_or(false)
    }

    pub fn clear_hasMore(&mut self) {
        self.hasMore = ::std::option::Option::None;
    }

    pub fn has_hasMore(&self) -> bool {
        self.hasMore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hasMore(&mut self, v: bool) {
        self.hasMore = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAOrderListByPositionIdRes| { &m.payloadType },
            |m: &mut ProtoOAOrderListByPositionIdRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAOrderListByPositionIdRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAOrderListByPositionIdRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "order",
            |m: &ProtoOAOrderListByPositionIdRes| { &m.order },
            |m: &mut ProtoOAOrderListByPositionIdRes| { &mut m.order },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hasMore",
            |m: &ProtoOAOrderListByPositionIdRes| { &m.hasMore },
            |m: &mut ProtoOAOrderListByPositionIdRes| { &mut m.hasMore },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrderListByPositionIdRes>(
            "ProtoOAOrderListByPositionIdRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrderListByPositionIdRes {
    const NAME: &'static str = "ProtoOAOrderListByPositionIdRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.hasMore.is_none() {
            return false;
        }
        for v in &self.order {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.order.push(is.read_message()?);
                },
                32 => {
                    self.hasMore = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.order {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.hasMore {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.order {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.hasMore {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrderListByPositionIdRes {
        ProtoOAOrderListByPositionIdRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.order.clear();
        self.hasMore = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrderListByPositionIdRes {
        static instance: ProtoOAOrderListByPositionIdRes = ProtoOAOrderListByPositionIdRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            order: ::std::vec::Vec::new(),
            hasMore: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrderListByPositionIdRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrderListByPositionIdRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrderListByPositionIdRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrderListByPositionIdRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealOffsetListReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealOffsetListReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealOffsetListReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADealOffsetListReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealOffsetListReq.dealId)
    pub dealId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealOffsetListReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealOffsetListReq {
    fn default() -> &'a ProtoOADealOffsetListReq {
        <ProtoOADealOffsetListReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealOffsetListReq {
    pub fn new() -> ProtoOADealOffsetListReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 dealId = 3;

    pub fn dealId(&self) -> i64 {
        self.dealId.unwrap_or(0)
    }

    pub fn clear_dealId(&mut self) {
        self.dealId = ::std::option::Option::None;
    }

    pub fn has_dealId(&self) -> bool {
        self.dealId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dealId(&mut self, v: i64) {
        self.dealId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADealOffsetListReq| { &m.payloadType },
            |m: &mut ProtoOADealOffsetListReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADealOffsetListReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADealOffsetListReq| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dealId",
            |m: &ProtoOADealOffsetListReq| { &m.dealId },
            |m: &mut ProtoOADealOffsetListReq| { &mut m.dealId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealOffsetListReq>(
            "ProtoOADealOffsetListReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealOffsetListReq {
    const NAME: &'static str = "ProtoOADealOffsetListReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.dealId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.dealId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.dealId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.dealId {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealOffsetListReq {
        ProtoOADealOffsetListReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.dealId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealOffsetListReq {
        static instance: ProtoOADealOffsetListReq = ProtoOADealOffsetListReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            dealId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealOffsetListReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealOffsetListReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealOffsetListReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealOffsetListReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealOffsetListRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealOffsetListRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealOffsetListRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOADealOffsetListRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealOffsetListRes.offsetBy)
    pub offsetBy: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADealOffset>,
    // @@protoc_insertion_point(field:ProtoOADealOffsetListRes.offsetting)
    pub offsetting: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOADealOffset>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealOffsetListRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealOffsetListRes {
    fn default() -> &'a ProtoOADealOffsetListRes {
        <ProtoOADealOffsetListRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealOffsetListRes {
    pub fn new() -> ProtoOADealOffsetListRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOADealOffsetListRes| { &m.payloadType },
            |m: &mut ProtoOADealOffsetListRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOADealOffsetListRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOADealOffsetListRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "offsetBy",
            |m: &ProtoOADealOffsetListRes| { &m.offsetBy },
            |m: &mut ProtoOADealOffsetListRes| { &mut m.offsetBy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "offsetting",
            |m: &ProtoOADealOffsetListRes| { &m.offsetting },
            |m: &mut ProtoOADealOffsetListRes| { &mut m.offsetting },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealOffsetListRes>(
            "ProtoOADealOffsetListRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealOffsetListRes {
    const NAME: &'static str = "ProtoOADealOffsetListRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        for v in &self.offsetBy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.offsetting {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.offsetBy.push(is.read_message()?);
                },
                34 => {
                    self.offsetting.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.offsetBy {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.offsetting {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.offsetBy {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.offsetting {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealOffsetListRes {
        ProtoOADealOffsetListRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.offsetBy.clear();
        self.offsetting.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealOffsetListRes {
        static instance: ProtoOADealOffsetListRes = ProtoOADealOffsetListRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            offsetBy: ::std::vec::Vec::new(),
            offsetting: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealOffsetListRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealOffsetListRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealOffsetListRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealOffsetListRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetPositionUnrealizedPnLReq)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetPositionUnrealizedPnLReq {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetPositionUnrealizedPnLReq.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetPositionUnrealizedPnLReq.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetPositionUnrealizedPnLReq.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetPositionUnrealizedPnLReq {
    fn default() -> &'a ProtoOAGetPositionUnrealizedPnLReq {
        <ProtoOAGetPositionUnrealizedPnLReq as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetPositionUnrealizedPnLReq {
    pub fn new() -> ProtoOAGetPositionUnrealizedPnLReq {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetPositionUnrealizedPnLReq| { &m.payloadType },
            |m: &mut ProtoOAGetPositionUnrealizedPnLReq| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetPositionUnrealizedPnLReq| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetPositionUnrealizedPnLReq| { &mut m.ctidTraderAccountId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetPositionUnrealizedPnLReq>(
            "ProtoOAGetPositionUnrealizedPnLReq",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetPositionUnrealizedPnLReq {
    const NAME: &'static str = "ProtoOAGetPositionUnrealizedPnLReq";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetPositionUnrealizedPnLReq {
        ProtoOAGetPositionUnrealizedPnLReq::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetPositionUnrealizedPnLReq {
        static instance: ProtoOAGetPositionUnrealizedPnLReq = ProtoOAGetPositionUnrealizedPnLReq {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetPositionUnrealizedPnLReq {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetPositionUnrealizedPnLReq").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetPositionUnrealizedPnLReq {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetPositionUnrealizedPnLReq {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAGetPositionUnrealizedPnLRes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAGetPositionUnrealizedPnLRes {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAGetPositionUnrealizedPnLRes.payloadType)
    pub payloadType: ::std::option::Option<::protobuf::EnumOrUnknown<super::OpenApiModelMessages::ProtoOAPayloadType>>,
    // @@protoc_insertion_point(field:ProtoOAGetPositionUnrealizedPnLRes.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAGetPositionUnrealizedPnLRes.positionUnrealizedPnL)
    pub positionUnrealizedPnL: ::std::vec::Vec<super::OpenApiModelMessages::ProtoOAPositionUnrealizedPnL>,
    // @@protoc_insertion_point(field:ProtoOAGetPositionUnrealizedPnLRes.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAGetPositionUnrealizedPnLRes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAGetPositionUnrealizedPnLRes {
    fn default() -> &'a ProtoOAGetPositionUnrealizedPnLRes {
        <ProtoOAGetPositionUnrealizedPnLRes as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAGetPositionUnrealizedPnLRes {
    pub fn new() -> ProtoOAGetPositionUnrealizedPnLRes {
        ::std::default::Default::default()
    }

    // optional .ProtoOAPayloadType payloadType = 1;

    pub fn payloadType(&self) -> super::OpenApiModelMessages::ProtoOAPayloadType {
        match self.payloadType {
            Some(e) => e.enum_value_or(super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES),
            None => super::OpenApiModelMessages::ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES,
        }
    }

    pub fn clear_payloadType(&mut self) {
        self.payloadType = ::std::option::Option::None;
    }

    pub fn has_payloadType(&self) -> bool {
        self.payloadType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payloadType(&mut self, v: super::OpenApiModelMessages::ProtoOAPayloadType) {
        self.payloadType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 ctidTraderAccountId = 2;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required uint32 moneyDigits = 4;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payloadType",
            |m: &ProtoOAGetPositionUnrealizedPnLRes| { &m.payloadType },
            |m: &mut ProtoOAGetPositionUnrealizedPnLRes| { &mut m.payloadType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOAGetPositionUnrealizedPnLRes| { &m.ctidTraderAccountId },
            |m: &mut ProtoOAGetPositionUnrealizedPnLRes| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positionUnrealizedPnL",
            |m: &ProtoOAGetPositionUnrealizedPnLRes| { &m.positionUnrealizedPnL },
            |m: &mut ProtoOAGetPositionUnrealizedPnLRes| { &mut m.positionUnrealizedPnL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOAGetPositionUnrealizedPnLRes| { &m.moneyDigits },
            |m: &mut ProtoOAGetPositionUnrealizedPnLRes| { &mut m.moneyDigits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAGetPositionUnrealizedPnLRes>(
            "ProtoOAGetPositionUnrealizedPnLRes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAGetPositionUnrealizedPnLRes {
    const NAME: &'static str = "ProtoOAGetPositionUnrealizedPnLRes";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.moneyDigits.is_none() {
            return false;
        }
        for v in &self.positionUnrealizedPnL {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.payloadType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.positionUnrealizedPnL.push(is.read_message()?);
                },
                32 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.payloadType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        for value in &self.positionUnrealizedPnL {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.payloadType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(2, v)?;
        }
        for v in &self.positionUnrealizedPnL {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.moneyDigits {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAGetPositionUnrealizedPnLRes {
        ProtoOAGetPositionUnrealizedPnLRes::new()
    }

    fn clear(&mut self) {
        self.payloadType = ::std::option::Option::None;
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.positionUnrealizedPnL.clear();
        self.moneyDigits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAGetPositionUnrealizedPnLRes {
        static instance: ProtoOAGetPositionUnrealizedPnLRes = ProtoOAGetPositionUnrealizedPnLRes {
            payloadType: ::std::option::Option::None,
            ctidTraderAccountId: ::std::option::Option::None,
            positionUnrealizedPnL: ::std::vec::Vec::new(),
            moneyDigits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAGetPositionUnrealizedPnLRes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAGetPositionUnrealizedPnLRes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAGetPositionUnrealizedPnLRes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAGetPositionUnrealizedPnLRes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15OpenApiMessages.proto\x1a\x1aOpenApiModelMessages.proto\"\xb1\x01\
    \n\x19ProtoOAApplicationAuthReq\x12T\n\x0bpayloadType\x18\x01\x20\x01(\
    \x0e2\x13.ProtoOAPayloadType:\x1dPROTO_OA_APPLICATION_AUTH_REQR\x0bpaylo\
    adType\x12\x1a\n\x08clientId\x18\x02\x20\x02(\tR\x08clientId\x12\"\n\x0c\
    clientSecret\x18\x03\x20\x02(\tR\x0cclientSecret\"q\n\x19ProtoOAApplicat\
    ionAuthRes\x12T\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloa\
    dType:\x1dPROTO_OA_APPLICATION_AUTH_RESR\x0bpayloadType\"\xbd\x01\n\x15P\
    rotoOAAccountAuthReq\x12P\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.Pro\
    toOAPayloadType:\x19PROTO_OA_ACCOUNT_AUTH_REQR\x0bpayloadType\x120\n\x13\
    ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x20\
    \n\x0baccessToken\x18\x03\x20\x02(\tR\x0baccessToken\"\x9b\x01\n\x15Prot\
    oOAAccountAuthRes\x12P\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoO\
    APayloadType:\x19PROTO_OA_ACCOUNT_AUTH_RESR\x0bpayloadType\x120\n\x13cti\
    dTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\"\xa8\x02\
    \n\x0fProtoOAErrorRes\x12I\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.Pr\
    otoOAPayloadType:\x12PROTO_OA_ERROR_RESR\x0bpayloadType\x120\n\x13ctidTr\
    aderAccountId\x18\x02\x20\x01(\x03R\x13ctidTraderAccountId\x12\x1c\n\ter\
    rorCode\x18\x03\x20\x02(\tR\terrorCode\x12\x20\n\x0bdescription\x18\x04\
    \x20\x01(\tR\x0bdescription\x128\n\x17maintenanceEndTimestamp\x18\x05\
    \x20\x01(\x03R\x17maintenanceEndTimestamp\x12\x1e\n\nretryAfter\x18\x06\
    \x20\x01(\x04R\nretryAfter\"\x8f\x01\n\x1cProtoOAClientDisconnectEvent\
    \x12W\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x20\
    PROTO_OA_CLIENT_DISCONNECT_EVENTR\x0bpayloadType\x12\x16\n\x06reason\x18\
    \x02\x20\x01(\tR\x06reason\"\xd4\x01\n$ProtoOAAccountsTokenInvalidatedEv\
    ent\x12`\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:)\
    PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENTR\x0bpayloadType\x122\n\x14ctid\
    TraderAccountIds\x18\x02\x20\x03(\x03R\x14ctidTraderAccountIds\x12\x16\n\
    \x06reason\x18\x03\x20\x01(\tR\x06reason\"`\n\x11ProtoOAVersionReq\x12K\
    \n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x14PROTO\
    _OA_VERSION_REQR\x0bpayloadType\"z\n\x11ProtoOAVersionRes\x12K\n\x0bpayl\
    oadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x14PROTO_OA_VERSIO\
    N_RESR\x0bpayloadType\x12\x18\n\x07version\x18\x02\x20\x02(\tR\x07versio\
    n\"\xf9\x07\n\x12ProtoOANewOrderReq\x12M\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x16PROTO_OA_NEW_ORDER_REQR\x0bpayload\
    Type\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAc\
    countId\x12\x1a\n\x08symbolId\x18\x03\x20\x02(\x03R\x08symbolId\x12/\n\t\
    orderType\x18\x04\x20\x02(\x0e2\x11.ProtoOAOrderTypeR\torderType\x12/\n\
    \ttradeSide\x18\x05\x20\x02(\x0e2\x11.ProtoOATradeSideR\ttradeSide\x12\
    \x16\n\x06volume\x18\x06\x20\x02(\x03R\x06volume\x12\x1e\n\nlimitPrice\
    \x18\x07\x20\x01(\x01R\nlimitPrice\x12\x1c\n\tstopPrice\x18\x08\x20\x01(\
    \x01R\tstopPrice\x12G\n\x0btimeInForce\x18\t\x20\x01(\x0e2\x13.ProtoOATi\
    meInForce:\x10GOOD_TILL_CANCELR\x0btimeInForce\x120\n\x13expirationTimes\
    tamp\x18\n\x20\x01(\x03R\x13expirationTimestamp\x12\x1a\n\x08stopLoss\
    \x18\x0b\x20\x01(\x01R\x08stopLoss\x12\x1e\n\ntakeProfit\x18\x0c\x20\x01\
    (\x01R\ntakeProfit\x12\x18\n\x07comment\x18\r\x20\x01(\tR\x07comment\x12\
    ,\n\x11baseSlippagePrice\x18\x0e\x20\x01(\x01R\x11baseSlippagePrice\x12*\
    \n\x10slippageInPoints\x18\x0f\x20\x01(\x05R\x10slippageInPoints\x12\x14\
    \n\x05label\x18\x10\x20\x01(\tR\x05label\x12\x1e\n\npositionId\x18\x11\
    \x20\x01(\x03R\npositionId\x12$\n\rclientOrderId\x18\x12\x20\x01(\tR\rcl\
    ientOrderId\x12*\n\x10relativeStopLoss\x18\x13\x20\x01(\x03R\x10relative\
    StopLoss\x12.\n\x12relativeTakeProfit\x18\x14\x20\x01(\x03R\x12relativeT\
    akeProfit\x12.\n\x12guaranteedStopLoss\x18\x15\x20\x01(\x08R\x12guarante\
    edStopLoss\x12*\n\x10trailingStopLoss\x18\x16\x20\x01(\x08R\x10trailingS\
    topLoss\x12O\n\x11stopTriggerMethod\x18\x17\x20\x01(\x0e2\x1a.ProtoOAOrd\
    erTriggerMethod:\x05TRADER\x11stopTriggerMethod\"\xa5\x04\n\x15ProtoOAEx\
    ecutionEvent\x12O\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayl\
    oadType:\x18PROTO_OA_EXECUTION_EVENTR\x0bpayloadType\x120\n\x13ctidTrade\
    rAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12;\n\rexecutio\
    nType\x18\x03\x20\x02(\x0e2\x15.ProtoOAExecutionTypeR\rexecutionType\x12\
    ,\n\x08position\x18\x04\x20\x01(\x0b2\x10.ProtoOAPositionR\x08position\
    \x12#\n\x05order\x18\x05\x20\x01(\x0b2\r.ProtoOAOrderR\x05order\x12\x20\
    \n\x04deal\x18\x06\x20\x01(\x0b2\x0c.ProtoOADealR\x04deal\x12P\n\x14bonu\
    sDepositWithdraw\x18\x07\x20\x01(\x0b2\x1c.ProtoOABonusDepositWithdrawR\
    \x14bonusDepositWithdraw\x12A\n\x0fdepositWithdraw\x18\x08\x20\x01(\x0b2\
    \x17.ProtoOADepositWithdrawR\x0fdepositWithdraw\x12\x1c\n\terrorCode\x18\
    \t\x20\x01(\tR\terrorCode\x12$\n\risServerEvent\x18\n\x20\x01(\x08R\risS\
    erverEvent\"\xb5\x01\n\x15ProtoOACancelOrderReq\x12P\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x19PROTO_OA_CANCEL_ORDER_\
    REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\
    \x13ctidTraderAccountId\x12\x18\n\x07orderId\x18\x03\x20\x02(\x03R\x07or\
    derId\"\xac\x05\n\x14ProtoOAAmendOrderReq\x12O\n\x0bpayloadType\x18\x01\
    \x20\x01(\x0e2\x13.ProtoOAPayloadType:\x18PROTO_OA_AMEND_ORDER_REQR\x0bp\
    ayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTr\
    aderAccountId\x12\x18\n\x07orderId\x18\x03\x20\x02(\x03R\x07orderId\x12\
    \x16\n\x06volume\x18\x04\x20\x01(\x03R\x06volume\x12\x1e\n\nlimitPrice\
    \x18\x05\x20\x01(\x01R\nlimitPrice\x12\x1c\n\tstopPrice\x18\x06\x20\x01(\
    \x01R\tstopPrice\x120\n\x13expirationTimestamp\x18\x07\x20\x01(\x03R\x13\
    expirationTimestamp\x12\x1a\n\x08stopLoss\x18\x08\x20\x01(\x01R\x08stopL\
    oss\x12\x1e\n\ntakeProfit\x18\t\x20\x01(\x01R\ntakeProfit\x12*\n\x10slip\
    pageInPoints\x18\n\x20\x01(\x05R\x10slippageInPoints\x12*\n\x10relativeS\
    topLoss\x18\x0b\x20\x01(\x03R\x10relativeStopLoss\x12.\n\x12relativeTake\
    Profit\x18\x0c\x20\x01(\x03R\x12relativeTakeProfit\x12.\n\x12guaranteedS\
    topLoss\x18\r\x20\x01(\x08R\x12guaranteedStopLoss\x12*\n\x10trailingStop\
    Loss\x18\x0e\x20\x01(\x08R\x10trailingStopLoss\x12O\n\x11stopTriggerMeth\
    od\x18\x0f\x20\x01(\x0e2\x1a.ProtoOAOrderTriggerMethod:\x05TRADER\x11sto\
    pTriggerMethod\"\xb9\x03\n\x1bProtoOAAmendPositionSLTPReq\x12W\n\x0bpayl\
    oadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x20PROTO_OA_AMEND_\
    POSITION_SLTP_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\
    \x20\x02(\x03R\x13ctidTraderAccountId\x12\x1e\n\npositionId\x18\x03\x20\
    \x02(\x03R\npositionId\x12\x1a\n\x08stopLoss\x18\x04\x20\x01(\x01R\x08st\
    opLoss\x12\x1e\n\ntakeProfit\x18\x05\x20\x01(\x01R\ntakeProfit\x12.\n\
    \x12guaranteedStopLoss\x18\x07\x20\x01(\x08R\x12guaranteedStopLoss\x12*\
    \n\x10trailingStopLoss\x18\x08\x20\x01(\x08R\x10trailingStopLoss\x12W\n\
    \x15stopLossTriggerMethod\x18\t\x20\x01(\x0e2\x1a.ProtoOAOrderTriggerMet\
    hod:\x05TRADER\x15stopLossTriggerMethod\"\xd7\x01\n\x17ProtoOAClosePosit\
    ionReq\x12R\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadTyp\
    e:\x1bPROTO_OA_CLOSE_POSITION_REQR\x0bpayloadType\x120\n\x13ctidTraderAc\
    countId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1e\n\nposition\
    Id\x18\x03\x20\x02(\x03R\npositionId\x12\x16\n\x06volume\x18\x04\x20\x02\
    (\x03R\x06volume\"\xbc\x02\n\x1dProtoOATrailingSLChangedEvent\x12Y\n\x0b\
    payloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\"PROTO_OA_TRAI\
    LING_SL_CHANGED_EVENTR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\
    \x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1e\n\npositionId\x18\x03\
    \x20\x02(\x03R\npositionId\x12\x18\n\x07orderId\x18\x04\x20\x02(\x03R\
    \x07orderId\x12\x1c\n\tstopPrice\x18\x05\x20\x02(\x01R\tstopPrice\x126\n\
    \x16utcLastUpdateTimestamp\x18\x06\x20\x02(\x03R\x16utcLastUpdateTimesta\
    mp\"\x97\x01\n\x13ProtoOAAssetListReq\x12N\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x17PROTO_OA_ASSET_LIST_REQR\x0bpayloa\
    dType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderA\
    ccountId\"\xbc\x01\n\x13ProtoOAAssetListRes\x12N\n\x0bpayloadType\x18\
    \x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x17PROTO_OA_ASSET_LIST_RESR\
    \x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13c\
    tidTraderAccountId\x12#\n\x05asset\x18\x03\x20\x03(\x0b2\r.ProtoOAAssetR\
    \x05asset\"\xda\x01\n\x15ProtoOASymbolsListReq\x12P\n\x0bpayloadType\x18\
    \x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x19PROTO_OA_SYMBOLS_LIST_REQR\
    \x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13c\
    tidTraderAccountId\x12=\n\x16includeArchivedSymbols\x18\x03\x20\x01(\x08\
    :\x05falseR\x16includeArchivedSymbols\"\x88\x02\n\x15ProtoOASymbolsListR\
    es\x12P\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\
    \x19PROTO_OA_SYMBOLS_LIST_RESR\x0bpayloadType\x120\n\x13ctidTraderAccoun\
    tId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12+\n\x06symbol\x18\
    \x03\x20\x03(\x0b2\x13.ProtoOALightSymbolR\x06symbol\x12>\n\x0earchivedS\
    ymbol\x18\x04\x20\x03(\x0b2\x16.ProtoOAArchivedSymbolR\x0earchivedSymbol\
    \"\xb6\x01\n\x14ProtoOASymbolByIdReq\x12P\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x19PROTO_OA_SYMBOL_BY_ID_REQR\x0bpayl\
    oadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTrade\
    rAccountId\x12\x1a\n\x08symbolId\x18\x03\x20\x03(\x03R\x08symbolId\"\x82\
    \x02\n\x14ProtoOASymbolByIdRes\x12P\n\x0bpayloadType\x18\x01\x20\x01(\
    \x0e2\x13.ProtoOAPayloadType:\x19PROTO_OA_SYMBOL_BY_ID_RESR\x0bpayloadTy\
    pe\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAcco\
    untId\x12&\n\x06symbol\x18\x03\x20\x03(\x0b2\x0e.ProtoOASymbolR\x06symbo\
    l\x12>\n\x0earchivedSymbol\x18\x04\x20\x03(\x0b2\x16.ProtoOAArchivedSymb\
    olR\x0earchivedSymbol\"\xf4\x01\n\x1eProtoOASymbolsForConversionReq\x12Z\
    \n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:#PROTO_OA\
    _SYMBOLS_FOR_CONVERSION_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountI\
    d\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\"\n\x0cfirstAssetId\
    \x18\x03\x20\x02(\x03R\x0cfirstAssetId\x12\x20\n\x0blastAssetId\x18\x04\
    \x20\x02(\x03R\x0blastAssetId\"\xdb\x01\n\x1eProtoOASymbolsForConversion\
    Res\x12Z\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:#\
    PROTO_OA_SYMBOLS_FOR_CONVERSION_RESR\x0bpayloadType\x120\n\x13ctidTrader\
    AccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12+\n\x06symbol\
    \x18\x03\x20\x03(\x0b2\x13.ProtoOALightSymbolR\x06symbol\"\xbf\x01\n\x19\
    ProtoOASymbolChangedEvent\x12T\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\
    \x13.ProtoOAPayloadType:\x1dPROTO_OA_SYMBOL_CHANGED_EVENTR\x0bpayloadTyp\
    e\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccou\
    ntId\x12\x1a\n\x08symbolId\x18\x03\x20\x03(\x03R\x08symbolId\"\xa2\x01\n\
    \x18ProtoOAAssetClassListReq\x12T\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\
    \x13.ProtoOAPayloadType:\x1dPROTO_OA_ASSET_CLASS_LIST_REQR\x0bpayloadTyp\
    e\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccou\
    ntId\"\xd6\x01\n\x18ProtoOAAssetClassListRes\x12T\n\x0bpayloadType\x18\
    \x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1dPROTO_OA_ASSET_CLASS_LIST_\
    RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\
    \x13ctidTraderAccountId\x122\n\nassetClass\x18\x03\x20\x03(\x0b2\x12.Pro\
    toOAAssetClassR\nassetClass\"\x90\x01\n\x10ProtoOATraderReq\x12J\n\x0bpa\
    yloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x13PROTO_OA_TRAD\
    ER_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\"\xb8\x01\n\x10ProtoOATraderRes\x12J\n\x0bp\
    ayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x13PROTO_OA_TRA\
    DER_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\x12&\n\x06trader\x18\x03\x20\x02(\x0b2\x0e.\
    ProtoOATraderR\x06trader\"\xca\x01\n\x19ProtoOATraderUpdatedEvent\x12S\n\
    \x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1cPROTO_O\
    A_TRADER_UPDATE_EVENTR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\
    \x02\x20\x02(\x03R\x13ctidTraderAccountId\x12&\n\x06trader\x18\x03\x20\
    \x02(\x0b2\x0e.ProtoOATraderR\x06trader\"\xce\x01\n\x13ProtoOAReconcileR\
    eq\x12M\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\
    \x16PROTO_OA_RECONCILE_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\
    \x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x126\n\x16returnProtection\
    Orders\x18\x03\x20\x01(\x08R\x16returnProtectionOrders\"\xe9\x01\n\x13Pr\
    otoOAReconcileRes\x12M\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoO\
    APayloadType:\x16PROTO_OA_RECONCILE_RESR\x0bpayloadType\x120\n\x13ctidTr\
    aderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12,\n\x08pos\
    ition\x18\x03\x20\x03(\x0b2\x10.ProtoOAPositionR\x08position\x12#\n\x05o\
    rder\x18\x04\x20\x03(\x0b2\r.ProtoOAOrderR\x05order\"\x97\x02\n\x16Proto\
    OAOrderErrorEvent\x12Q\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoO\
    APayloadType:\x1aPROTO_OA_ORDER_ERROR_EVENTR\x0bpayloadType\x120\n\x13ct\
    idTraderAccountId\x18\x05\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1c\n\
    \terrorCode\x18\x02\x20\x02(\tR\terrorCode\x12\x18\n\x07orderId\x18\x03\
    \x20\x01(\x03R\x07orderId\x12\x1e\n\npositionId\x18\x06\x20\x01(\x03R\np\
    ositionId\x12\x20\n\x0bdescription\x18\x07\x20\x01(\tR\x0bdescription\"\
    \xf7\x01\n\x12ProtoOADealListReq\x12M\n\x0bpayloadType\x18\x01\x20\x01(\
    \x0e2\x13.ProtoOAPayloadType:\x16PROTO_OA_DEAL_LIST_REQR\x0bpayloadType\
    \x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccoun\
    tId\x12$\n\rfromTimestamp\x18\x03\x20\x01(\x03R\rfromTimestamp\x12\x20\n\
    \x0btoTimestamp\x18\x04\x20\x01(\x03R\x0btoTimestamp\x12\x18\n\x07maxRow\
    s\x18\x05\x20\x01(\x05R\x07maxRows\"\xd1\x01\n\x12ProtoOADealListRes\x12\
    M\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x16PROT\
    O_OA_DEAL_LIST_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\
    \x20\x02(\x03R\x13ctidTraderAccountId\x12\x20\n\x04deal\x18\x03\x20\x03(\
    \x0b2\x0c.ProtoOADealR\x04deal\x12\x18\n\x07hasMore\x18\x04\x20\x02(\x08\
    R\x07hasMore\"\xdf\x01\n\x13ProtoOAOrderListReq\x12N\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x17PROTO_OA_ORDER_LIST_RE\
    QR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\
    \x13ctidTraderAccountId\x12$\n\rfromTimestamp\x18\x03\x20\x01(\x03R\rfro\
    mTimestamp\x12\x20\n\x0btoTimestamp\x18\x04\x20\x01(\x03R\x0btoTimestamp\
    \"\xd6\x01\n\x13ProtoOAOrderListRes\x12N\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x17PROTO_OA_ORDER_LIST_RESR\x0bpayloa\
    dType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderA\
    ccountId\x12#\n\x05order\x18\x03\x20\x03(\x0b2\r.ProtoOAOrderR\x05order\
    \x12\x18\n\x07hasMore\x18\x04\x20\x02(\x08R\x07hasMore\"\xd5\x01\n\x18Pr\
    otoOAExpectedMarginReq\x12S\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.P\
    rotoOAPayloadType:\x1cPROTO_OA_EXPECTED_MARGIN_REQR\x0bpayloadType\x120\
    \n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\
    \x12\x1a\n\x08symbolId\x18\x03\x20\x02(\x03R\x08symbolId\x12\x16\n\x06vo\
    lume\x18\x04\x20\x03(\x03R\x06volume\"\xf3\x01\n\x18ProtoOAExpectedMargi\
    nRes\x12S\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\
    \x1cPROTO_OA_EXPECTED_MARGIN_RESR\x0bpayloadType\x120\n\x13ctidTraderAcc\
    ountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12.\n\x06margin\x18\
    \x03\x20\x03(\x0b2\x16.ProtoOAExpectedMarginR\x06margin\x12\x20\n\x0bmon\
    eyDigits\x18\x04\x20\x01(\rR\x0bmoneyDigits\"\x85\x02\n\x19ProtoOAMargin\
    ChangedEvent\x12T\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayl\
    oadType:\x1dPROTO_OA_MARGIN_CHANGED_EVENTR\x0bpayloadType\x120\n\x13ctid\
    TraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1e\n\n\
    positionId\x18\x03\x20\x02(\x04R\npositionId\x12\x1e\n\nusedMargin\x18\
    \x04\x20\x02(\x04R\nusedMargin\x12\x20\n\x0bmoneyDigits\x18\x05\x20\x01(\
    \rR\x0bmoneyDigits\"\xf5\x01\n\x1dProtoOACashFlowHistoryListReq\x12Z\n\
    \x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:#PROTO_OA_C\
    ASH_FLOW_HISTORY_LIST_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\
    \x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12$\n\rfromTimestamp\x18\
    \x03\x20\x02(\x03R\rfromTimestamp\x12\x20\n\x0btoTimestamp\x18\x04\x20\
    \x02(\x03R\x0btoTimestamp\"\xf0\x01\n\x1dProtoOACashFlowHistoryListRes\
    \x12Z\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:#PRO\
    TO_OA_CASH_FLOW_HISTORY_LIST_RESR\x0bpayloadType\x120\n\x13ctidTraderAcc\
    ountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12A\n\x0fdepositWit\
    hdraw\x18\x03\x20\x03(\x0b2\x17.ProtoOADepositWithdrawR\x0fdepositWithdr\
    aw\"\xab\x01\n%ProtoOAGetAccountListByAccessTokenReq\x12`\n\x0bpayloadTy\
    pe\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:)PROTO_OA_GET_ACCOUNTS_B\
    Y_ACCESS_TOKEN_REQR\x0bpayloadType\x12\x20\n\x0baccessToken\x18\x02\x20\
    \x02(\tR\x0baccessToken\"\xbd\x02\n%ProtoOAGetAccountListByAccessTokenRe\
    s\x12`\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:)PR\
    OTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RESR\x0bpayloadType\x12\x20\n\x0bacc\
    essToken\x18\x02\x20\x02(\tR\x0baccessToken\x12G\n\x0fpermissionScope\
    \x18\x03\x20\x01(\x0e2\x1d.ProtoOAClientPermissionScopeR\x0fpermissionSc\
    ope\x12G\n\x11ctidTraderAccount\x18\x04\x20\x03(\x0b2\x19.ProtoOACtidTra\
    derAccountR\x11ctidTraderAccount\"\x8f\x01\n\x16ProtoOARefreshTokenReq\
    \x12Q\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1a\
    PROTO_OA_REFRESH_TOKEN_REQR\x0bpayloadType\x12\"\n\x0crefreshToken\x18\
    \x02\x20\x02(\tR\x0crefreshToken\"\xed\x01\n\x16ProtoOARefreshTokenRes\
    \x12Q\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1a\
    PROTO_OA_REFRESH_TOKEN_RESR\x0bpayloadType\x12\x20\n\x0baccessToken\x18\
    \x02\x20\x02(\tR\x0baccessToken\x12\x1c\n\ttokenType\x18\x03\x20\x02(\tR\
    \ttokenType\x12\x1c\n\texpiresIn\x18\x04\x20\x02(\x03R\texpiresIn\x12\"\
    \n\x0crefreshToken\x18\x05\x20\x02(\tR\x0crefreshToken\"\xf9\x01\n\x18Pr\
    otoOASubscribeSpotsReq\x12S\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.P\
    rotoOAPayloadType:\x1cPROTO_OA_SUBSCRIBE_SPOTS_REQR\x0bpayloadType\x120\
    \n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\
    \x12\x1a\n\x08symbolId\x18\x03\x20\x03(\x03R\x08symbolId\x12:\n\x18subsc\
    ribeToSpotTimestamp\x18\x04\x20\x01(\x08R\x18subscribeToSpotTimestamp\"\
    \xa1\x01\n\x18ProtoOASubscribeSpotsRes\x12S\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x1cPROTO_OA_SUBSCRIBE_SPOTS_RESR\x0bp\
    ayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTr\
    aderAccountId\"\xc1\x01\n\x1aProtoOAUnsubscribeSpotsReq\x12U\n\x0bpayloa\
    dType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1ePROTO_OA_UNSUBSCR\
    IBE_SPOTS_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\
    \x02(\x03R\x13ctidTraderAccountId\x12\x1a\n\x08symbolId\x18\x03\x20\x03(\
    \x03R\x08symbolId\"\xa5\x01\n\x1aProtoOAUnsubscribeSpotsRes\x12U\n\x0bpa\
    yloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1ePROTO_OA_UNSU\
    BSCRIBE_SPOTS_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\
    \x20\x02(\x03R\x13ctidTraderAccountId\"\xc0\x02\n\x10ProtoOASpotEvent\
    \x12J\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x13\
    PROTO_OA_SPOT_EVENTR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\
    \x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1a\n\x08symbolId\x18\x03\
    \x20\x02(\x03R\x08symbolId\x12\x10\n\x03bid\x18\x04\x20\x01(\x04R\x03bid\
    \x12\x10\n\x03ask\x18\x05\x20\x01(\x04R\x03ask\x12,\n\x08trendbar\x18\
    \x06\x20\x03(\x0b2\x10.ProtoOATrendbarR\x08trendbar\x12\"\n\x0csessionCl\
    ose\x18\x07\x20\x01(\x04R\x0csessionClose\x12\x1c\n\ttimestamp\x18\x08\
    \x20\x01(\x03R\ttimestamp\"\xfc\x01\n\x1fProtoOASubscribeLiveTrendbarReq\
    \x12[\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:$PRO\
    TO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQR\x0bpayloadType\x120\n\x13ctidTraderAc\
    countId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12.\n\x06period\
    \x18\x03\x20\x02(\x0e2\x16.ProtoOATrendbarPeriodR\x06period\x12\x1a\n\
    \x08symbolId\x18\x04\x20\x02(\x03R\x08symbolId\"\xb0\x01\n\x1fProtoOASub\
    scribeLiveTrendbarRes\x12[\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.Pr\
    otoOAPayloadType:$PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RESR\x0bpayloadType\
    \x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccoun\
    tId\"\x80\x02\n!ProtoOAUnsubscribeLiveTrendbarReq\x12]\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:&PROTO_OA_UNSUBSCRIBE_LIVE\
    _TRENDBAR_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\
    \x02(\x03R\x13ctidTraderAccountId\x12.\n\x06period\x18\x03\x20\x02(\x0e2\
    \x16.ProtoOATrendbarPeriodR\x06period\x12\x1a\n\x08symbolId\x18\x04\x20\
    \x02(\x03R\x08symbolId\"\xb4\x01\n!ProtoOAUnsubscribeLiveTrendbarRes\x12\
    ]\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:&PROTO_O\
    A_UNSUBSCRIBE_LIVE_TRENDBAR_RESR\x0bpayloadType\x120\n\x13ctidTraderAcco\
    untId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\"\xc7\x02\n\x16ProtoO\
    AGetTrendbarsReq\x12Q\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOA\
    PayloadType:\x1aPROTO_OA_GET_TRENDBARS_REQR\x0bpayloadType\x120\n\x13cti\
    dTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12$\n\rfr\
    omTimestamp\x18\x03\x20\x01(\x03R\rfromTimestamp\x12\x20\n\x0btoTimestam\
    p\x18\x04\x20\x01(\x03R\x0btoTimestamp\x12.\n\x06period\x18\x05\x20\x02(\
    \x0e2\x16.ProtoOATrendbarPeriodR\x06period\x12\x1a\n\x08symbolId\x18\x06\
    \x20\x02(\x03R\x08symbolId\x12\x14\n\x05count\x18\x07\x20\x01(\rR\x05cou\
    nt\"\xd3\x02\n\x16ProtoOAGetTrendbarsRes\x12Q\n\x0bpayloadType\x18\x01\
    \x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1aPROTO_OA_GET_TRENDBARS_RESR\
    \x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13c\
    tidTraderAccountId\x12.\n\x06period\x18\x03\x20\x02(\x0e2\x16.ProtoOATre\
    ndbarPeriodR\x06period\x12\x20\n\ttimestamp\x18\x04\x20\x01(\x03R\ttimes\
    tampB\x02\x18\x01\x12,\n\x08trendbar\x18\x05\x20\x03(\x0b2\x10.ProtoOATr\
    endbarR\x08trendbar\x12\x1a\n\x08symbolId\x18\x06\x20\x01(\x03R\x08symbo\
    lId\x12\x18\n\x07hasMore\x18\x07\x20\x01(\x08R\x07hasMore\"\xa6\x02\n\
    \x15ProtoOAGetTickDataReq\x12P\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\
    \x13.ProtoOAPayloadType:\x19PROTO_OA_GET_TICKDATA_REQR\x0bpayloadType\
    \x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccoun\
    tId\x12\x1a\n\x08symbolId\x18\x03\x20\x02(\x03R\x08symbolId\x12%\n\x04ty\
    pe\x18\x04\x20\x02(\x0e2\x11.ProtoOAQuoteTypeR\x04type\x12$\n\rfromTimes\
    tamp\x18\x05\x20\x01(\x03R\rfromTimestamp\x12\x20\n\x0btoTimestamp\x18\
    \x06\x20\x01(\x03R\x0btoTimestamp\"\xe3\x01\n\x15ProtoOAGetTickDataRes\
    \x12P\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x19\
    PROTO_OA_GET_TICKDATA_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\
    \x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12,\n\x08tickData\x18\x03\
    \x20\x03(\x0b2\x10.ProtoOATickDataR\x08tickData\x12\x18\n\x07hasMore\x18\
    \x04\x20\x02(\x08R\x07hasMore\"\xa2\x01\n\x1fProtoOAGetCtidProfileByToke\
    nReq\x12]\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\
    &PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQR\x0bpayloadType\x12\x20\n\x0bacc\
    essToken\x18\x02\x20\x02(\tR\x0baccessToken\"\xaf\x01\n\x1fProtoOAGetCti\
    dProfileByTokenRes\x12]\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.Proto\
    OAPayloadType:&PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RESR\x0bpayloadType\
    \x12-\n\x07profile\x18\x02\x20\x02(\x0b2\x13.ProtoOACtidProfileR\x07prof\
    ile\"\x8a\x02\n\x11ProtoOADepthEvent\x12K\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x14PROTO_OA_DEPTH_EVENTR\x0bpayloadTy\
    pe\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAcco\
    untId\x12\x1a\n\x08symbolId\x18\x03\x20\x02(\x04R\x08symbolId\x120\n\tne\
    wQuotes\x18\x04\x20\x03(\x0b2\x12.ProtoOADepthQuoteR\tnewQuotes\x12(\n\r\
    deletedQuotes\x18\x05\x20\x03(\x04R\rdeletedQuotesB\x02\x10\x01\"\xca\
    \x01\n\x1eProtoOASubscribeDepthQuotesReq\x12Z\n\x0bpayloadType\x18\x01\
    \x20\x01(\x0e2\x13.ProtoOAPayloadType:#PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_R\
    EQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\
    \x13ctidTraderAccountId\x12\x1a\n\x08symbolId\x18\x03\x20\x03(\x03R\x08s\
    ymbolId\"\xae\x01\n\x1eProtoOASubscribeDepthQuotesRes\x12Z\n\x0bpayloadT\
    ype\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:#PROTO_OA_SUBSCRIBE_DEP\
    TH_QUOTES_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\
    \x02(\x03R\x13ctidTraderAccountId\"\xce\x01\n\x20ProtoOAUnsubscribeDepth\
    QuotesReq\x12\\\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloa\
    dType:%PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQR\x0bpayloadType\x120\n\x13c\
    tidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1a\
    \n\x08symbolId\x18\x03\x20\x03(\x03R\x08symbolId\"\xb2\x01\n\x20ProtoOAU\
    nsubscribeDepthQuotesRes\x12\\\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\
    \x13.ProtoOAPayloadType:%PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RESR\x0bpaylo\
    adType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTrader\
    AccountId\"\xa5\x01\n\x1cProtoOASymbolCategoryListReq\x12S\n\x0bpayloadT\
    ype\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1cPROTO_OA_SYMBOL_CAT\
    EGORY_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\"\xe5\x01\n\x1cProtoOASymbolCategoryListRes\
    \x12S\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1c\
    PROTO_OA_SYMBOL_CATEGORY_RESR\x0bpayloadType\x120\n\x13ctidTraderAccount\
    Id\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12>\n\x0esymbolCategory\
    \x18\x03\x20\x03(\x0b2\x16.ProtoOASymbolCategoryR\x0esymbolCategory\"\
    \x9f\x01\n\x17ProtoOAAccountLogoutReq\x12R\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x1bPROTO_OA_ACCOUNT_LOGOUT_REQR\x0bpa\
    yloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTra\
    derAccountId\"\x9f\x01\n\x17ProtoOAAccountLogoutRes\x12R\n\x0bpayloadTyp\
    e\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1bPROTO_OA_ACCOUNT_LOGO\
    UT_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\"\xab\x01\n\x1dProtoOAAccountDisconnectEven\
    t\x12X\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:!PR\
    OTO_OA_ACCOUNT_DISCONNECT_EVENTR\x0bpayloadType\x120\n\x13ctidTraderAcco\
    untId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\"\xa2\x01\n\x18ProtoO\
    AMarginCallListReq\x12T\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.Proto\
    OAPayloadType:\x1dPROTO_OA_MARGIN_CALL_LIST_REQR\x0bpayloadType\x120\n\
    \x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\"\
    \xa4\x01\n\x18ProtoOAMarginCallListRes\x12T\n\x0bpayloadType\x18\x01\x20\
    \x01(\x0e2\x13.ProtoOAPayloadType:\x1dPROTO_OA_MARGIN_CALL_LIST_RESR\x0b\
    payloadType\x122\n\nmarginCall\x18\x02\x20\x03(\x0b2\x12.ProtoOAMarginCa\
    llR\nmarginCall\"\xda\x01\n\x1aProtoOAMarginCallUpdateReq\x12V\n\x0bpayl\
    oadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1fPROTO_OA_MARGIN\
    _CALL_UPDATE_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\
    \x20\x02(\x03R\x13ctidTraderAccountId\x122\n\nmarginCall\x18\x03\x20\x02\
    (\x0b2\x12.ProtoOAMarginCallR\nmarginCall\"t\n\x1aProtoOAMarginCallUpdat\
    eRes\x12V\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\
    \x1fPROTO_OA_MARGIN_CALL_UPDATE_RESR\x0bpayloadType\"\xde\x01\n\x1cProto\
    OAMarginCallUpdateEvent\x12X\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.\
    ProtoOAPayloadType:!PROTO_OA_MARGIN_CALL_UPDATE_EVENTR\x0bpayloadType\
    \x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccoun\
    tId\x122\n\nmarginCall\x18\x03\x20\x02(\x0b2\x12.ProtoOAMarginCallR\nmar\
    ginCall\"\xe0\x01\n\x1dProtoOAMarginCallTriggerEvent\x12Y\n\x0bpayloadTy\
    pe\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\"PROTO_OA_MARGIN_CALL_T\
    RIGGER_EVENTR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\
    \x02(\x03R\x13ctidTraderAccountId\x122\n\nmarginCall\x18\x03\x20\x02(\
    \x0b2\x12.ProtoOAMarginCallR\nmarginCall\"\xce\x01\n\x20ProtoOAGetDynami\
    cLeverageByIDReq\x12X\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOA\
    PayloadType:!PROTO_OA_GET_DYNAMIC_LEVERAGE_REQR\x0bpayloadType\x120\n\
    \x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\
    \x1e\n\nleverageId\x18\x03\x20\x02(\x03R\nleverageId\"\xe3\x01\n\x20Prot\
    oOAGetDynamicLeverageByIDRes\x12X\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\
    \x13.ProtoOAPayloadType:!PROTO_OA_GET_DYNAMIC_LEVERAGE_RESR\x0bpayloadTy\
    pe\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAcco\
    untId\x123\n\x08leverage\x18\x03\x20\x02(\x0b2\x17.ProtoOADynamicLeverag\
    eR\x08leverage\"\x98\x02\n\x1eProtoOADealListByPositionIdReq\x12\\\n\x0b\
    payloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:%PROTO_OA_DEAL_\
    LIST_BY_POSITION_ID_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\
    \x18\x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x1e\n\npositionId\x18\
    \x03\x20\x02(\x03R\npositionId\x12$\n\rfromTimestamp\x18\x04\x20\x01(\
    \x03R\rfromTimestamp\x12\x20\n\x0btoTimestamp\x18\x05\x20\x01(\x03R\x0bt\
    oTimestamp\"\xec\x01\n\x1eProtoOADealListByPositionIdRes\x12\\\n\x0bpayl\
    oadType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:%PROTO_OA_DEAL_LIST\
    _BY_POSITION_ID_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\
    \x02\x20\x02(\x03R\x13ctidTraderAccountId\x12\x20\n\x04deal\x18\x03\x20\
    \x03(\x0b2\x0c.ProtoOADealR\x04deal\x12\x18\n\x07hasMore\x18\x04\x20\x02\
    (\x08R\x07hasMore\"\xb7\x01\n\x16ProtoOAOrderDetailsReq\x12Q\n\x0bpayloa\
    dType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1aPROTO_OA_ORDER_DE\
    TAILS_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\x12\x18\n\x07orderId\x18\x03\x20\x02(\x03R\
    \x07orderId\"\xe4\x01\n\x16ProtoOAOrderDetailsRes\x12Q\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1aPROTO_OA_ORDER_DETAILS\
    _RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\
    \x13ctidTraderAccountId\x12#\n\x05order\x18\x03\x20\x02(\x0b2\r.ProtoOAO\
    rderR\x05order\x12\x20\n\x04deal\x18\x04\x20\x03(\x0b2\x0c.ProtoOADealR\
    \x04deal\"\x9a\x02\n\x1fProtoOAOrderListByPositionIdReq\x12]\n\x0bpayloa\
    dType\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:&PROTO_OA_ORDER_LIST_\
    BY_POSITION_ID_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\
    \x20\x02(\x03R\x13ctidTraderAccountId\x12\x1e\n\npositionId\x18\x03\x20\
    \x02(\x03R\npositionId\x12$\n\rfromTimestamp\x18\x04\x20\x01(\x03R\rfrom\
    Timestamp\x12\x20\n\x0btoTimestamp\x18\x05\x20\x01(\x03R\x0btoTimestamp\
    \"\xf1\x01\n\x1fProtoOAOrderListByPositionIdRes\x12]\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:&PROTO_OA_ORDER_LIST_BY_PO\
    SITION_ID_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\
    \x02(\x03R\x13ctidTraderAccountId\x12#\n\x05order\x18\x03\x20\x03(\x0b2\
    \r.ProtoOAOrderR\x05order\x12\x18\n\x07hasMore\x18\x04\x20\x02(\x08R\x07\
    hasMore\"\xba\x01\n\x18ProtoOADealOffsetListReq\x12T\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1dPROTO_OA_DEAL_OFFSET_L\
    IST_REQR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\x12\x16\n\x06dealId\x18\x03\x20\x02(\x03R\
    \x06dealId\"\x86\x02\n\x18ProtoOADealOffsetListRes\x12T\n\x0bpayloadType\
    \x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:\x1dPROTO_OA_DEAL_OFFSET_L\
    IST_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\
    \x03R\x13ctidTraderAccountId\x12.\n\x08offsetBy\x18\x03\x20\x03(\x0b2\
    \x12.ProtoOADealOffsetR\x08offsetBy\x122\n\noffsetting\x18\x04\x20\x03(\
    \x0b2\x12.ProtoOADealOffsetR\noffsetting\"\xb7\x01\n\"ProtoOAGetPosition\
    UnrealizedPnLReq\x12_\n\x0bpayloadType\x18\x01\x20\x01(\x0e2\x13.ProtoOA\
    PayloadType:(PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQR\x0bpayloadType\
    \x120\n\x13ctidTraderAccountId\x18\x02\x20\x02(\x03R\x13ctidTraderAccoun\
    tId\"\xae\x02\n\"ProtoOAGetPositionUnrealizedPnLRes\x12_\n\x0bpayloadTyp\
    e\x18\x01\x20\x01(\x0e2\x13.ProtoOAPayloadType:(PROTO_OA_GET_POSITION_UN\
    REALIZED_PNL_RESR\x0bpayloadType\x120\n\x13ctidTraderAccountId\x18\x02\
    \x20\x02(\x03R\x13ctidTraderAccountId\x12S\n\x15positionUnrealizedPnL\
    \x18\x03\x20\x03(\x0b2\x1d.ProtoOAPositionUnrealizedPnLR\x15positionUnre\
    alizedPnL\x12\x20\n\x0bmoneyDigits\x18\x04\x20\x02(\rR\x0bmoneyDigitsBL\
    \n\x1fcom.xtrader.protocol.openapi.v2B\x1aContainerOpenApiV2MessagesP\
    \x01\xa0\x01\x01Z\x08/openapi\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::OpenApiModelMessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(89);
            messages.push(ProtoOAApplicationAuthReq::generated_message_descriptor_data());
            messages.push(ProtoOAApplicationAuthRes::generated_message_descriptor_data());
            messages.push(ProtoOAAccountAuthReq::generated_message_descriptor_data());
            messages.push(ProtoOAAccountAuthRes::generated_message_descriptor_data());
            messages.push(ProtoOAErrorRes::generated_message_descriptor_data());
            messages.push(ProtoOAClientDisconnectEvent::generated_message_descriptor_data());
            messages.push(ProtoOAAccountsTokenInvalidatedEvent::generated_message_descriptor_data());
            messages.push(ProtoOAVersionReq::generated_message_descriptor_data());
            messages.push(ProtoOAVersionRes::generated_message_descriptor_data());
            messages.push(ProtoOANewOrderReq::generated_message_descriptor_data());
            messages.push(ProtoOAExecutionEvent::generated_message_descriptor_data());
            messages.push(ProtoOACancelOrderReq::generated_message_descriptor_data());
            messages.push(ProtoOAAmendOrderReq::generated_message_descriptor_data());
            messages.push(ProtoOAAmendPositionSLTPReq::generated_message_descriptor_data());
            messages.push(ProtoOAClosePositionReq::generated_message_descriptor_data());
            messages.push(ProtoOATrailingSLChangedEvent::generated_message_descriptor_data());
            messages.push(ProtoOAAssetListReq::generated_message_descriptor_data());
            messages.push(ProtoOAAssetListRes::generated_message_descriptor_data());
            messages.push(ProtoOASymbolsListReq::generated_message_descriptor_data());
            messages.push(ProtoOASymbolsListRes::generated_message_descriptor_data());
            messages.push(ProtoOASymbolByIdReq::generated_message_descriptor_data());
            messages.push(ProtoOASymbolByIdRes::generated_message_descriptor_data());
            messages.push(ProtoOASymbolsForConversionReq::generated_message_descriptor_data());
            messages.push(ProtoOASymbolsForConversionRes::generated_message_descriptor_data());
            messages.push(ProtoOASymbolChangedEvent::generated_message_descriptor_data());
            messages.push(ProtoOAAssetClassListReq::generated_message_descriptor_data());
            messages.push(ProtoOAAssetClassListRes::generated_message_descriptor_data());
            messages.push(ProtoOATraderReq::generated_message_descriptor_data());
            messages.push(ProtoOATraderRes::generated_message_descriptor_data());
            messages.push(ProtoOATraderUpdatedEvent::generated_message_descriptor_data());
            messages.push(ProtoOAReconcileReq::generated_message_descriptor_data());
            messages.push(ProtoOAReconcileRes::generated_message_descriptor_data());
            messages.push(ProtoOAOrderErrorEvent::generated_message_descriptor_data());
            messages.push(ProtoOADealListReq::generated_message_descriptor_data());
            messages.push(ProtoOADealListRes::generated_message_descriptor_data());
            messages.push(ProtoOAOrderListReq::generated_message_descriptor_data());
            messages.push(ProtoOAOrderListRes::generated_message_descriptor_data());
            messages.push(ProtoOAExpectedMarginReq::generated_message_descriptor_data());
            messages.push(ProtoOAExpectedMarginRes::generated_message_descriptor_data());
            messages.push(ProtoOAMarginChangedEvent::generated_message_descriptor_data());
            messages.push(ProtoOACashFlowHistoryListReq::generated_message_descriptor_data());
            messages.push(ProtoOACashFlowHistoryListRes::generated_message_descriptor_data());
            messages.push(ProtoOAGetAccountListByAccessTokenReq::generated_message_descriptor_data());
            messages.push(ProtoOAGetAccountListByAccessTokenRes::generated_message_descriptor_data());
            messages.push(ProtoOARefreshTokenReq::generated_message_descriptor_data());
            messages.push(ProtoOARefreshTokenRes::generated_message_descriptor_data());
            messages.push(ProtoOASubscribeSpotsReq::generated_message_descriptor_data());
            messages.push(ProtoOASubscribeSpotsRes::generated_message_descriptor_data());
            messages.push(ProtoOAUnsubscribeSpotsReq::generated_message_descriptor_data());
            messages.push(ProtoOAUnsubscribeSpotsRes::generated_message_descriptor_data());
            messages.push(ProtoOASpotEvent::generated_message_descriptor_data());
            messages.push(ProtoOASubscribeLiveTrendbarReq::generated_message_descriptor_data());
            messages.push(ProtoOASubscribeLiveTrendbarRes::generated_message_descriptor_data());
            messages.push(ProtoOAUnsubscribeLiveTrendbarReq::generated_message_descriptor_data());
            messages.push(ProtoOAUnsubscribeLiveTrendbarRes::generated_message_descriptor_data());
            messages.push(ProtoOAGetTrendbarsReq::generated_message_descriptor_data());
            messages.push(ProtoOAGetTrendbarsRes::generated_message_descriptor_data());
            messages.push(ProtoOAGetTickDataReq::generated_message_descriptor_data());
            messages.push(ProtoOAGetTickDataRes::generated_message_descriptor_data());
            messages.push(ProtoOAGetCtidProfileByTokenReq::generated_message_descriptor_data());
            messages.push(ProtoOAGetCtidProfileByTokenRes::generated_message_descriptor_data());
            messages.push(ProtoOADepthEvent::generated_message_descriptor_data());
            messages.push(ProtoOASubscribeDepthQuotesReq::generated_message_descriptor_data());
            messages.push(ProtoOASubscribeDepthQuotesRes::generated_message_descriptor_data());
            messages.push(ProtoOAUnsubscribeDepthQuotesReq::generated_message_descriptor_data());
            messages.push(ProtoOAUnsubscribeDepthQuotesRes::generated_message_descriptor_data());
            messages.push(ProtoOASymbolCategoryListReq::generated_message_descriptor_data());
            messages.push(ProtoOASymbolCategoryListRes::generated_message_descriptor_data());
            messages.push(ProtoOAAccountLogoutReq::generated_message_descriptor_data());
            messages.push(ProtoOAAccountLogoutRes::generated_message_descriptor_data());
            messages.push(ProtoOAAccountDisconnectEvent::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCallListReq::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCallListRes::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCallUpdateReq::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCallUpdateRes::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCallUpdateEvent::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCallTriggerEvent::generated_message_descriptor_data());
            messages.push(ProtoOAGetDynamicLeverageByIDReq::generated_message_descriptor_data());
            messages.push(ProtoOAGetDynamicLeverageByIDRes::generated_message_descriptor_data());
            messages.push(ProtoOADealListByPositionIdReq::generated_message_descriptor_data());
            messages.push(ProtoOADealListByPositionIdRes::generated_message_descriptor_data());
            messages.push(ProtoOAOrderDetailsReq::generated_message_descriptor_data());
            messages.push(ProtoOAOrderDetailsRes::generated_message_descriptor_data());
            messages.push(ProtoOAOrderListByPositionIdReq::generated_message_descriptor_data());
            messages.push(ProtoOAOrderListByPositionIdRes::generated_message_descriptor_data());
            messages.push(ProtoOADealOffsetListReq::generated_message_descriptor_data());
            messages.push(ProtoOADealOffsetListRes::generated_message_descriptor_data());
            messages.push(ProtoOAGetPositionUnrealizedPnLReq::generated_message_descriptor_data());
            messages.push(ProtoOAGetPositionUnrealizedPnLRes::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
