// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 33.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `OpenApiModelMessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:ProtoOAAsset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAsset {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAsset.assetId)
    pub assetId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAsset.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAAsset.displayName)
    pub displayName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAAsset.digits)
    pub digits: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAsset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAsset {
    fn default() -> &'a ProtoOAAsset {
        <ProtoOAAsset as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAsset {
    pub fn new() -> ProtoOAAsset {
        ::std::default::Default::default()
    }

    // required int64 assetId = 1;

    pub fn assetId(&self) -> i64 {
        self.assetId.unwrap_or(0)
    }

    pub fn clear_assetId(&mut self) {
        self.assetId = ::std::option::Option::None;
    }

    pub fn has_assetId(&self) -> bool {
        self.assetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assetId(&mut self, v: i64) {
        self.assetId = ::std::option::Option::Some(v);
    }

    // required string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string displayName = 3;

    pub fn displayName(&self) -> &str {
        match self.displayName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_displayName(&mut self) {
        self.displayName = ::std::option::Option::None;
    }

    pub fn has_displayName(&self) -> bool {
        self.displayName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displayName(&mut self, v: ::std::string::String) {
        self.displayName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_displayName(&mut self) -> &mut ::std::string::String {
        if self.displayName.is_none() {
            self.displayName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.displayName.as_mut().unwrap()
    }

    // Take field
    pub fn take_displayName(&mut self) -> ::std::string::String {
        self.displayName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 digits = 4;

    pub fn digits(&self) -> i32 {
        self.digits.unwrap_or(0)
    }

    pub fn clear_digits(&mut self) {
        self.digits = ::std::option::Option::None;
    }

    pub fn has_digits(&self) -> bool {
        self.digits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digits(&mut self, v: i32) {
        self.digits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assetId",
            |m: &ProtoOAAsset| { &m.assetId },
            |m: &mut ProtoOAAsset| { &mut m.assetId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ProtoOAAsset| { &m.name },
            |m: &mut ProtoOAAsset| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "displayName",
            |m: &ProtoOAAsset| { &m.displayName },
            |m: &mut ProtoOAAsset| { &mut m.displayName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digits",
            |m: &ProtoOAAsset| { &m.digits },
            |m: &mut ProtoOAAsset| { &mut m.digits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAsset>(
            "ProtoOAAsset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAsset {
    const NAME: &'static str = "ProtoOAAsset";

    fn is_initialized(&self) -> bool {
        if self.assetId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.assetId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.displayName = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.digits = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.assetId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.displayName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.digits {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.assetId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.displayName.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.digits {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAsset {
        ProtoOAAsset::new()
    }

    fn clear(&mut self) {
        self.assetId = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.displayName = ::std::option::Option::None;
        self.digits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAsset {
        static instance: ProtoOAAsset = ProtoOAAsset {
            assetId: ::std::option::Option::None,
            name: ::std::option::Option::None,
            displayName: ::std::option::Option::None,
            digits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAsset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAsset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAsset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAsset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbol)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbol {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbol.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.digits)
    pub digits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.pipPosition)
    pub pipPosition: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.enableShortSelling)
    pub enableShortSelling: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOASymbol.guaranteedStopLoss)
    pub guaranteedStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOASymbol.swapRollover3Days)
    pub swapRollover3Days: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOADayOfWeek>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.swapLong)
    pub swapLong: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.swapShort)
    pub swapShort: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.maxVolume)
    pub maxVolume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.minVolume)
    pub minVolume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.stepVolume)
    pub stepVolume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.maxExposure)
    pub maxExposure: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.schedule)
    pub schedule: ::std::vec::Vec<ProtoOAInterval>,
    // @@protoc_insertion_point(field:ProtoOASymbol.commission)
    pub commission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.commissionType)
    pub commissionType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOACommissionType>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.slDistance)
    pub slDistance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.tpDistance)
    pub tpDistance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.gslDistance)
    pub gslDistance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.gslCharge)
    pub gslCharge: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.distanceSetIn)
    pub distanceSetIn: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOASymbolDistanceType>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.minCommission)
    pub minCommission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.minCommissionType)
    pub minCommissionType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAMinCommissionType>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.minCommissionAsset)
    pub minCommissionAsset: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOASymbol.rolloverCommission)
    pub rolloverCommission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.skipRolloverDays)
    pub skipRolloverDays: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.scheduleTimeZone)
    pub scheduleTimeZone: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOASymbol.tradingMode)
    pub tradingMode: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOATradingMode>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.rolloverCommission3Days)
    pub rolloverCommission3Days: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOADayOfWeek>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.swapCalculationType)
    pub swapCalculationType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOASwapCalculationType>>,
    // @@protoc_insertion_point(field:ProtoOASymbol.lotSize)
    pub lotSize: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.preciseTradingCommissionRate)
    pub preciseTradingCommissionRate: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.preciseMinCommission)
    pub preciseMinCommission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.holiday)
    pub holiday: ::std::vec::Vec<ProtoOAHoliday>,
    // @@protoc_insertion_point(field:ProtoOASymbol.pnlConversionFeeRate)
    pub pnlConversionFeeRate: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.leverageId)
    pub leverageId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbol.swapPeriod)
    pub swapPeriod: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.swapTime)
    pub swapTime: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.skipSWAPPeriods)
    pub skipSWAPPeriods: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOASymbol.chargeSwapAtWeekends)
    pub chargeSwapAtWeekends: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOASymbol.measurementUnits)
    pub measurementUnits: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbol.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbol {
    fn default() -> &'a ProtoOASymbol {
        <ProtoOASymbol as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbol {
    pub fn new() -> ProtoOASymbol {
        ::std::default::Default::default()
    }

    // required int64 symbolId = 1;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // required int32 digits = 2;

    pub fn digits(&self) -> i32 {
        self.digits.unwrap_or(0)
    }

    pub fn clear_digits(&mut self) {
        self.digits = ::std::option::Option::None;
    }

    pub fn has_digits(&self) -> bool {
        self.digits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_digits(&mut self, v: i32) {
        self.digits = ::std::option::Option::Some(v);
    }

    // required int32 pipPosition = 3;

    pub fn pipPosition(&self) -> i32 {
        self.pipPosition.unwrap_or(0)
    }

    pub fn clear_pipPosition(&mut self) {
        self.pipPosition = ::std::option::Option::None;
    }

    pub fn has_pipPosition(&self) -> bool {
        self.pipPosition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pipPosition(&mut self, v: i32) {
        self.pipPosition = ::std::option::Option::Some(v);
    }

    // optional bool enableShortSelling = 4;

    pub fn enableShortSelling(&self) -> bool {
        self.enableShortSelling.unwrap_or(false)
    }

    pub fn clear_enableShortSelling(&mut self) {
        self.enableShortSelling = ::std::option::Option::None;
    }

    pub fn has_enableShortSelling(&self) -> bool {
        self.enableShortSelling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enableShortSelling(&mut self, v: bool) {
        self.enableShortSelling = ::std::option::Option::Some(v);
    }

    // optional bool guaranteedStopLoss = 5;

    pub fn guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.unwrap_or(false)
    }

    pub fn clear_guaranteedStopLoss(&mut self) {
        self.guaranteedStopLoss = ::std::option::Option::None;
    }

    pub fn has_guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guaranteedStopLoss(&mut self, v: bool) {
        self.guaranteedStopLoss = ::std::option::Option::Some(v);
    }

    // optional .ProtoOADayOfWeek swapRollover3Days = 6;

    pub fn swapRollover3Days(&self) -> ProtoOADayOfWeek {
        match self.swapRollover3Days {
            Some(e) => e.enum_value_or(ProtoOADayOfWeek::MONDAY),
            None => ProtoOADayOfWeek::MONDAY,
        }
    }

    pub fn clear_swapRollover3Days(&mut self) {
        self.swapRollover3Days = ::std::option::Option::None;
    }

    pub fn has_swapRollover3Days(&self) -> bool {
        self.swapRollover3Days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapRollover3Days(&mut self, v: ProtoOADayOfWeek) {
        self.swapRollover3Days = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional double swapLong = 7;

    pub fn swapLong(&self) -> f64 {
        self.swapLong.unwrap_or(0.)
    }

    pub fn clear_swapLong(&mut self) {
        self.swapLong = ::std::option::Option::None;
    }

    pub fn has_swapLong(&self) -> bool {
        self.swapLong.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapLong(&mut self, v: f64) {
        self.swapLong = ::std::option::Option::Some(v);
    }

    // optional double swapShort = 8;

    pub fn swapShort(&self) -> f64 {
        self.swapShort.unwrap_or(0.)
    }

    pub fn clear_swapShort(&mut self) {
        self.swapShort = ::std::option::Option::None;
    }

    pub fn has_swapShort(&self) -> bool {
        self.swapShort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapShort(&mut self, v: f64) {
        self.swapShort = ::std::option::Option::Some(v);
    }

    // optional int64 maxVolume = 9;

    pub fn maxVolume(&self) -> i64 {
        self.maxVolume.unwrap_or(0)
    }

    pub fn clear_maxVolume(&mut self) {
        self.maxVolume = ::std::option::Option::None;
    }

    pub fn has_maxVolume(&self) -> bool {
        self.maxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxVolume(&mut self, v: i64) {
        self.maxVolume = ::std::option::Option::Some(v);
    }

    // optional int64 minVolume = 10;

    pub fn minVolume(&self) -> i64 {
        self.minVolume.unwrap_or(0)
    }

    pub fn clear_minVolume(&mut self) {
        self.minVolume = ::std::option::Option::None;
    }

    pub fn has_minVolume(&self) -> bool {
        self.minVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minVolume(&mut self, v: i64) {
        self.minVolume = ::std::option::Option::Some(v);
    }

    // optional int64 stepVolume = 11;

    pub fn stepVolume(&self) -> i64 {
        self.stepVolume.unwrap_or(0)
    }

    pub fn clear_stepVolume(&mut self) {
        self.stepVolume = ::std::option::Option::None;
    }

    pub fn has_stepVolume(&self) -> bool {
        self.stepVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stepVolume(&mut self, v: i64) {
        self.stepVolume = ::std::option::Option::Some(v);
    }

    // optional uint64 maxExposure = 12;

    pub fn maxExposure(&self) -> u64 {
        self.maxExposure.unwrap_or(0)
    }

    pub fn clear_maxExposure(&mut self) {
        self.maxExposure = ::std::option::Option::None;
    }

    pub fn has_maxExposure(&self) -> bool {
        self.maxExposure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxExposure(&mut self, v: u64) {
        self.maxExposure = ::std::option::Option::Some(v);
    }

    // optional int64 commission = 14;

    pub fn commission(&self) -> i64 {
        self.commission.unwrap_or(0)
    }

    pub fn clear_commission(&mut self) {
        self.commission = ::std::option::Option::None;
    }

    pub fn has_commission(&self) -> bool {
        self.commission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commission(&mut self, v: i64) {
        self.commission = ::std::option::Option::Some(v);
    }

    // optional .ProtoOACommissionType commissionType = 15;

    pub fn commissionType(&self) -> ProtoOACommissionType {
        match self.commissionType {
            Some(e) => e.enum_value_or(ProtoOACommissionType::USD_PER_MILLION_USD),
            None => ProtoOACommissionType::USD_PER_MILLION_USD,
        }
    }

    pub fn clear_commissionType(&mut self) {
        self.commissionType = ::std::option::Option::None;
    }

    pub fn has_commissionType(&self) -> bool {
        self.commissionType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commissionType(&mut self, v: ProtoOACommissionType) {
        self.commissionType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 slDistance = 16;

    pub fn slDistance(&self) -> u32 {
        self.slDistance.unwrap_or(0)
    }

    pub fn clear_slDistance(&mut self) {
        self.slDistance = ::std::option::Option::None;
    }

    pub fn has_slDistance(&self) -> bool {
        self.slDistance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slDistance(&mut self, v: u32) {
        self.slDistance = ::std::option::Option::Some(v);
    }

    // optional uint32 tpDistance = 17;

    pub fn tpDistance(&self) -> u32 {
        self.tpDistance.unwrap_or(0)
    }

    pub fn clear_tpDistance(&mut self) {
        self.tpDistance = ::std::option::Option::None;
    }

    pub fn has_tpDistance(&self) -> bool {
        self.tpDistance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tpDistance(&mut self, v: u32) {
        self.tpDistance = ::std::option::Option::Some(v);
    }

    // optional uint32 gslDistance = 18;

    pub fn gslDistance(&self) -> u32 {
        self.gslDistance.unwrap_or(0)
    }

    pub fn clear_gslDistance(&mut self) {
        self.gslDistance = ::std::option::Option::None;
    }

    pub fn has_gslDistance(&self) -> bool {
        self.gslDistance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gslDistance(&mut self, v: u32) {
        self.gslDistance = ::std::option::Option::Some(v);
    }

    // optional int64 gslCharge = 19;

    pub fn gslCharge(&self) -> i64 {
        self.gslCharge.unwrap_or(0)
    }

    pub fn clear_gslCharge(&mut self) {
        self.gslCharge = ::std::option::Option::None;
    }

    pub fn has_gslCharge(&self) -> bool {
        self.gslCharge.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gslCharge(&mut self, v: i64) {
        self.gslCharge = ::std::option::Option::Some(v);
    }

    // optional .ProtoOASymbolDistanceType distanceSetIn = 20;

    pub fn distanceSetIn(&self) -> ProtoOASymbolDistanceType {
        match self.distanceSetIn {
            Some(e) => e.enum_value_or(ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS),
            None => ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS,
        }
    }

    pub fn clear_distanceSetIn(&mut self) {
        self.distanceSetIn = ::std::option::Option::None;
    }

    pub fn has_distanceSetIn(&self) -> bool {
        self.distanceSetIn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distanceSetIn(&mut self, v: ProtoOASymbolDistanceType) {
        self.distanceSetIn = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 minCommission = 21;

    pub fn minCommission(&self) -> i64 {
        self.minCommission.unwrap_or(0)
    }

    pub fn clear_minCommission(&mut self) {
        self.minCommission = ::std::option::Option::None;
    }

    pub fn has_minCommission(&self) -> bool {
        self.minCommission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minCommission(&mut self, v: i64) {
        self.minCommission = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAMinCommissionType minCommissionType = 22;

    pub fn minCommissionType(&self) -> ProtoOAMinCommissionType {
        match self.minCommissionType {
            Some(e) => e.enum_value_or(ProtoOAMinCommissionType::CURRENCY),
            None => ProtoOAMinCommissionType::CURRENCY,
        }
    }

    pub fn clear_minCommissionType(&mut self) {
        self.minCommissionType = ::std::option::Option::None;
    }

    pub fn has_minCommissionType(&self) -> bool {
        self.minCommissionType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minCommissionType(&mut self, v: ProtoOAMinCommissionType) {
        self.minCommissionType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string minCommissionAsset = 23;

    pub fn minCommissionAsset(&self) -> &str {
        match self.minCommissionAsset.as_ref() {
            Some(v) => v,
            None => "USD",
        }
    }

    pub fn clear_minCommissionAsset(&mut self) {
        self.minCommissionAsset = ::std::option::Option::None;
    }

    pub fn has_minCommissionAsset(&self) -> bool {
        self.minCommissionAsset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minCommissionAsset(&mut self, v: ::std::string::String) {
        self.minCommissionAsset = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_minCommissionAsset(&mut self) -> &mut ::std::string::String {
        if self.minCommissionAsset.is_none() {
            self.minCommissionAsset = ::std::option::Option::Some(::std::string::String::new());
        }
        self.minCommissionAsset.as_mut().unwrap()
    }

    // Take field
    pub fn take_minCommissionAsset(&mut self) -> ::std::string::String {
        self.minCommissionAsset.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 rolloverCommission = 24;

    pub fn rolloverCommission(&self) -> i64 {
        self.rolloverCommission.unwrap_or(0)
    }

    pub fn clear_rolloverCommission(&mut self) {
        self.rolloverCommission = ::std::option::Option::None;
    }

    pub fn has_rolloverCommission(&self) -> bool {
        self.rolloverCommission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rolloverCommission(&mut self, v: i64) {
        self.rolloverCommission = ::std::option::Option::Some(v);
    }

    // optional int32 skipRolloverDays = 25;

    pub fn skipRolloverDays(&self) -> i32 {
        self.skipRolloverDays.unwrap_or(0)
    }

    pub fn clear_skipRolloverDays(&mut self) {
        self.skipRolloverDays = ::std::option::Option::None;
    }

    pub fn has_skipRolloverDays(&self) -> bool {
        self.skipRolloverDays.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipRolloverDays(&mut self, v: i32) {
        self.skipRolloverDays = ::std::option::Option::Some(v);
    }

    // optional string scheduleTimeZone = 26;

    pub fn scheduleTimeZone(&self) -> &str {
        match self.scheduleTimeZone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scheduleTimeZone(&mut self) {
        self.scheduleTimeZone = ::std::option::Option::None;
    }

    pub fn has_scheduleTimeZone(&self) -> bool {
        self.scheduleTimeZone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduleTimeZone(&mut self, v: ::std::string::String) {
        self.scheduleTimeZone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduleTimeZone(&mut self) -> &mut ::std::string::String {
        if self.scheduleTimeZone.is_none() {
            self.scheduleTimeZone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scheduleTimeZone.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduleTimeZone(&mut self) -> ::std::string::String {
        self.scheduleTimeZone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ProtoOATradingMode tradingMode = 27;

    pub fn tradingMode(&self) -> ProtoOATradingMode {
        match self.tradingMode {
            Some(e) => e.enum_value_or(ProtoOATradingMode::ENABLED),
            None => ProtoOATradingMode::ENABLED,
        }
    }

    pub fn clear_tradingMode(&mut self) {
        self.tradingMode = ::std::option::Option::None;
    }

    pub fn has_tradingMode(&self) -> bool {
        self.tradingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tradingMode(&mut self, v: ProtoOATradingMode) {
        self.tradingMode = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ProtoOADayOfWeek rolloverCommission3Days = 28;

    pub fn rolloverCommission3Days(&self) -> ProtoOADayOfWeek {
        match self.rolloverCommission3Days {
            Some(e) => e.enum_value_or(ProtoOADayOfWeek::MONDAY),
            None => ProtoOADayOfWeek::MONDAY,
        }
    }

    pub fn clear_rolloverCommission3Days(&mut self) {
        self.rolloverCommission3Days = ::std::option::Option::None;
    }

    pub fn has_rolloverCommission3Days(&self) -> bool {
        self.rolloverCommission3Days.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rolloverCommission3Days(&mut self, v: ProtoOADayOfWeek) {
        self.rolloverCommission3Days = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ProtoOASwapCalculationType swapCalculationType = 29;

    pub fn swapCalculationType(&self) -> ProtoOASwapCalculationType {
        match self.swapCalculationType {
            Some(e) => e.enum_value_or(ProtoOASwapCalculationType::PIPS),
            None => ProtoOASwapCalculationType::PIPS,
        }
    }

    pub fn clear_swapCalculationType(&mut self) {
        self.swapCalculationType = ::std::option::Option::None;
    }

    pub fn has_swapCalculationType(&self) -> bool {
        self.swapCalculationType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapCalculationType(&mut self, v: ProtoOASwapCalculationType) {
        self.swapCalculationType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 lotSize = 30;

    pub fn lotSize(&self) -> i64 {
        self.lotSize.unwrap_or(0)
    }

    pub fn clear_lotSize(&mut self) {
        self.lotSize = ::std::option::Option::None;
    }

    pub fn has_lotSize(&self) -> bool {
        self.lotSize.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lotSize(&mut self, v: i64) {
        self.lotSize = ::std::option::Option::Some(v);
    }

    // optional int64 preciseTradingCommissionRate = 31;

    pub fn preciseTradingCommissionRate(&self) -> i64 {
        self.preciseTradingCommissionRate.unwrap_or(0)
    }

    pub fn clear_preciseTradingCommissionRate(&mut self) {
        self.preciseTradingCommissionRate = ::std::option::Option::None;
    }

    pub fn has_preciseTradingCommissionRate(&self) -> bool {
        self.preciseTradingCommissionRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preciseTradingCommissionRate(&mut self, v: i64) {
        self.preciseTradingCommissionRate = ::std::option::Option::Some(v);
    }

    // optional int64 preciseMinCommission = 32;

    pub fn preciseMinCommission(&self) -> i64 {
        self.preciseMinCommission.unwrap_or(0)
    }

    pub fn clear_preciseMinCommission(&mut self) {
        self.preciseMinCommission = ::std::option::Option::None;
    }

    pub fn has_preciseMinCommission(&self) -> bool {
        self.preciseMinCommission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preciseMinCommission(&mut self, v: i64) {
        self.preciseMinCommission = ::std::option::Option::Some(v);
    }

    // optional int32 pnlConversionFeeRate = 34;

    pub fn pnlConversionFeeRate(&self) -> i32 {
        self.pnlConversionFeeRate.unwrap_or(0)
    }

    pub fn clear_pnlConversionFeeRate(&mut self) {
        self.pnlConversionFeeRate = ::std::option::Option::None;
    }

    pub fn has_pnlConversionFeeRate(&self) -> bool {
        self.pnlConversionFeeRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pnlConversionFeeRate(&mut self, v: i32) {
        self.pnlConversionFeeRate = ::std::option::Option::Some(v);
    }

    // optional int64 leverageId = 35;

    pub fn leverageId(&self) -> i64 {
        self.leverageId.unwrap_or(0)
    }

    pub fn clear_leverageId(&mut self) {
        self.leverageId = ::std::option::Option::None;
    }

    pub fn has_leverageId(&self) -> bool {
        self.leverageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leverageId(&mut self, v: i64) {
        self.leverageId = ::std::option::Option::Some(v);
    }

    // optional int32 swapPeriod = 36;

    pub fn swapPeriod(&self) -> i32 {
        self.swapPeriod.unwrap_or(0)
    }

    pub fn clear_swapPeriod(&mut self) {
        self.swapPeriod = ::std::option::Option::None;
    }

    pub fn has_swapPeriod(&self) -> bool {
        self.swapPeriod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapPeriod(&mut self, v: i32) {
        self.swapPeriod = ::std::option::Option::Some(v);
    }

    // optional int32 swapTime = 37;

    pub fn swapTime(&self) -> i32 {
        self.swapTime.unwrap_or(0)
    }

    pub fn clear_swapTime(&mut self) {
        self.swapTime = ::std::option::Option::None;
    }

    pub fn has_swapTime(&self) -> bool {
        self.swapTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapTime(&mut self, v: i32) {
        self.swapTime = ::std::option::Option::Some(v);
    }

    // optional int32 skipSWAPPeriods = 38;

    pub fn skipSWAPPeriods(&self) -> i32 {
        self.skipSWAPPeriods.unwrap_or(0)
    }

    pub fn clear_skipSWAPPeriods(&mut self) {
        self.skipSWAPPeriods = ::std::option::Option::None;
    }

    pub fn has_skipSWAPPeriods(&self) -> bool {
        self.skipSWAPPeriods.is_some()
    }

    // Param is passed by value, moved
    pub fn set_skipSWAPPeriods(&mut self, v: i32) {
        self.skipSWAPPeriods = ::std::option::Option::Some(v);
    }

    // optional bool chargeSwapAtWeekends = 39;

    pub fn chargeSwapAtWeekends(&self) -> bool {
        self.chargeSwapAtWeekends.unwrap_or(false)
    }

    pub fn clear_chargeSwapAtWeekends(&mut self) {
        self.chargeSwapAtWeekends = ::std::option::Option::None;
    }

    pub fn has_chargeSwapAtWeekends(&self) -> bool {
        self.chargeSwapAtWeekends.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chargeSwapAtWeekends(&mut self, v: bool) {
        self.chargeSwapAtWeekends = ::std::option::Option::Some(v);
    }

    // optional string measurementUnits = 40;

    pub fn measurementUnits(&self) -> &str {
        match self.measurementUnits.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_measurementUnits(&mut self) {
        self.measurementUnits = ::std::option::Option::None;
    }

    pub fn has_measurementUnits(&self) -> bool {
        self.measurementUnits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_measurementUnits(&mut self, v: ::std::string::String) {
        self.measurementUnits = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_measurementUnits(&mut self) -> &mut ::std::string::String {
        if self.measurementUnits.is_none() {
            self.measurementUnits = ::std::option::Option::Some(::std::string::String::new());
        }
        self.measurementUnits.as_mut().unwrap()
    }

    // Take field
    pub fn take_measurementUnits(&mut self) -> ::std::string::String {
        self.measurementUnits.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(40);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOASymbol| { &m.symbolId },
            |m: &mut ProtoOASymbol| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "digits",
            |m: &ProtoOASymbol| { &m.digits },
            |m: &mut ProtoOASymbol| { &mut m.digits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pipPosition",
            |m: &ProtoOASymbol| { &m.pipPosition },
            |m: &mut ProtoOASymbol| { &mut m.pipPosition },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enableShortSelling",
            |m: &ProtoOASymbol| { &m.enableShortSelling },
            |m: &mut ProtoOASymbol| { &mut m.enableShortSelling },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guaranteedStopLoss",
            |m: &ProtoOASymbol| { &m.guaranteedStopLoss },
            |m: &mut ProtoOASymbol| { &mut m.guaranteedStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapRollover3Days",
            |m: &ProtoOASymbol| { &m.swapRollover3Days },
            |m: &mut ProtoOASymbol| { &mut m.swapRollover3Days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapLong",
            |m: &ProtoOASymbol| { &m.swapLong },
            |m: &mut ProtoOASymbol| { &mut m.swapLong },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapShort",
            |m: &ProtoOASymbol| { &m.swapShort },
            |m: &mut ProtoOASymbol| { &mut m.swapShort },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxVolume",
            |m: &ProtoOASymbol| { &m.maxVolume },
            |m: &mut ProtoOASymbol| { &mut m.maxVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minVolume",
            |m: &ProtoOASymbol| { &m.minVolume },
            |m: &mut ProtoOASymbol| { &mut m.minVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stepVolume",
            |m: &ProtoOASymbol| { &m.stepVolume },
            |m: &mut ProtoOASymbol| { &mut m.stepVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxExposure",
            |m: &ProtoOASymbol| { &m.maxExposure },
            |m: &mut ProtoOASymbol| { &mut m.maxExposure },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "schedule",
            |m: &ProtoOASymbol| { &m.schedule },
            |m: &mut ProtoOASymbol| { &mut m.schedule },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commission",
            |m: &ProtoOASymbol| { &m.commission },
            |m: &mut ProtoOASymbol| { &mut m.commission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commissionType",
            |m: &ProtoOASymbol| { &m.commissionType },
            |m: &mut ProtoOASymbol| { &mut m.commissionType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slDistance",
            |m: &ProtoOASymbol| { &m.slDistance },
            |m: &mut ProtoOASymbol| { &mut m.slDistance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tpDistance",
            |m: &ProtoOASymbol| { &m.tpDistance },
            |m: &mut ProtoOASymbol| { &mut m.tpDistance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gslDistance",
            |m: &ProtoOASymbol| { &m.gslDistance },
            |m: &mut ProtoOASymbol| { &mut m.gslDistance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gslCharge",
            |m: &ProtoOASymbol| { &m.gslCharge },
            |m: &mut ProtoOASymbol| { &mut m.gslCharge },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "distanceSetIn",
            |m: &ProtoOASymbol| { &m.distanceSetIn },
            |m: &mut ProtoOASymbol| { &mut m.distanceSetIn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minCommission",
            |m: &ProtoOASymbol| { &m.minCommission },
            |m: &mut ProtoOASymbol| { &mut m.minCommission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minCommissionType",
            |m: &ProtoOASymbol| { &m.minCommissionType },
            |m: &mut ProtoOASymbol| { &mut m.minCommissionType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "minCommissionAsset",
            |m: &ProtoOASymbol| { &m.minCommissionAsset },
            |m: &mut ProtoOASymbol| { &mut m.minCommissionAsset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rolloverCommission",
            |m: &ProtoOASymbol| { &m.rolloverCommission },
            |m: &mut ProtoOASymbol| { &mut m.rolloverCommission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skipRolloverDays",
            |m: &ProtoOASymbol| { &m.skipRolloverDays },
            |m: &mut ProtoOASymbol| { &mut m.skipRolloverDays },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scheduleTimeZone",
            |m: &ProtoOASymbol| { &m.scheduleTimeZone },
            |m: &mut ProtoOASymbol| { &mut m.scheduleTimeZone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tradingMode",
            |m: &ProtoOASymbol| { &m.tradingMode },
            |m: &mut ProtoOASymbol| { &mut m.tradingMode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rolloverCommission3Days",
            |m: &ProtoOASymbol| { &m.rolloverCommission3Days },
            |m: &mut ProtoOASymbol| { &mut m.rolloverCommission3Days },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapCalculationType",
            |m: &ProtoOASymbol| { &m.swapCalculationType },
            |m: &mut ProtoOASymbol| { &mut m.swapCalculationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lotSize",
            |m: &ProtoOASymbol| { &m.lotSize },
            |m: &mut ProtoOASymbol| { &mut m.lotSize },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preciseTradingCommissionRate",
            |m: &ProtoOASymbol| { &m.preciseTradingCommissionRate },
            |m: &mut ProtoOASymbol| { &mut m.preciseTradingCommissionRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "preciseMinCommission",
            |m: &ProtoOASymbol| { &m.preciseMinCommission },
            |m: &mut ProtoOASymbol| { &mut m.preciseMinCommission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "holiday",
            |m: &ProtoOASymbol| { &m.holiday },
            |m: &mut ProtoOASymbol| { &mut m.holiday },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pnlConversionFeeRate",
            |m: &ProtoOASymbol| { &m.pnlConversionFeeRate },
            |m: &mut ProtoOASymbol| { &mut m.pnlConversionFeeRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leverageId",
            |m: &ProtoOASymbol| { &m.leverageId },
            |m: &mut ProtoOASymbol| { &mut m.leverageId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapPeriod",
            |m: &ProtoOASymbol| { &m.swapPeriod },
            |m: &mut ProtoOASymbol| { &mut m.swapPeriod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapTime",
            |m: &ProtoOASymbol| { &m.swapTime },
            |m: &mut ProtoOASymbol| { &mut m.swapTime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "skipSWAPPeriods",
            |m: &ProtoOASymbol| { &m.skipSWAPPeriods },
            |m: &mut ProtoOASymbol| { &mut m.skipSWAPPeriods },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "chargeSwapAtWeekends",
            |m: &ProtoOASymbol| { &m.chargeSwapAtWeekends },
            |m: &mut ProtoOASymbol| { &mut m.chargeSwapAtWeekends },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "measurementUnits",
            |m: &ProtoOASymbol| { &m.measurementUnits },
            |m: &mut ProtoOASymbol| { &mut m.measurementUnits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbol>(
            "ProtoOASymbol",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbol {
    const NAME: &'static str = "ProtoOASymbol";

    fn is_initialized(&self) -> bool {
        if self.symbolId.is_none() {
            return false;
        }
        if self.digits.is_none() {
            return false;
        }
        if self.pipPosition.is_none() {
            return false;
        }
        for v in &self.schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.holiday {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.digits = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.pipPosition = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.enableShortSelling = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.guaranteedStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.swapRollover3Days = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                57 => {
                    self.swapLong = ::std::option::Option::Some(is.read_double()?);
                },
                65 => {
                    self.swapShort = ::std::option::Option::Some(is.read_double()?);
                },
                72 => {
                    self.maxVolume = ::std::option::Option::Some(is.read_int64()?);
                },
                80 => {
                    self.minVolume = ::std::option::Option::Some(is.read_int64()?);
                },
                88 => {
                    self.stepVolume = ::std::option::Option::Some(is.read_int64()?);
                },
                96 => {
                    self.maxExposure = ::std::option::Option::Some(is.read_uint64()?);
                },
                106 => {
                    self.schedule.push(is.read_message()?);
                },
                112 => {
                    self.commission = ::std::option::Option::Some(is.read_int64()?);
                },
                120 => {
                    self.commissionType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                128 => {
                    self.slDistance = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.tpDistance = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.gslDistance = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.gslCharge = ::std::option::Option::Some(is.read_int64()?);
                },
                160 => {
                    self.distanceSetIn = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                168 => {
                    self.minCommission = ::std::option::Option::Some(is.read_int64()?);
                },
                176 => {
                    self.minCommissionType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                186 => {
                    self.minCommissionAsset = ::std::option::Option::Some(is.read_string()?);
                },
                192 => {
                    self.rolloverCommission = ::std::option::Option::Some(is.read_int64()?);
                },
                200 => {
                    self.skipRolloverDays = ::std::option::Option::Some(is.read_int32()?);
                },
                210 => {
                    self.scheduleTimeZone = ::std::option::Option::Some(is.read_string()?);
                },
                216 => {
                    self.tradingMode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                224 => {
                    self.rolloverCommission3Days = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                232 => {
                    self.swapCalculationType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                240 => {
                    self.lotSize = ::std::option::Option::Some(is.read_int64()?);
                },
                248 => {
                    self.preciseTradingCommissionRate = ::std::option::Option::Some(is.read_int64()?);
                },
                256 => {
                    self.preciseMinCommission = ::std::option::Option::Some(is.read_int64()?);
                },
                266 => {
                    self.holiday.push(is.read_message()?);
                },
                272 => {
                    self.pnlConversionFeeRate = ::std::option::Option::Some(is.read_int32()?);
                },
                280 => {
                    self.leverageId = ::std::option::Option::Some(is.read_int64()?);
                },
                288 => {
                    self.swapPeriod = ::std::option::Option::Some(is.read_int32()?);
                },
                296 => {
                    self.swapTime = ::std::option::Option::Some(is.read_int32()?);
                },
                304 => {
                    self.skipSWAPPeriods = ::std::option::Option::Some(is.read_int32()?);
                },
                312 => {
                    self.chargeSwapAtWeekends = ::std::option::Option::Some(is.read_bool()?);
                },
                322 => {
                    self.measurementUnits = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.digits {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.pipPosition {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.enableShortSelling {
            my_size += 1 + 1;
        }
        if let Some(v) = self.guaranteedStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.swapRollover3Days {
            my_size += ::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.swapLong {
            my_size += 1 + 8;
        }
        if let Some(v) = self.swapShort {
            my_size += 1 + 8;
        }
        if let Some(v) = self.maxVolume {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.minVolume {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        if let Some(v) = self.stepVolume {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        if let Some(v) = self.maxExposure {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        for value in &self.schedule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.commission {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.commissionType {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.slDistance {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.tpDistance {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.gslDistance {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.gslCharge {
            my_size += ::protobuf::rt::int64_size(19, v);
        }
        if let Some(v) = self.distanceSetIn {
            my_size += ::protobuf::rt::int32_size(20, v.value());
        }
        if let Some(v) = self.minCommission {
            my_size += ::protobuf::rt::int64_size(21, v);
        }
        if let Some(v) = self.minCommissionType {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.minCommissionAsset.as_ref() {
            my_size += ::protobuf::rt::string_size(23, &v);
        }
        if let Some(v) = self.rolloverCommission {
            my_size += ::protobuf::rt::int64_size(24, v);
        }
        if let Some(v) = self.skipRolloverDays {
            my_size += ::protobuf::rt::int32_size(25, v);
        }
        if let Some(v) = self.scheduleTimeZone.as_ref() {
            my_size += ::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.tradingMode {
            my_size += ::protobuf::rt::int32_size(27, v.value());
        }
        if let Some(v) = self.rolloverCommission3Days {
            my_size += ::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.swapCalculationType {
            my_size += ::protobuf::rt::int32_size(29, v.value());
        }
        if let Some(v) = self.lotSize {
            my_size += ::protobuf::rt::int64_size(30, v);
        }
        if let Some(v) = self.preciseTradingCommissionRate {
            my_size += ::protobuf::rt::int64_size(31, v);
        }
        if let Some(v) = self.preciseMinCommission {
            my_size += ::protobuf::rt::int64_size(32, v);
        }
        for value in &self.holiday {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.pnlConversionFeeRate {
            my_size += ::protobuf::rt::int32_size(34, v);
        }
        if let Some(v) = self.leverageId {
            my_size += ::protobuf::rt::int64_size(35, v);
        }
        if let Some(v) = self.swapPeriod {
            my_size += ::protobuf::rt::int32_size(36, v);
        }
        if let Some(v) = self.swapTime {
            my_size += ::protobuf::rt::int32_size(37, v);
        }
        if let Some(v) = self.skipSWAPPeriods {
            my_size += ::protobuf::rt::int32_size(38, v);
        }
        if let Some(v) = self.chargeSwapAtWeekends {
            my_size += 2 + 1;
        }
        if let Some(v) = self.measurementUnits.as_ref() {
            my_size += ::protobuf::rt::string_size(40, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.symbolId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.digits {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.pipPosition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.enableShortSelling {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.guaranteedStopLoss {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.swapRollover3Days {
            os.write_enum(6, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.swapLong {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.swapShort {
            os.write_double(8, v)?;
        }
        if let Some(v) = self.maxVolume {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.minVolume {
            os.write_int64(10, v)?;
        }
        if let Some(v) = self.stepVolume {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.maxExposure {
            os.write_uint64(12, v)?;
        }
        for v in &self.schedule {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.commission {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.commissionType {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slDistance {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tpDistance {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.gslDistance {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.gslCharge {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.distanceSetIn {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.minCommission {
            os.write_int64(21, v)?;
        }
        if let Some(v) = self.minCommissionType {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.minCommissionAsset.as_ref() {
            os.write_string(23, v)?;
        }
        if let Some(v) = self.rolloverCommission {
            os.write_int64(24, v)?;
        }
        if let Some(v) = self.skipRolloverDays {
            os.write_int32(25, v)?;
        }
        if let Some(v) = self.scheduleTimeZone.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.tradingMode {
            os.write_enum(27, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rolloverCommission3Days {
            os.write_enum(28, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.swapCalculationType {
            os.write_enum(29, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lotSize {
            os.write_int64(30, v)?;
        }
        if let Some(v) = self.preciseTradingCommissionRate {
            os.write_int64(31, v)?;
        }
        if let Some(v) = self.preciseMinCommission {
            os.write_int64(32, v)?;
        }
        for v in &self.holiday {
            ::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        };
        if let Some(v) = self.pnlConversionFeeRate {
            os.write_int32(34, v)?;
        }
        if let Some(v) = self.leverageId {
            os.write_int64(35, v)?;
        }
        if let Some(v) = self.swapPeriod {
            os.write_int32(36, v)?;
        }
        if let Some(v) = self.swapTime {
            os.write_int32(37, v)?;
        }
        if let Some(v) = self.skipSWAPPeriods {
            os.write_int32(38, v)?;
        }
        if let Some(v) = self.chargeSwapAtWeekends {
            os.write_bool(39, v)?;
        }
        if let Some(v) = self.measurementUnits.as_ref() {
            os.write_string(40, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbol {
        ProtoOASymbol::new()
    }

    fn clear(&mut self) {
        self.symbolId = ::std::option::Option::None;
        self.digits = ::std::option::Option::None;
        self.pipPosition = ::std::option::Option::None;
        self.enableShortSelling = ::std::option::Option::None;
        self.guaranteedStopLoss = ::std::option::Option::None;
        self.swapRollover3Days = ::std::option::Option::None;
        self.swapLong = ::std::option::Option::None;
        self.swapShort = ::std::option::Option::None;
        self.maxVolume = ::std::option::Option::None;
        self.minVolume = ::std::option::Option::None;
        self.stepVolume = ::std::option::Option::None;
        self.maxExposure = ::std::option::Option::None;
        self.schedule.clear();
        self.commission = ::std::option::Option::None;
        self.commissionType = ::std::option::Option::None;
        self.slDistance = ::std::option::Option::None;
        self.tpDistance = ::std::option::Option::None;
        self.gslDistance = ::std::option::Option::None;
        self.gslCharge = ::std::option::Option::None;
        self.distanceSetIn = ::std::option::Option::None;
        self.minCommission = ::std::option::Option::None;
        self.minCommissionType = ::std::option::Option::None;
        self.minCommissionAsset = ::std::option::Option::None;
        self.rolloverCommission = ::std::option::Option::None;
        self.skipRolloverDays = ::std::option::Option::None;
        self.scheduleTimeZone = ::std::option::Option::None;
        self.tradingMode = ::std::option::Option::None;
        self.rolloverCommission3Days = ::std::option::Option::None;
        self.swapCalculationType = ::std::option::Option::None;
        self.lotSize = ::std::option::Option::None;
        self.preciseTradingCommissionRate = ::std::option::Option::None;
        self.preciseMinCommission = ::std::option::Option::None;
        self.holiday.clear();
        self.pnlConversionFeeRate = ::std::option::Option::None;
        self.leverageId = ::std::option::Option::None;
        self.swapPeriod = ::std::option::Option::None;
        self.swapTime = ::std::option::Option::None;
        self.skipSWAPPeriods = ::std::option::Option::None;
        self.chargeSwapAtWeekends = ::std::option::Option::None;
        self.measurementUnits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbol {
        static instance: ProtoOASymbol = ProtoOASymbol {
            symbolId: ::std::option::Option::None,
            digits: ::std::option::Option::None,
            pipPosition: ::std::option::Option::None,
            enableShortSelling: ::std::option::Option::None,
            guaranteedStopLoss: ::std::option::Option::None,
            swapRollover3Days: ::std::option::Option::None,
            swapLong: ::std::option::Option::None,
            swapShort: ::std::option::Option::None,
            maxVolume: ::std::option::Option::None,
            minVolume: ::std::option::Option::None,
            stepVolume: ::std::option::Option::None,
            maxExposure: ::std::option::Option::None,
            schedule: ::std::vec::Vec::new(),
            commission: ::std::option::Option::None,
            commissionType: ::std::option::Option::None,
            slDistance: ::std::option::Option::None,
            tpDistance: ::std::option::Option::None,
            gslDistance: ::std::option::Option::None,
            gslCharge: ::std::option::Option::None,
            distanceSetIn: ::std::option::Option::None,
            minCommission: ::std::option::Option::None,
            minCommissionType: ::std::option::Option::None,
            minCommissionAsset: ::std::option::Option::None,
            rolloverCommission: ::std::option::Option::None,
            skipRolloverDays: ::std::option::Option::None,
            scheduleTimeZone: ::std::option::Option::None,
            tradingMode: ::std::option::Option::None,
            rolloverCommission3Days: ::std::option::Option::None,
            swapCalculationType: ::std::option::Option::None,
            lotSize: ::std::option::Option::None,
            preciseTradingCommissionRate: ::std::option::Option::None,
            preciseMinCommission: ::std::option::Option::None,
            holiday: ::std::vec::Vec::new(),
            pnlConversionFeeRate: ::std::option::Option::None,
            leverageId: ::std::option::Option::None,
            swapPeriod: ::std::option::Option::None,
            swapTime: ::std::option::Option::None,
            skipSWAPPeriods: ::std::option::Option::None,
            chargeSwapAtWeekends: ::std::option::Option::None,
            measurementUnits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbol {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbol").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbol {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOALightSymbol)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOALightSymbol {
    // message fields
    // @@protoc_insertion_point(field:ProtoOALightSymbol.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.symbolName)
    pub symbolName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.enabled)
    pub enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.baseAssetId)
    pub baseAssetId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.quoteAssetId)
    pub quoteAssetId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.symbolCategoryId)
    pub symbolCategoryId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOALightSymbol.sortingNumber)
    pub sortingNumber: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOALightSymbol.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOALightSymbol {
    fn default() -> &'a ProtoOALightSymbol {
        <ProtoOALightSymbol as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOALightSymbol {
    pub fn new() -> ProtoOALightSymbol {
        ::std::default::Default::default()
    }

    // required int64 symbolId = 1;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // optional string symbolName = 2;

    pub fn symbolName(&self) -> &str {
        match self.symbolName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_symbolName(&mut self) {
        self.symbolName = ::std::option::Option::None;
    }

    pub fn has_symbolName(&self) -> bool {
        self.symbolName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolName(&mut self, v: ::std::string::String) {
        self.symbolName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symbolName(&mut self) -> &mut ::std::string::String {
        if self.symbolName.is_none() {
            self.symbolName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.symbolName.as_mut().unwrap()
    }

    // Take field
    pub fn take_symbolName(&mut self) -> ::std::string::String {
        self.symbolName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enabled = 3;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }

    // optional int64 baseAssetId = 4;

    pub fn baseAssetId(&self) -> i64 {
        self.baseAssetId.unwrap_or(0)
    }

    pub fn clear_baseAssetId(&mut self) {
        self.baseAssetId = ::std::option::Option::None;
    }

    pub fn has_baseAssetId(&self) -> bool {
        self.baseAssetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseAssetId(&mut self, v: i64) {
        self.baseAssetId = ::std::option::Option::Some(v);
    }

    // optional int64 quoteAssetId = 5;

    pub fn quoteAssetId(&self) -> i64 {
        self.quoteAssetId.unwrap_or(0)
    }

    pub fn clear_quoteAssetId(&mut self) {
        self.quoteAssetId = ::std::option::Option::None;
    }

    pub fn has_quoteAssetId(&self) -> bool {
        self.quoteAssetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quoteAssetId(&mut self, v: i64) {
        self.quoteAssetId = ::std::option::Option::Some(v);
    }

    // optional int64 symbolCategoryId = 6;

    pub fn symbolCategoryId(&self) -> i64 {
        self.symbolCategoryId.unwrap_or(0)
    }

    pub fn clear_symbolCategoryId(&mut self) {
        self.symbolCategoryId = ::std::option::Option::None;
    }

    pub fn has_symbolCategoryId(&self) -> bool {
        self.symbolCategoryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolCategoryId(&mut self, v: i64) {
        self.symbolCategoryId = ::std::option::Option::Some(v);
    }

    // optional string description = 7;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double sortingNumber = 8;

    pub fn sortingNumber(&self) -> f64 {
        self.sortingNumber.unwrap_or(0.)
    }

    pub fn clear_sortingNumber(&mut self) {
        self.sortingNumber = ::std::option::Option::None;
    }

    pub fn has_sortingNumber(&self) -> bool {
        self.sortingNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortingNumber(&mut self, v: f64) {
        self.sortingNumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOALightSymbol| { &m.symbolId },
            |m: &mut ProtoOALightSymbol| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolName",
            |m: &ProtoOALightSymbol| { &m.symbolName },
            |m: &mut ProtoOALightSymbol| { &mut m.symbolName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "enabled",
            |m: &ProtoOALightSymbol| { &m.enabled },
            |m: &mut ProtoOALightSymbol| { &mut m.enabled },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseAssetId",
            |m: &ProtoOALightSymbol| { &m.baseAssetId },
            |m: &mut ProtoOALightSymbol| { &mut m.baseAssetId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quoteAssetId",
            |m: &ProtoOALightSymbol| { &m.quoteAssetId },
            |m: &mut ProtoOALightSymbol| { &mut m.quoteAssetId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolCategoryId",
            |m: &ProtoOALightSymbol| { &m.symbolCategoryId },
            |m: &mut ProtoOALightSymbol| { &mut m.symbolCategoryId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ProtoOALightSymbol| { &m.description },
            |m: &mut ProtoOALightSymbol| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sortingNumber",
            |m: &ProtoOALightSymbol| { &m.sortingNumber },
            |m: &mut ProtoOALightSymbol| { &mut m.sortingNumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOALightSymbol>(
            "ProtoOALightSymbol",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOALightSymbol {
    const NAME: &'static str = "ProtoOALightSymbol";

    fn is_initialized(&self) -> bool {
        if self.symbolId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.symbolName = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.baseAssetId = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.quoteAssetId = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.symbolCategoryId = ::std::option::Option::Some(is.read_int64()?);
                },
                58 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                65 => {
                    self.sortingNumber = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.symbolName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.baseAssetId {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.quoteAssetId {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.symbolCategoryId {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.sortingNumber {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.symbolId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.symbolName.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.enabled {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.baseAssetId {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.quoteAssetId {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.symbolCategoryId {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.sortingNumber {
            os.write_double(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOALightSymbol {
        ProtoOALightSymbol::new()
    }

    fn clear(&mut self) {
        self.symbolId = ::std::option::Option::None;
        self.symbolName = ::std::option::Option::None;
        self.enabled = ::std::option::Option::None;
        self.baseAssetId = ::std::option::Option::None;
        self.quoteAssetId = ::std::option::Option::None;
        self.symbolCategoryId = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.sortingNumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOALightSymbol {
        static instance: ProtoOALightSymbol = ProtoOALightSymbol {
            symbolId: ::std::option::Option::None,
            symbolName: ::std::option::Option::None,
            enabled: ::std::option::Option::None,
            baseAssetId: ::std::option::Option::None,
            quoteAssetId: ::std::option::Option::None,
            symbolCategoryId: ::std::option::Option::None,
            description: ::std::option::Option::None,
            sortingNumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOALightSymbol {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOALightSymbol").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOALightSymbol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOALightSymbol {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAArchivedSymbol)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAArchivedSymbol {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAArchivedSymbol.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAArchivedSymbol.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAArchivedSymbol.utcLastUpdateTimestamp)
    pub utcLastUpdateTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAArchivedSymbol.description)
    pub description: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAArchivedSymbol.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAArchivedSymbol {
    fn default() -> &'a ProtoOAArchivedSymbol {
        <ProtoOAArchivedSymbol as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAArchivedSymbol {
    pub fn new() -> ProtoOAArchivedSymbol {
        ::std::default::Default::default()
    }

    // required int64 symbolId = 1;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // required string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 utcLastUpdateTimestamp = 3;

    pub fn utcLastUpdateTimestamp(&self) -> i64 {
        self.utcLastUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_utcLastUpdateTimestamp(&mut self) {
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_utcLastUpdateTimestamp(&self) -> bool {
        self.utcLastUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcLastUpdateTimestamp(&mut self, v: i64) {
        self.utcLastUpdateTimestamp = ::std::option::Option::Some(v);
    }

    // optional string description = 4;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOAArchivedSymbol| { &m.symbolId },
            |m: &mut ProtoOAArchivedSymbol| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ProtoOAArchivedSymbol| { &m.name },
            |m: &mut ProtoOAArchivedSymbol| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcLastUpdateTimestamp",
            |m: &ProtoOAArchivedSymbol| { &m.utcLastUpdateTimestamp },
            |m: &mut ProtoOAArchivedSymbol| { &mut m.utcLastUpdateTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ProtoOAArchivedSymbol| { &m.description },
            |m: &mut ProtoOAArchivedSymbol| { &mut m.description },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAArchivedSymbol>(
            "ProtoOAArchivedSymbol",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAArchivedSymbol {
    const NAME: &'static str = "ProtoOAArchivedSymbol";

    fn is_initialized(&self) -> bool {
        if self.symbolId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.utcLastUpdateTimestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.utcLastUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.symbolId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAArchivedSymbol {
        ProtoOAArchivedSymbol::new()
    }

    fn clear(&mut self) {
        self.symbolId = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAArchivedSymbol {
        static instance: ProtoOAArchivedSymbol = ProtoOAArchivedSymbol {
            symbolId: ::std::option::Option::None,
            name: ::std::option::Option::None,
            utcLastUpdateTimestamp: ::std::option::Option::None,
            description: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAArchivedSymbol {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAArchivedSymbol").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAArchivedSymbol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAArchivedSymbol {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOASymbolCategory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOASymbolCategory {
    // message fields
    // @@protoc_insertion_point(field:ProtoOASymbolCategory.id)
    pub id: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolCategory.assetClassId)
    pub assetClassId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOASymbolCategory.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOASymbolCategory.sortingNumber)
    pub sortingNumber: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOASymbolCategory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOASymbolCategory {
    fn default() -> &'a ProtoOASymbolCategory {
        <ProtoOASymbolCategory as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOASymbolCategory {
    pub fn new() -> ProtoOASymbolCategory {
        ::std::default::Default::default()
    }

    // required int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required int64 assetClassId = 2;

    pub fn assetClassId(&self) -> i64 {
        self.assetClassId.unwrap_or(0)
    }

    pub fn clear_assetClassId(&mut self) {
        self.assetClassId = ::std::option::Option::None;
    }

    pub fn has_assetClassId(&self) -> bool {
        self.assetClassId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assetClassId(&mut self, v: i64) {
        self.assetClassId = ::std::option::Option::Some(v);
    }

    // required string name = 3;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double sortingNumber = 4;

    pub fn sortingNumber(&self) -> f64 {
        self.sortingNumber.unwrap_or(0.)
    }

    pub fn clear_sortingNumber(&mut self) {
        self.sortingNumber = ::std::option::Option::None;
    }

    pub fn has_sortingNumber(&self) -> bool {
        self.sortingNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortingNumber(&mut self, v: f64) {
        self.sortingNumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ProtoOASymbolCategory| { &m.id },
            |m: &mut ProtoOASymbolCategory| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "assetClassId",
            |m: &ProtoOASymbolCategory| { &m.assetClassId },
            |m: &mut ProtoOASymbolCategory| { &mut m.assetClassId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ProtoOASymbolCategory| { &m.name },
            |m: &mut ProtoOASymbolCategory| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sortingNumber",
            |m: &ProtoOASymbolCategory| { &m.sortingNumber },
            |m: &mut ProtoOASymbolCategory| { &mut m.sortingNumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOASymbolCategory>(
            "ProtoOASymbolCategory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOASymbolCategory {
    const NAME: &'static str = "ProtoOASymbolCategory";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.assetClassId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.assetClassId = ::std::option::Option::Some(is.read_int64()?);
                },
                26 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                33 => {
                    self.sortingNumber = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.assetClassId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.sortingNumber {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.assetClassId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.sortingNumber {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOASymbolCategory {
        ProtoOASymbolCategory::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.assetClassId = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.sortingNumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOASymbolCategory {
        static instance: ProtoOASymbolCategory = ProtoOASymbolCategory {
            id: ::std::option::Option::None,
            assetClassId: ::std::option::Option::None,
            name: ::std::option::Option::None,
            sortingNumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOASymbolCategory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOASymbolCategory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOASymbolCategory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOASymbolCategory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAInterval)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAInterval {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAInterval.startSecond)
    pub startSecond: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOAInterval.endSecond)
    pub endSecond: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAInterval.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAInterval {
    fn default() -> &'a ProtoOAInterval {
        <ProtoOAInterval as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAInterval {
    pub fn new() -> ProtoOAInterval {
        ::std::default::Default::default()
    }

    // required uint32 startSecond = 3;

    pub fn startSecond(&self) -> u32 {
        self.startSecond.unwrap_or(0)
    }

    pub fn clear_startSecond(&mut self) {
        self.startSecond = ::std::option::Option::None;
    }

    pub fn has_startSecond(&self) -> bool {
        self.startSecond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startSecond(&mut self, v: u32) {
        self.startSecond = ::std::option::Option::Some(v);
    }

    // required uint32 endSecond = 4;

    pub fn endSecond(&self) -> u32 {
        self.endSecond.unwrap_or(0)
    }

    pub fn clear_endSecond(&mut self) {
        self.endSecond = ::std::option::Option::None;
    }

    pub fn has_endSecond(&self) -> bool {
        self.endSecond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endSecond(&mut self, v: u32) {
        self.endSecond = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startSecond",
            |m: &ProtoOAInterval| { &m.startSecond },
            |m: &mut ProtoOAInterval| { &mut m.startSecond },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endSecond",
            |m: &ProtoOAInterval| { &m.endSecond },
            |m: &mut ProtoOAInterval| { &mut m.endSecond },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAInterval>(
            "ProtoOAInterval",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAInterval {
    const NAME: &'static str = "ProtoOAInterval";

    fn is_initialized(&self) -> bool {
        if self.startSecond.is_none() {
            return false;
        }
        if self.endSecond.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.startSecond = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.endSecond = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.startSecond {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.endSecond {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.startSecond {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.endSecond {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAInterval {
        ProtoOAInterval::new()
    }

    fn clear(&mut self) {
        self.startSecond = ::std::option::Option::None;
        self.endSecond = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAInterval {
        static instance: ProtoOAInterval = ProtoOAInterval {
            startSecond: ::std::option::Option::None,
            endSecond: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAInterval {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAInterval").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAInterval {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAInterval {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATrader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATrader {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATrader.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.balance)
    pub balance: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.balanceVersion)
    pub balanceVersion: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.managerBonus)
    pub managerBonus: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.ibBonus)
    pub ibBonus: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.nonWithdrawableBonus)
    pub nonWithdrawableBonus: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.accessRights)
    pub accessRights: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAAccessRights>>,
    // @@protoc_insertion_point(field:ProtoOATrader.depositAssetId)
    pub depositAssetId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.swapFree)
    pub swapFree: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOATrader.leverageInCents)
    pub leverageInCents: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOATrader.totalMarginCalculationType)
    pub totalMarginCalculationType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOATotalMarginCalculationType>>,
    // @@protoc_insertion_point(field:ProtoOATrader.maxLeverage)
    pub maxLeverage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOATrader.frenchRisk)
    pub frenchRisk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOATrader.traderLogin)
    pub traderLogin: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.accountType)
    pub accountType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAAccountType>>,
    // @@protoc_insertion_point(field:ProtoOATrader.brokerName)
    pub brokerName: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOATrader.registrationTimestamp)
    pub registrationTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrader.isLimitedRisk)
    pub isLimitedRisk: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOATrader.limitedRiskMarginCalculationStrategy)
    pub limitedRiskMarginCalculationStrategy: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOALimitedRiskMarginCalculationStrategy>>,
    // @@protoc_insertion_point(field:ProtoOATrader.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOATrader.fairStopOut)
    pub fairStopOut: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOATrader.stopOutStrategy)
    pub stopOutStrategy: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAStopOutStrategy>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATrader.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATrader {
    fn default() -> &'a ProtoOATrader {
        <ProtoOATrader as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATrader {
    pub fn new() -> ProtoOATrader {
        ::std::default::Default::default()
    }

    // required int64 ctidTraderAccountId = 1;

    pub fn ctidTraderAccountId(&self) -> i64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: i64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // required int64 balance = 2;

    pub fn balance(&self) -> i64 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int64 balanceVersion = 3;

    pub fn balanceVersion(&self) -> i64 {
        self.balanceVersion.unwrap_or(0)
    }

    pub fn clear_balanceVersion(&mut self) {
        self.balanceVersion = ::std::option::Option::None;
    }

    pub fn has_balanceVersion(&self) -> bool {
        self.balanceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balanceVersion(&mut self, v: i64) {
        self.balanceVersion = ::std::option::Option::Some(v);
    }

    // optional int64 managerBonus = 4;

    pub fn managerBonus(&self) -> i64 {
        self.managerBonus.unwrap_or(0)
    }

    pub fn clear_managerBonus(&mut self) {
        self.managerBonus = ::std::option::Option::None;
    }

    pub fn has_managerBonus(&self) -> bool {
        self.managerBonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_managerBonus(&mut self, v: i64) {
        self.managerBonus = ::std::option::Option::Some(v);
    }

    // optional int64 ibBonus = 5;

    pub fn ibBonus(&self) -> i64 {
        self.ibBonus.unwrap_or(0)
    }

    pub fn clear_ibBonus(&mut self) {
        self.ibBonus = ::std::option::Option::None;
    }

    pub fn has_ibBonus(&self) -> bool {
        self.ibBonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ibBonus(&mut self, v: i64) {
        self.ibBonus = ::std::option::Option::Some(v);
    }

    // optional int64 nonWithdrawableBonus = 6;

    pub fn nonWithdrawableBonus(&self) -> i64 {
        self.nonWithdrawableBonus.unwrap_or(0)
    }

    pub fn clear_nonWithdrawableBonus(&mut self) {
        self.nonWithdrawableBonus = ::std::option::Option::None;
    }

    pub fn has_nonWithdrawableBonus(&self) -> bool {
        self.nonWithdrawableBonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nonWithdrawableBonus(&mut self, v: i64) {
        self.nonWithdrawableBonus = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAAccessRights accessRights = 7;

    pub fn accessRights(&self) -> ProtoOAAccessRights {
        match self.accessRights {
            Some(e) => e.enum_value_or(ProtoOAAccessRights::FULL_ACCESS),
            None => ProtoOAAccessRights::FULL_ACCESS,
        }
    }

    pub fn clear_accessRights(&mut self) {
        self.accessRights = ::std::option::Option::None;
    }

    pub fn has_accessRights(&self) -> bool {
        self.accessRights.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accessRights(&mut self, v: ProtoOAAccessRights) {
        self.accessRights = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 depositAssetId = 8;

    pub fn depositAssetId(&self) -> i64 {
        self.depositAssetId.unwrap_or(0)
    }

    pub fn clear_depositAssetId(&mut self) {
        self.depositAssetId = ::std::option::Option::None;
    }

    pub fn has_depositAssetId(&self) -> bool {
        self.depositAssetId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_depositAssetId(&mut self, v: i64) {
        self.depositAssetId = ::std::option::Option::Some(v);
    }

    // optional bool swapFree = 9;

    pub fn swapFree(&self) -> bool {
        self.swapFree.unwrap_or(false)
    }

    pub fn clear_swapFree(&mut self) {
        self.swapFree = ::std::option::Option::None;
    }

    pub fn has_swapFree(&self) -> bool {
        self.swapFree.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swapFree(&mut self, v: bool) {
        self.swapFree = ::std::option::Option::Some(v);
    }

    // optional uint32 leverageInCents = 10;

    pub fn leverageInCents(&self) -> u32 {
        self.leverageInCents.unwrap_or(0)
    }

    pub fn clear_leverageInCents(&mut self) {
        self.leverageInCents = ::std::option::Option::None;
    }

    pub fn has_leverageInCents(&self) -> bool {
        self.leverageInCents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leverageInCents(&mut self, v: u32) {
        self.leverageInCents = ::std::option::Option::Some(v);
    }

    // optional .ProtoOATotalMarginCalculationType totalMarginCalculationType = 11;

    pub fn totalMarginCalculationType(&self) -> ProtoOATotalMarginCalculationType {
        match self.totalMarginCalculationType {
            Some(e) => e.enum_value_or(ProtoOATotalMarginCalculationType::MAX),
            None => ProtoOATotalMarginCalculationType::MAX,
        }
    }

    pub fn clear_totalMarginCalculationType(&mut self) {
        self.totalMarginCalculationType = ::std::option::Option::None;
    }

    pub fn has_totalMarginCalculationType(&self) -> bool {
        self.totalMarginCalculationType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_totalMarginCalculationType(&mut self, v: ProtoOATotalMarginCalculationType) {
        self.totalMarginCalculationType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 maxLeverage = 12;

    pub fn maxLeverage(&self) -> u32 {
        self.maxLeverage.unwrap_or(0)
    }

    pub fn clear_maxLeverage(&mut self) {
        self.maxLeverage = ::std::option::Option::None;
    }

    pub fn has_maxLeverage(&self) -> bool {
        self.maxLeverage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxLeverage(&mut self, v: u32) {
        self.maxLeverage = ::std::option::Option::Some(v);
    }

    // optional bool frenchRisk = 13;

    pub fn frenchRisk(&self) -> bool {
        self.frenchRisk.unwrap_or(false)
    }

    pub fn clear_frenchRisk(&mut self) {
        self.frenchRisk = ::std::option::Option::None;
    }

    pub fn has_frenchRisk(&self) -> bool {
        self.frenchRisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frenchRisk(&mut self, v: bool) {
        self.frenchRisk = ::std::option::Option::Some(v);
    }

    // optional int64 traderLogin = 14;

    pub fn traderLogin(&self) -> i64 {
        self.traderLogin.unwrap_or(0)
    }

    pub fn clear_traderLogin(&mut self) {
        self.traderLogin = ::std::option::Option::None;
    }

    pub fn has_traderLogin(&self) -> bool {
        self.traderLogin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traderLogin(&mut self, v: i64) {
        self.traderLogin = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAAccountType accountType = 15;

    pub fn accountType(&self) -> ProtoOAAccountType {
        match self.accountType {
            Some(e) => e.enum_value_or(ProtoOAAccountType::HEDGED),
            None => ProtoOAAccountType::HEDGED,
        }
    }

    pub fn clear_accountType(&mut self) {
        self.accountType = ::std::option::Option::None;
    }

    pub fn has_accountType(&self) -> bool {
        self.accountType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountType(&mut self, v: ProtoOAAccountType) {
        self.accountType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional string brokerName = 16;

    pub fn brokerName(&self) -> &str {
        match self.brokerName.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_brokerName(&mut self) {
        self.brokerName = ::std::option::Option::None;
    }

    pub fn has_brokerName(&self) -> bool {
        self.brokerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brokerName(&mut self, v: ::std::string::String) {
        self.brokerName = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brokerName(&mut self) -> &mut ::std::string::String {
        if self.brokerName.is_none() {
            self.brokerName = ::std::option::Option::Some(::std::string::String::new());
        }
        self.brokerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_brokerName(&mut self) -> ::std::string::String {
        self.brokerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 registrationTimestamp = 17;

    pub fn registrationTimestamp(&self) -> i64 {
        self.registrationTimestamp.unwrap_or(0)
    }

    pub fn clear_registrationTimestamp(&mut self) {
        self.registrationTimestamp = ::std::option::Option::None;
    }

    pub fn has_registrationTimestamp(&self) -> bool {
        self.registrationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registrationTimestamp(&mut self, v: i64) {
        self.registrationTimestamp = ::std::option::Option::Some(v);
    }

    // optional bool isLimitedRisk = 18;

    pub fn isLimitedRisk(&self) -> bool {
        self.isLimitedRisk.unwrap_or(false)
    }

    pub fn clear_isLimitedRisk(&mut self) {
        self.isLimitedRisk = ::std::option::Option::None;
    }

    pub fn has_isLimitedRisk(&self) -> bool {
        self.isLimitedRisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLimitedRisk(&mut self, v: bool) {
        self.isLimitedRisk = ::std::option::Option::Some(v);
    }

    // optional .ProtoOALimitedRiskMarginCalculationStrategy limitedRiskMarginCalculationStrategy = 19;

    pub fn limitedRiskMarginCalculationStrategy(&self) -> ProtoOALimitedRiskMarginCalculationStrategy {
        match self.limitedRiskMarginCalculationStrategy {
            Some(e) => e.enum_value_or(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_LEVERAGE),
            None => ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_LEVERAGE,
        }
    }

    pub fn clear_limitedRiskMarginCalculationStrategy(&mut self) {
        self.limitedRiskMarginCalculationStrategy = ::std::option::Option::None;
    }

    pub fn has_limitedRiskMarginCalculationStrategy(&self) -> bool {
        self.limitedRiskMarginCalculationStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitedRiskMarginCalculationStrategy(&mut self, v: ProtoOALimitedRiskMarginCalculationStrategy) {
        self.limitedRiskMarginCalculationStrategy = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 moneyDigits = 20;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    // optional bool fairStopOut = 21;

    pub fn fairStopOut(&self) -> bool {
        self.fairStopOut.unwrap_or(false)
    }

    pub fn clear_fairStopOut(&mut self) {
        self.fairStopOut = ::std::option::Option::None;
    }

    pub fn has_fairStopOut(&self) -> bool {
        self.fairStopOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fairStopOut(&mut self, v: bool) {
        self.fairStopOut = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAStopOutStrategy stopOutStrategy = 22;

    pub fn stopOutStrategy(&self) -> ProtoOAStopOutStrategy {
        match self.stopOutStrategy {
            Some(e) => e.enum_value_or(ProtoOAStopOutStrategy::MOST_MARGIN_USED_FIRST),
            None => ProtoOAStopOutStrategy::MOST_MARGIN_USED_FIRST,
        }
    }

    pub fn clear_stopOutStrategy(&mut self) {
        self.stopOutStrategy = ::std::option::Option::None;
    }

    pub fn has_stopOutStrategy(&self) -> bool {
        self.stopOutStrategy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopOutStrategy(&mut self, v: ProtoOAStopOutStrategy) {
        self.stopOutStrategy = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOATrader| { &m.ctidTraderAccountId },
            |m: &mut ProtoOATrader| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &ProtoOATrader| { &m.balance },
            |m: &mut ProtoOATrader| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balanceVersion",
            |m: &ProtoOATrader| { &m.balanceVersion },
            |m: &mut ProtoOATrader| { &mut m.balanceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "managerBonus",
            |m: &ProtoOATrader| { &m.managerBonus },
            |m: &mut ProtoOATrader| { &mut m.managerBonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ibBonus",
            |m: &ProtoOATrader| { &m.ibBonus },
            |m: &mut ProtoOATrader| { &mut m.ibBonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "nonWithdrawableBonus",
            |m: &ProtoOATrader| { &m.nonWithdrawableBonus },
            |m: &mut ProtoOATrader| { &mut m.nonWithdrawableBonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accessRights",
            |m: &ProtoOATrader| { &m.accessRights },
            |m: &mut ProtoOATrader| { &mut m.accessRights },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "depositAssetId",
            |m: &ProtoOATrader| { &m.depositAssetId },
            |m: &mut ProtoOATrader| { &mut m.depositAssetId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swapFree",
            |m: &ProtoOATrader| { &m.swapFree },
            |m: &mut ProtoOATrader| { &mut m.swapFree },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leverageInCents",
            |m: &ProtoOATrader| { &m.leverageInCents },
            |m: &mut ProtoOATrader| { &mut m.leverageInCents },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "totalMarginCalculationType",
            |m: &ProtoOATrader| { &m.totalMarginCalculationType },
            |m: &mut ProtoOATrader| { &mut m.totalMarginCalculationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maxLeverage",
            |m: &ProtoOATrader| { &m.maxLeverage },
            |m: &mut ProtoOATrader| { &mut m.maxLeverage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "frenchRisk",
            |m: &ProtoOATrader| { &m.frenchRisk },
            |m: &mut ProtoOATrader| { &mut m.frenchRisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "traderLogin",
            |m: &ProtoOATrader| { &m.traderLogin },
            |m: &mut ProtoOATrader| { &mut m.traderLogin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountType",
            |m: &ProtoOATrader| { &m.accountType },
            |m: &mut ProtoOATrader| { &mut m.accountType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brokerName",
            |m: &ProtoOATrader| { &m.brokerName },
            |m: &mut ProtoOATrader| { &mut m.brokerName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "registrationTimestamp",
            |m: &ProtoOATrader| { &m.registrationTimestamp },
            |m: &mut ProtoOATrader| { &mut m.registrationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isLimitedRisk",
            |m: &ProtoOATrader| { &m.isLimitedRisk },
            |m: &mut ProtoOATrader| { &mut m.isLimitedRisk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limitedRiskMarginCalculationStrategy",
            |m: &ProtoOATrader| { &m.limitedRiskMarginCalculationStrategy },
            |m: &mut ProtoOATrader| { &mut m.limitedRiskMarginCalculationStrategy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOATrader| { &m.moneyDigits },
            |m: &mut ProtoOATrader| { &mut m.moneyDigits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fairStopOut",
            |m: &ProtoOATrader| { &m.fairStopOut },
            |m: &mut ProtoOATrader| { &mut m.fairStopOut },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopOutStrategy",
            |m: &ProtoOATrader| { &m.stopOutStrategy },
            |m: &mut ProtoOATrader| { &mut m.stopOutStrategy },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATrader>(
            "ProtoOATrader",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATrader {
    const NAME: &'static str = "ProtoOATrader";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        if self.balance.is_none() {
            return false;
        }
        if self.depositAssetId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.balance = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.balanceVersion = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.managerBonus = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.ibBonus = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.nonWithdrawableBonus = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.accessRights = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.depositAssetId = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.swapFree = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.leverageInCents = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.totalMarginCalculationType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.maxLeverage = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.frenchRisk = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.traderLogin = ::std::option::Option::Some(is.read_int64()?);
                },
                120 => {
                    self.accountType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                130 => {
                    self.brokerName = ::std::option::Option::Some(is.read_string()?);
                },
                136 => {
                    self.registrationTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                144 => {
                    self.isLimitedRisk = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.limitedRiskMarginCalculationStrategy = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                160 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.fairStopOut = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.stopOutStrategy = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.balanceVersion {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.managerBonus {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.ibBonus {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.nonWithdrawableBonus {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.accessRights {
            my_size += ::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.depositAssetId {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.swapFree {
            my_size += 1 + 1;
        }
        if let Some(v) = self.leverageInCents {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.totalMarginCalculationType {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.maxLeverage {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.frenchRisk {
            my_size += 1 + 1;
        }
        if let Some(v) = self.traderLogin {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.accountType {
            my_size += ::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.brokerName.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(v) = self.registrationTimestamp {
            my_size += ::protobuf::rt::int64_size(17, v);
        }
        if let Some(v) = self.isLimitedRisk {
            my_size += 2 + 1;
        }
        if let Some(v) = self.limitedRiskMarginCalculationStrategy {
            my_size += ::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.fairStopOut {
            my_size += 2 + 1;
        }
        if let Some(v) = self.stopOutStrategy {
            my_size += ::protobuf::rt::int32_size(22, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ctidTraderAccountId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.balanceVersion {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.managerBonus {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.ibBonus {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.nonWithdrawableBonus {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.accessRights {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.depositAssetId {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.swapFree {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.leverageInCents {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.totalMarginCalculationType {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.maxLeverage {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.frenchRisk {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.traderLogin {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.accountType {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.brokerName.as_ref() {
            os.write_string(16, v)?;
        }
        if let Some(v) = self.registrationTimestamp {
            os.write_int64(17, v)?;
        }
        if let Some(v) = self.isLimitedRisk {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.limitedRiskMarginCalculationStrategy {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.fairStopOut {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.stopOutStrategy {
            os.write_enum(22, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATrader {
        ProtoOATrader::new()
    }

    fn clear(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.balanceVersion = ::std::option::Option::None;
        self.managerBonus = ::std::option::Option::None;
        self.ibBonus = ::std::option::Option::None;
        self.nonWithdrawableBonus = ::std::option::Option::None;
        self.accessRights = ::std::option::Option::None;
        self.depositAssetId = ::std::option::Option::None;
        self.swapFree = ::std::option::Option::None;
        self.leverageInCents = ::std::option::Option::None;
        self.totalMarginCalculationType = ::std::option::Option::None;
        self.maxLeverage = ::std::option::Option::None;
        self.frenchRisk = ::std::option::Option::None;
        self.traderLogin = ::std::option::Option::None;
        self.accountType = ::std::option::Option::None;
        self.brokerName = ::std::option::Option::None;
        self.registrationTimestamp = ::std::option::Option::None;
        self.isLimitedRisk = ::std::option::Option::None;
        self.limitedRiskMarginCalculationStrategy = ::std::option::Option::None;
        self.moneyDigits = ::std::option::Option::None;
        self.fairStopOut = ::std::option::Option::None;
        self.stopOutStrategy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATrader {
        static instance: ProtoOATrader = ProtoOATrader {
            ctidTraderAccountId: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            balanceVersion: ::std::option::Option::None,
            managerBonus: ::std::option::Option::None,
            ibBonus: ::std::option::Option::None,
            nonWithdrawableBonus: ::std::option::Option::None,
            accessRights: ::std::option::Option::None,
            depositAssetId: ::std::option::Option::None,
            swapFree: ::std::option::Option::None,
            leverageInCents: ::std::option::Option::None,
            totalMarginCalculationType: ::std::option::Option::None,
            maxLeverage: ::std::option::Option::None,
            frenchRisk: ::std::option::Option::None,
            traderLogin: ::std::option::Option::None,
            accountType: ::std::option::Option::None,
            brokerName: ::std::option::Option::None,
            registrationTimestamp: ::std::option::Option::None,
            isLimitedRisk: ::std::option::Option::None,
            limitedRiskMarginCalculationStrategy: ::std::option::Option::None,
            moneyDigits: ::std::option::Option::None,
            fairStopOut: ::std::option::Option::None,
            stopOutStrategy: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATrader {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATrader").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATrader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATrader {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAPosition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAPosition {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAPosition.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.tradeData)
    pub tradeData: ::protobuf::MessageField<ProtoOATradeData>,
    // @@protoc_insertion_point(field:ProtoOAPosition.positionStatus)
    pub positionStatus: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAPositionStatus>>,
    // @@protoc_insertion_point(field:ProtoOAPosition.swap)
    pub swap: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.price)
    pub price: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.stopLoss)
    pub stopLoss: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.takeProfit)
    pub takeProfit: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.utcLastUpdateTimestamp)
    pub utcLastUpdateTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.commission)
    pub commission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.marginRate)
    pub marginRate: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.mirroringCommission)
    pub mirroringCommission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.guaranteedStopLoss)
    pub guaranteedStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAPosition.usedMargin)
    pub usedMargin: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOAPosition.stopLossTriggerMethod)
    pub stopLossTriggerMethod: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAOrderTriggerMethod>>,
    // @@protoc_insertion_point(field:ProtoOAPosition.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOAPosition.trailingStopLoss)
    pub trailingStopLoss: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAPosition.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAPosition {
    fn default() -> &'a ProtoOAPosition {
        <ProtoOAPosition as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAPosition {
    pub fn new() -> ProtoOAPosition {
        ::std::default::Default::default()
    }

    // required int64 positionId = 1;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // required .ProtoOAPositionStatus positionStatus = 3;

    pub fn positionStatus(&self) -> ProtoOAPositionStatus {
        match self.positionStatus {
            Some(e) => e.enum_value_or(ProtoOAPositionStatus::POSITION_STATUS_OPEN),
            None => ProtoOAPositionStatus::POSITION_STATUS_OPEN,
        }
    }

    pub fn clear_positionStatus(&mut self) {
        self.positionStatus = ::std::option::Option::None;
    }

    pub fn has_positionStatus(&self) -> bool {
        self.positionStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionStatus(&mut self, v: ProtoOAPositionStatus) {
        self.positionStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 swap = 4;

    pub fn swap(&self) -> i64 {
        self.swap.unwrap_or(0)
    }

    pub fn clear_swap(&mut self) {
        self.swap = ::std::option::Option::None;
    }

    pub fn has_swap(&self) -> bool {
        self.swap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: i64) {
        self.swap = ::std::option::Option::Some(v);
    }

    // optional double price = 5;

    pub fn price(&self) -> f64 {
        self.price.unwrap_or(0.)
    }

    pub fn clear_price(&mut self) {
        self.price = ::std::option::Option::None;
    }

    pub fn has_price(&self) -> bool {
        self.price.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price(&mut self, v: f64) {
        self.price = ::std::option::Option::Some(v);
    }

    // optional double stopLoss = 6;

    pub fn stopLoss(&self) -> f64 {
        self.stopLoss.unwrap_or(0.)
    }

    pub fn clear_stopLoss(&mut self) {
        self.stopLoss = ::std::option::Option::None;
    }

    pub fn has_stopLoss(&self) -> bool {
        self.stopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLoss(&mut self, v: f64) {
        self.stopLoss = ::std::option::Option::Some(v);
    }

    // optional double takeProfit = 7;

    pub fn takeProfit(&self) -> f64 {
        self.takeProfit.unwrap_or(0.)
    }

    pub fn clear_takeProfit(&mut self) {
        self.takeProfit = ::std::option::Option::None;
    }

    pub fn has_takeProfit(&self) -> bool {
        self.takeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_takeProfit(&mut self, v: f64) {
        self.takeProfit = ::std::option::Option::Some(v);
    }

    // optional int64 utcLastUpdateTimestamp = 8;

    pub fn utcLastUpdateTimestamp(&self) -> i64 {
        self.utcLastUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_utcLastUpdateTimestamp(&mut self) {
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_utcLastUpdateTimestamp(&self) -> bool {
        self.utcLastUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcLastUpdateTimestamp(&mut self, v: i64) {
        self.utcLastUpdateTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 commission = 9;

    pub fn commission(&self) -> i64 {
        self.commission.unwrap_or(0)
    }

    pub fn clear_commission(&mut self) {
        self.commission = ::std::option::Option::None;
    }

    pub fn has_commission(&self) -> bool {
        self.commission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commission(&mut self, v: i64) {
        self.commission = ::std::option::Option::Some(v);
    }

    // optional double marginRate = 10;

    pub fn marginRate(&self) -> f64 {
        self.marginRate.unwrap_or(0.)
    }

    pub fn clear_marginRate(&mut self) {
        self.marginRate = ::std::option::Option::None;
    }

    pub fn has_marginRate(&self) -> bool {
        self.marginRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marginRate(&mut self, v: f64) {
        self.marginRate = ::std::option::Option::Some(v);
    }

    // optional int64 mirroringCommission = 11;

    pub fn mirroringCommission(&self) -> i64 {
        self.mirroringCommission.unwrap_or(0)
    }

    pub fn clear_mirroringCommission(&mut self) {
        self.mirroringCommission = ::std::option::Option::None;
    }

    pub fn has_mirroringCommission(&self) -> bool {
        self.mirroringCommission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mirroringCommission(&mut self, v: i64) {
        self.mirroringCommission = ::std::option::Option::Some(v);
    }

    // optional bool guaranteedStopLoss = 12;

    pub fn guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.unwrap_or(false)
    }

    pub fn clear_guaranteedStopLoss(&mut self) {
        self.guaranteedStopLoss = ::std::option::Option::None;
    }

    pub fn has_guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guaranteedStopLoss(&mut self, v: bool) {
        self.guaranteedStopLoss = ::std::option::Option::Some(v);
    }

    // optional uint64 usedMargin = 13;

    pub fn usedMargin(&self) -> u64 {
        self.usedMargin.unwrap_or(0)
    }

    pub fn clear_usedMargin(&mut self) {
        self.usedMargin = ::std::option::Option::None;
    }

    pub fn has_usedMargin(&self) -> bool {
        self.usedMargin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_usedMargin(&mut self, v: u64) {
        self.usedMargin = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAOrderTriggerMethod stopLossTriggerMethod = 14;

    pub fn stopLossTriggerMethod(&self) -> ProtoOAOrderTriggerMethod {
        match self.stopLossTriggerMethod {
            Some(e) => e.enum_value_or(ProtoOAOrderTriggerMethod::TRADE),
            None => ProtoOAOrderTriggerMethod::TRADE,
        }
    }

    pub fn clear_stopLossTriggerMethod(&mut self) {
        self.stopLossTriggerMethod = ::std::option::Option::None;
    }

    pub fn has_stopLossTriggerMethod(&self) -> bool {
        self.stopLossTriggerMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLossTriggerMethod(&mut self, v: ProtoOAOrderTriggerMethod) {
        self.stopLossTriggerMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 moneyDigits = 15;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    // optional bool trailingStopLoss = 16;

    pub fn trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.unwrap_or(false)
    }

    pub fn clear_trailingStopLoss(&mut self) {
        self.trailingStopLoss = ::std::option::Option::None;
    }

    pub fn has_trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailingStopLoss(&mut self, v: bool) {
        self.trailingStopLoss = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAPosition| { &m.positionId },
            |m: &mut ProtoOAPosition| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoOATradeData>(
            "tradeData",
            |m: &ProtoOAPosition| { &m.tradeData },
            |m: &mut ProtoOAPosition| { &mut m.tradeData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionStatus",
            |m: &ProtoOAPosition| { &m.positionStatus },
            |m: &mut ProtoOAPosition| { &mut m.positionStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swap",
            |m: &ProtoOAPosition| { &m.swap },
            |m: &mut ProtoOAPosition| { &mut m.swap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "price",
            |m: &ProtoOAPosition| { &m.price },
            |m: &mut ProtoOAPosition| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLoss",
            |m: &ProtoOAPosition| { &m.stopLoss },
            |m: &mut ProtoOAPosition| { &mut m.stopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "takeProfit",
            |m: &ProtoOAPosition| { &m.takeProfit },
            |m: &mut ProtoOAPosition| { &mut m.takeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcLastUpdateTimestamp",
            |m: &ProtoOAPosition| { &m.utcLastUpdateTimestamp },
            |m: &mut ProtoOAPosition| { &mut m.utcLastUpdateTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commission",
            |m: &ProtoOAPosition| { &m.commission },
            |m: &mut ProtoOAPosition| { &mut m.commission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "marginRate",
            |m: &ProtoOAPosition| { &m.marginRate },
            |m: &mut ProtoOAPosition| { &mut m.marginRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mirroringCommission",
            |m: &ProtoOAPosition| { &m.mirroringCommission },
            |m: &mut ProtoOAPosition| { &mut m.mirroringCommission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guaranteedStopLoss",
            |m: &ProtoOAPosition| { &m.guaranteedStopLoss },
            |m: &mut ProtoOAPosition| { &mut m.guaranteedStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "usedMargin",
            |m: &ProtoOAPosition| { &m.usedMargin },
            |m: &mut ProtoOAPosition| { &mut m.usedMargin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLossTriggerMethod",
            |m: &ProtoOAPosition| { &m.stopLossTriggerMethod },
            |m: &mut ProtoOAPosition| { &mut m.stopLossTriggerMethod },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOAPosition| { &m.moneyDigits },
            |m: &mut ProtoOAPosition| { &mut m.moneyDigits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailingStopLoss",
            |m: &ProtoOAPosition| { &m.trailingStopLoss },
            |m: &mut ProtoOAPosition| { &mut m.trailingStopLoss },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAPosition>(
            "ProtoOAPosition",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAPosition {
    const NAME: &'static str = "ProtoOAPosition";

    fn is_initialized(&self) -> bool {
        if self.positionId.is_none() {
            return false;
        }
        if self.tradeData.is_none() {
            return false;
        }
        if self.positionStatus.is_none() {
            return false;
        }
        if self.swap.is_none() {
            return false;
        }
        for v in &self.tradeData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tradeData)?;
                },
                24 => {
                    self.positionStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.swap = ::std::option::Option::Some(is.read_int64()?);
                },
                41 => {
                    self.price = ::std::option::Option::Some(is.read_double()?);
                },
                49 => {
                    self.stopLoss = ::std::option::Option::Some(is.read_double()?);
                },
                57 => {
                    self.takeProfit = ::std::option::Option::Some(is.read_double()?);
                },
                64 => {
                    self.utcLastUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.commission = ::std::option::Option::Some(is.read_int64()?);
                },
                81 => {
                    self.marginRate = ::std::option::Option::Some(is.read_double()?);
                },
                88 => {
                    self.mirroringCommission = ::std::option::Option::Some(is.read_int64()?);
                },
                96 => {
                    self.guaranteedStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.usedMargin = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.stopLossTriggerMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                120 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.trailingStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.tradeData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.positionStatus {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.swap {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.price {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stopLoss {
            my_size += 1 + 8;
        }
        if let Some(v) = self.takeProfit {
            my_size += 1 + 8;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.commission {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.marginRate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.mirroringCommission {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        if let Some(v) = self.guaranteedStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.usedMargin {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        if let Some(v) = self.stopLossTriggerMethod {
            my_size += ::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.trailingStopLoss {
            my_size += 2 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.positionId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.tradeData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.positionStatus {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.swap {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.price {
            os.write_double(5, v)?;
        }
        if let Some(v) = self.stopLoss {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.takeProfit {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.commission {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.marginRate {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.mirroringCommission {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.guaranteedStopLoss {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.usedMargin {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.stopLossTriggerMethod {
            os.write_enum(14, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.trailingStopLoss {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAPosition {
        ProtoOAPosition::new()
    }

    fn clear(&mut self) {
        self.positionId = ::std::option::Option::None;
        self.tradeData.clear();
        self.positionStatus = ::std::option::Option::None;
        self.swap = ::std::option::Option::None;
        self.price = ::std::option::Option::None;
        self.stopLoss = ::std::option::Option::None;
        self.takeProfit = ::std::option::Option::None;
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
        self.commission = ::std::option::Option::None;
        self.marginRate = ::std::option::Option::None;
        self.mirroringCommission = ::std::option::Option::None;
        self.guaranteedStopLoss = ::std::option::Option::None;
        self.usedMargin = ::std::option::Option::None;
        self.stopLossTriggerMethod = ::std::option::Option::None;
        self.moneyDigits = ::std::option::Option::None;
        self.trailingStopLoss = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAPosition {
        static instance: ProtoOAPosition = ProtoOAPosition {
            positionId: ::std::option::Option::None,
            tradeData: ::protobuf::MessageField::none(),
            positionStatus: ::std::option::Option::None,
            swap: ::std::option::Option::None,
            price: ::std::option::Option::None,
            stopLoss: ::std::option::Option::None,
            takeProfit: ::std::option::Option::None,
            utcLastUpdateTimestamp: ::std::option::Option::None,
            commission: ::std::option::Option::None,
            marginRate: ::std::option::Option::None,
            mirroringCommission: ::std::option::Option::None,
            guaranteedStopLoss: ::std::option::Option::None,
            usedMargin: ::std::option::Option::None,
            stopLossTriggerMethod: ::std::option::Option::None,
            moneyDigits: ::std::option::Option::None,
            trailingStopLoss: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAPosition {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAPosition").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAPosition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAPosition {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATradeData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATradeData {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATradeData.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATradeData.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATradeData.tradeSide)
    pub tradeSide: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOATradeSide>>,
    // @@protoc_insertion_point(field:ProtoOATradeData.openTimestamp)
    pub openTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATradeData.label)
    pub label: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOATradeData.guaranteedStopLoss)
    pub guaranteedStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOATradeData.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOATradeData.measurementUnits)
    pub measurementUnits: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOATradeData.closeTimestamp)
    pub closeTimestamp: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATradeData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATradeData {
    fn default() -> &'a ProtoOATradeData {
        <ProtoOATradeData as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATradeData {
    pub fn new() -> ProtoOATradeData {
        ::std::default::Default::default()
    }

    // required int64 symbolId = 1;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // required int64 volume = 2;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // required .ProtoOATradeSide tradeSide = 3;

    pub fn tradeSide(&self) -> ProtoOATradeSide {
        match self.tradeSide {
            Some(e) => e.enum_value_or(ProtoOATradeSide::BUY),
            None => ProtoOATradeSide::BUY,
        }
    }

    pub fn clear_tradeSide(&mut self) {
        self.tradeSide = ::std::option::Option::None;
    }

    pub fn has_tradeSide(&self) -> bool {
        self.tradeSide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tradeSide(&mut self, v: ProtoOATradeSide) {
        self.tradeSide = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 openTimestamp = 4;

    pub fn openTimestamp(&self) -> i64 {
        self.openTimestamp.unwrap_or(0)
    }

    pub fn clear_openTimestamp(&mut self) {
        self.openTimestamp = ::std::option::Option::None;
    }

    pub fn has_openTimestamp(&self) -> bool {
        self.openTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_openTimestamp(&mut self, v: i64) {
        self.openTimestamp = ::std::option::Option::Some(v);
    }

    // optional string label = 5;

    pub fn label(&self) -> &str {
        match self.label.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: ::std::string::String) {
        self.label = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label(&mut self) -> &mut ::std::string::String {
        if self.label.is_none() {
            self.label = ::std::option::Option::Some(::std::string::String::new());
        }
        self.label.as_mut().unwrap()
    }

    // Take field
    pub fn take_label(&mut self) -> ::std::string::String {
        self.label.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool guaranteedStopLoss = 6;

    pub fn guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.unwrap_or(false)
    }

    pub fn clear_guaranteedStopLoss(&mut self) {
        self.guaranteedStopLoss = ::std::option::Option::None;
    }

    pub fn has_guaranteedStopLoss(&self) -> bool {
        self.guaranteedStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guaranteedStopLoss(&mut self, v: bool) {
        self.guaranteedStopLoss = ::std::option::Option::Some(v);
    }

    // optional string comment = 7;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string measurementUnits = 8;

    pub fn measurementUnits(&self) -> &str {
        match self.measurementUnits.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_measurementUnits(&mut self) {
        self.measurementUnits = ::std::option::Option::None;
    }

    pub fn has_measurementUnits(&self) -> bool {
        self.measurementUnits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_measurementUnits(&mut self, v: ::std::string::String) {
        self.measurementUnits = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_measurementUnits(&mut self) -> &mut ::std::string::String {
        if self.measurementUnits.is_none() {
            self.measurementUnits = ::std::option::Option::Some(::std::string::String::new());
        }
        self.measurementUnits.as_mut().unwrap()
    }

    // Take field
    pub fn take_measurementUnits(&mut self) -> ::std::string::String {
        self.measurementUnits.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 closeTimestamp = 9;

    pub fn closeTimestamp(&self) -> u64 {
        self.closeTimestamp.unwrap_or(0)
    }

    pub fn clear_closeTimestamp(&mut self) {
        self.closeTimestamp = ::std::option::Option::None;
    }

    pub fn has_closeTimestamp(&self) -> bool {
        self.closeTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closeTimestamp(&mut self, v: u64) {
        self.closeTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOATradeData| { &m.symbolId },
            |m: &mut ProtoOATradeData| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOATradeData| { &m.volume },
            |m: &mut ProtoOATradeData| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tradeSide",
            |m: &ProtoOATradeData| { &m.tradeSide },
            |m: &mut ProtoOATradeData| { &mut m.tradeSide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "openTimestamp",
            |m: &ProtoOATradeData| { &m.openTimestamp },
            |m: &mut ProtoOATradeData| { &mut m.openTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &ProtoOATradeData| { &m.label },
            |m: &mut ProtoOATradeData| { &mut m.label },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "guaranteedStopLoss",
            |m: &ProtoOATradeData| { &m.guaranteedStopLoss },
            |m: &mut ProtoOATradeData| { &mut m.guaranteedStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "comment",
            |m: &ProtoOATradeData| { &m.comment },
            |m: &mut ProtoOATradeData| { &mut m.comment },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "measurementUnits",
            |m: &ProtoOATradeData| { &m.measurementUnits },
            |m: &mut ProtoOATradeData| { &mut m.measurementUnits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "closeTimestamp",
            |m: &ProtoOATradeData| { &m.closeTimestamp },
            |m: &mut ProtoOATradeData| { &mut m.closeTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATradeData>(
            "ProtoOATradeData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATradeData {
    const NAME: &'static str = "ProtoOATradeData";

    fn is_initialized(&self) -> bool {
        if self.symbolId.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        if self.tradeSide.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.tradeSide = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.openTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                42 => {
                    self.label = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.guaranteedStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.measurementUnits = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.closeTimestamp = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.tradeSide {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.openTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.label.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.guaranteedStopLoss {
            my_size += 1 + 1;
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.measurementUnits.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.closeTimestamp {
            my_size += ::protobuf::rt::uint64_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.symbolId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.tradeSide {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.openTimestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.label.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.guaranteedStopLoss {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.measurementUnits.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.closeTimestamp {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATradeData {
        ProtoOATradeData::new()
    }

    fn clear(&mut self) {
        self.symbolId = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.tradeSide = ::std::option::Option::None;
        self.openTimestamp = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.guaranteedStopLoss = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.measurementUnits = ::std::option::Option::None;
        self.closeTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATradeData {
        static instance: ProtoOATradeData = ProtoOATradeData {
            symbolId: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            tradeSide: ::std::option::Option::None,
            openTimestamp: ::std::option::Option::None,
            label: ::std::option::Option::None,
            guaranteedStopLoss: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            measurementUnits: ::std::option::Option::None,
            closeTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATradeData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATradeData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATradeData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATradeData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAOrder {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAOrder.orderId)
    pub orderId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.tradeData)
    pub tradeData: ::protobuf::MessageField<ProtoOATradeData>,
    // @@protoc_insertion_point(field:ProtoOAOrder.orderType)
    pub orderType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAOrderType>>,
    // @@protoc_insertion_point(field:ProtoOAOrder.orderStatus)
    pub orderStatus: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAOrderStatus>>,
    // @@protoc_insertion_point(field:ProtoOAOrder.expirationTimestamp)
    pub expirationTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.executionPrice)
    pub executionPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.executedVolume)
    pub executedVolume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.utcLastUpdateTimestamp)
    pub utcLastUpdateTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.baseSlippagePrice)
    pub baseSlippagePrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.slippageInPoints)
    pub slippageInPoints: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.closingOrder)
    pub closingOrder: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAOrder.limitPrice)
    pub limitPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.stopPrice)
    pub stopPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.stopLoss)
    pub stopLoss: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.takeProfit)
    pub takeProfit: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.clientOrderId)
    pub clientOrderId: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAOrder.timeInForce)
    pub timeInForce: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOATimeInForce>>,
    // @@protoc_insertion_point(field:ProtoOAOrder.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.relativeStopLoss)
    pub relativeStopLoss: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.relativeTakeProfit)
    pub relativeTakeProfit: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAOrder.isStopOut)
    pub isStopOut: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAOrder.trailingStopLoss)
    pub trailingStopLoss: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAOrder.stopTriggerMethod)
    pub stopTriggerMethod: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAOrderTriggerMethod>>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAOrder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAOrder {
    fn default() -> &'a ProtoOAOrder {
        <ProtoOAOrder as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAOrder {
    pub fn new() -> ProtoOAOrder {
        ::std::default::Default::default()
    }

    // required int64 orderId = 1;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // required .ProtoOAOrderType orderType = 3;

    pub fn orderType(&self) -> ProtoOAOrderType {
        match self.orderType {
            Some(e) => e.enum_value_or(ProtoOAOrderType::MARKET),
            None => ProtoOAOrderType::MARKET,
        }
    }

    pub fn clear_orderType(&mut self) {
        self.orderType = ::std::option::Option::None;
    }

    pub fn has_orderType(&self) -> bool {
        self.orderType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderType(&mut self, v: ProtoOAOrderType) {
        self.orderType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .ProtoOAOrderStatus orderStatus = 4;

    pub fn orderStatus(&self) -> ProtoOAOrderStatus {
        match self.orderStatus {
            Some(e) => e.enum_value_or(ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED),
            None => ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED,
        }
    }

    pub fn clear_orderStatus(&mut self) {
        self.orderStatus = ::std::option::Option::None;
    }

    pub fn has_orderStatus(&self) -> bool {
        self.orderStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderStatus(&mut self, v: ProtoOAOrderStatus) {
        self.orderStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 expirationTimestamp = 6;

    pub fn expirationTimestamp(&self) -> i64 {
        self.expirationTimestamp.unwrap_or(0)
    }

    pub fn clear_expirationTimestamp(&mut self) {
        self.expirationTimestamp = ::std::option::Option::None;
    }

    pub fn has_expirationTimestamp(&self) -> bool {
        self.expirationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationTimestamp(&mut self, v: i64) {
        self.expirationTimestamp = ::std::option::Option::Some(v);
    }

    // optional double executionPrice = 7;

    pub fn executionPrice(&self) -> f64 {
        self.executionPrice.unwrap_or(0.)
    }

    pub fn clear_executionPrice(&mut self) {
        self.executionPrice = ::std::option::Option::None;
    }

    pub fn has_executionPrice(&self) -> bool {
        self.executionPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionPrice(&mut self, v: f64) {
        self.executionPrice = ::std::option::Option::Some(v);
    }

    // optional int64 executedVolume = 8;

    pub fn executedVolume(&self) -> i64 {
        self.executedVolume.unwrap_or(0)
    }

    pub fn clear_executedVolume(&mut self) {
        self.executedVolume = ::std::option::Option::None;
    }

    pub fn has_executedVolume(&self) -> bool {
        self.executedVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executedVolume(&mut self, v: i64) {
        self.executedVolume = ::std::option::Option::Some(v);
    }

    // optional int64 utcLastUpdateTimestamp = 9;

    pub fn utcLastUpdateTimestamp(&self) -> i64 {
        self.utcLastUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_utcLastUpdateTimestamp(&mut self) {
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_utcLastUpdateTimestamp(&self) -> bool {
        self.utcLastUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcLastUpdateTimestamp(&mut self, v: i64) {
        self.utcLastUpdateTimestamp = ::std::option::Option::Some(v);
    }

    // optional double baseSlippagePrice = 10;

    pub fn baseSlippagePrice(&self) -> f64 {
        self.baseSlippagePrice.unwrap_or(0.)
    }

    pub fn clear_baseSlippagePrice(&mut self) {
        self.baseSlippagePrice = ::std::option::Option::None;
    }

    pub fn has_baseSlippagePrice(&self) -> bool {
        self.baseSlippagePrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseSlippagePrice(&mut self, v: f64) {
        self.baseSlippagePrice = ::std::option::Option::Some(v);
    }

    // optional int64 slippageInPoints = 11;

    pub fn slippageInPoints(&self) -> i64 {
        self.slippageInPoints.unwrap_or(0)
    }

    pub fn clear_slippageInPoints(&mut self) {
        self.slippageInPoints = ::std::option::Option::None;
    }

    pub fn has_slippageInPoints(&self) -> bool {
        self.slippageInPoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slippageInPoints(&mut self, v: i64) {
        self.slippageInPoints = ::std::option::Option::Some(v);
    }

    // optional bool closingOrder = 12;

    pub fn closingOrder(&self) -> bool {
        self.closingOrder.unwrap_or(false)
    }

    pub fn clear_closingOrder(&mut self) {
        self.closingOrder = ::std::option::Option::None;
    }

    pub fn has_closingOrder(&self) -> bool {
        self.closingOrder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closingOrder(&mut self, v: bool) {
        self.closingOrder = ::std::option::Option::Some(v);
    }

    // optional double limitPrice = 13;

    pub fn limitPrice(&self) -> f64 {
        self.limitPrice.unwrap_or(0.)
    }

    pub fn clear_limitPrice(&mut self) {
        self.limitPrice = ::std::option::Option::None;
    }

    pub fn has_limitPrice(&self) -> bool {
        self.limitPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitPrice(&mut self, v: f64) {
        self.limitPrice = ::std::option::Option::Some(v);
    }

    // optional double stopPrice = 14;

    pub fn stopPrice(&self) -> f64 {
        self.stopPrice.unwrap_or(0.)
    }

    pub fn clear_stopPrice(&mut self) {
        self.stopPrice = ::std::option::Option::None;
    }

    pub fn has_stopPrice(&self) -> bool {
        self.stopPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopPrice(&mut self, v: f64) {
        self.stopPrice = ::std::option::Option::Some(v);
    }

    // optional double stopLoss = 15;

    pub fn stopLoss(&self) -> f64 {
        self.stopLoss.unwrap_or(0.)
    }

    pub fn clear_stopLoss(&mut self) {
        self.stopLoss = ::std::option::Option::None;
    }

    pub fn has_stopLoss(&self) -> bool {
        self.stopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopLoss(&mut self, v: f64) {
        self.stopLoss = ::std::option::Option::Some(v);
    }

    // optional double takeProfit = 16;

    pub fn takeProfit(&self) -> f64 {
        self.takeProfit.unwrap_or(0.)
    }

    pub fn clear_takeProfit(&mut self) {
        self.takeProfit = ::std::option::Option::None;
    }

    pub fn has_takeProfit(&self) -> bool {
        self.takeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_takeProfit(&mut self, v: f64) {
        self.takeProfit = ::std::option::Option::Some(v);
    }

    // optional string clientOrderId = 17;

    pub fn clientOrderId(&self) -> &str {
        match self.clientOrderId.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_clientOrderId(&mut self) {
        self.clientOrderId = ::std::option::Option::None;
    }

    pub fn has_clientOrderId(&self) -> bool {
        self.clientOrderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientOrderId(&mut self, v: ::std::string::String) {
        self.clientOrderId = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientOrderId(&mut self) -> &mut ::std::string::String {
        if self.clientOrderId.is_none() {
            self.clientOrderId = ::std::option::Option::Some(::std::string::String::new());
        }
        self.clientOrderId.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientOrderId(&mut self) -> ::std::string::String {
        self.clientOrderId.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ProtoOATimeInForce timeInForce = 18;

    pub fn timeInForce(&self) -> ProtoOATimeInForce {
        match self.timeInForce {
            Some(e) => e.enum_value_or(ProtoOATimeInForce::IMMEDIATE_OR_CANCEL),
            None => ProtoOATimeInForce::IMMEDIATE_OR_CANCEL,
        }
    }

    pub fn clear_timeInForce(&mut self) {
        self.timeInForce = ::std::option::Option::None;
    }

    pub fn has_timeInForce(&self) -> bool {
        self.timeInForce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeInForce(&mut self, v: ProtoOATimeInForce) {
        self.timeInForce = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 positionId = 19;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // optional int64 relativeStopLoss = 20;

    pub fn relativeStopLoss(&self) -> i64 {
        self.relativeStopLoss.unwrap_or(0)
    }

    pub fn clear_relativeStopLoss(&mut self) {
        self.relativeStopLoss = ::std::option::Option::None;
    }

    pub fn has_relativeStopLoss(&self) -> bool {
        self.relativeStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relativeStopLoss(&mut self, v: i64) {
        self.relativeStopLoss = ::std::option::Option::Some(v);
    }

    // optional int64 relativeTakeProfit = 21;

    pub fn relativeTakeProfit(&self) -> i64 {
        self.relativeTakeProfit.unwrap_or(0)
    }

    pub fn clear_relativeTakeProfit(&mut self) {
        self.relativeTakeProfit = ::std::option::Option::None;
    }

    pub fn has_relativeTakeProfit(&self) -> bool {
        self.relativeTakeProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relativeTakeProfit(&mut self, v: i64) {
        self.relativeTakeProfit = ::std::option::Option::Some(v);
    }

    // optional bool isStopOut = 22;

    pub fn isStopOut(&self) -> bool {
        self.isStopOut.unwrap_or(false)
    }

    pub fn clear_isStopOut(&mut self) {
        self.isStopOut = ::std::option::Option::None;
    }

    pub fn has_isStopOut(&self) -> bool {
        self.isStopOut.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isStopOut(&mut self, v: bool) {
        self.isStopOut = ::std::option::Option::Some(v);
    }

    // optional bool trailingStopLoss = 23;

    pub fn trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.unwrap_or(false)
    }

    pub fn clear_trailingStopLoss(&mut self) {
        self.trailingStopLoss = ::std::option::Option::None;
    }

    pub fn has_trailingStopLoss(&self) -> bool {
        self.trailingStopLoss.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailingStopLoss(&mut self, v: bool) {
        self.trailingStopLoss = ::std::option::Option::Some(v);
    }

    // optional .ProtoOAOrderTriggerMethod stopTriggerMethod = 24;

    pub fn stopTriggerMethod(&self) -> ProtoOAOrderTriggerMethod {
        match self.stopTriggerMethod {
            Some(e) => e.enum_value_or(ProtoOAOrderTriggerMethod::TRADE),
            None => ProtoOAOrderTriggerMethod::TRADE,
        }
    }

    pub fn clear_stopTriggerMethod(&mut self) {
        self.stopTriggerMethod = ::std::option::Option::None;
    }

    pub fn has_stopTriggerMethod(&self) -> bool {
        self.stopTriggerMethod.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stopTriggerMethod(&mut self, v: ProtoOAOrderTriggerMethod) {
        self.stopTriggerMethod = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(23);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOAOrder| { &m.orderId },
            |m: &mut ProtoOAOrder| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoOATradeData>(
            "tradeData",
            |m: &ProtoOAOrder| { &m.tradeData },
            |m: &mut ProtoOAOrder| { &mut m.tradeData },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderType",
            |m: &ProtoOAOrder| { &m.orderType },
            |m: &mut ProtoOAOrder| { &mut m.orderType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderStatus",
            |m: &ProtoOAOrder| { &m.orderStatus },
            |m: &mut ProtoOAOrder| { &mut m.orderStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expirationTimestamp",
            |m: &ProtoOAOrder| { &m.expirationTimestamp },
            |m: &mut ProtoOAOrder| { &mut m.expirationTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executionPrice",
            |m: &ProtoOAOrder| { &m.executionPrice },
            |m: &mut ProtoOAOrder| { &mut m.executionPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executedVolume",
            |m: &ProtoOAOrder| { &m.executedVolume },
            |m: &mut ProtoOAOrder| { &mut m.executedVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcLastUpdateTimestamp",
            |m: &ProtoOAOrder| { &m.utcLastUpdateTimestamp },
            |m: &mut ProtoOAOrder| { &mut m.utcLastUpdateTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseSlippagePrice",
            |m: &ProtoOAOrder| { &m.baseSlippagePrice },
            |m: &mut ProtoOAOrder| { &mut m.baseSlippagePrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "slippageInPoints",
            |m: &ProtoOAOrder| { &m.slippageInPoints },
            |m: &mut ProtoOAOrder| { &mut m.slippageInPoints },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "closingOrder",
            |m: &ProtoOAOrder| { &m.closingOrder },
            |m: &mut ProtoOAOrder| { &mut m.closingOrder },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "limitPrice",
            |m: &ProtoOAOrder| { &m.limitPrice },
            |m: &mut ProtoOAOrder| { &mut m.limitPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopPrice",
            |m: &ProtoOAOrder| { &m.stopPrice },
            |m: &mut ProtoOAOrder| { &mut m.stopPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopLoss",
            |m: &ProtoOAOrder| { &m.stopLoss },
            |m: &mut ProtoOAOrder| { &mut m.stopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "takeProfit",
            |m: &ProtoOAOrder| { &m.takeProfit },
            |m: &mut ProtoOAOrder| { &mut m.takeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "clientOrderId",
            |m: &ProtoOAOrder| { &m.clientOrderId },
            |m: &mut ProtoOAOrder| { &mut m.clientOrderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeInForce",
            |m: &ProtoOAOrder| { &m.timeInForce },
            |m: &mut ProtoOAOrder| { &mut m.timeInForce },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAOrder| { &m.positionId },
            |m: &mut ProtoOAOrder| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relativeStopLoss",
            |m: &ProtoOAOrder| { &m.relativeStopLoss },
            |m: &mut ProtoOAOrder| { &mut m.relativeStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "relativeTakeProfit",
            |m: &ProtoOAOrder| { &m.relativeTakeProfit },
            |m: &mut ProtoOAOrder| { &mut m.relativeTakeProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isStopOut",
            |m: &ProtoOAOrder| { &m.isStopOut },
            |m: &mut ProtoOAOrder| { &mut m.isStopOut },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "trailingStopLoss",
            |m: &ProtoOAOrder| { &m.trailingStopLoss },
            |m: &mut ProtoOAOrder| { &mut m.trailingStopLoss },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stopTriggerMethod",
            |m: &ProtoOAOrder| { &m.stopTriggerMethod },
            |m: &mut ProtoOAOrder| { &mut m.stopTriggerMethod },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAOrder>(
            "ProtoOAOrder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAOrder {
    const NAME: &'static str = "ProtoOAOrder";

    fn is_initialized(&self) -> bool {
        if self.orderId.is_none() {
            return false;
        }
        if self.tradeData.is_none() {
            return false;
        }
        if self.orderType.is_none() {
            return false;
        }
        if self.orderStatus.is_none() {
            return false;
        }
        for v in &self.tradeData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tradeData)?;
                },
                24 => {
                    self.orderType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.orderStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.expirationTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                57 => {
                    self.executionPrice = ::std::option::Option::Some(is.read_double()?);
                },
                64 => {
                    self.executedVolume = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.utcLastUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                81 => {
                    self.baseSlippagePrice = ::std::option::Option::Some(is.read_double()?);
                },
                88 => {
                    self.slippageInPoints = ::std::option::Option::Some(is.read_int64()?);
                },
                96 => {
                    self.closingOrder = ::std::option::Option::Some(is.read_bool()?);
                },
                105 => {
                    self.limitPrice = ::std::option::Option::Some(is.read_double()?);
                },
                113 => {
                    self.stopPrice = ::std::option::Option::Some(is.read_double()?);
                },
                121 => {
                    self.stopLoss = ::std::option::Option::Some(is.read_double()?);
                },
                129 => {
                    self.takeProfit = ::std::option::Option::Some(is.read_double()?);
                },
                138 => {
                    self.clientOrderId = ::std::option::Option::Some(is.read_string()?);
                },
                144 => {
                    self.timeInForce = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                152 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                160 => {
                    self.relativeStopLoss = ::std::option::Option::Some(is.read_int64()?);
                },
                168 => {
                    self.relativeTakeProfit = ::std::option::Option::Some(is.read_int64()?);
                },
                176 => {
                    self.isStopOut = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.trailingStopLoss = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.stopTriggerMethod = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.tradeData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.orderType {
            my_size += ::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.orderStatus {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.expirationTimestamp {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.executionPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.executedVolume {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.baseSlippagePrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.slippageInPoints {
            my_size += ::protobuf::rt::int64_size(11, v);
        }
        if let Some(v) = self.closingOrder {
            my_size += 1 + 1;
        }
        if let Some(v) = self.limitPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stopPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stopLoss {
            my_size += 1 + 8;
        }
        if let Some(v) = self.takeProfit {
            my_size += 2 + 8;
        }
        if let Some(v) = self.clientOrderId.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.timeInForce {
            my_size += ::protobuf::rt::int32_size(18, v.value());
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(19, v);
        }
        if let Some(v) = self.relativeStopLoss {
            my_size += ::protobuf::rt::int64_size(20, v);
        }
        if let Some(v) = self.relativeTakeProfit {
            my_size += ::protobuf::rt::int64_size(21, v);
        }
        if let Some(v) = self.isStopOut {
            my_size += 2 + 1;
        }
        if let Some(v) = self.trailingStopLoss {
            my_size += 2 + 1;
        }
        if let Some(v) = self.stopTriggerMethod {
            my_size += ::protobuf::rt::int32_size(24, v.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.orderId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.tradeData.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.orderType {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.orderStatus {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.expirationTimestamp {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.executionPrice {
            os.write_double(7, v)?;
        }
        if let Some(v) = self.executedVolume {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.baseSlippagePrice {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.slippageInPoints {
            os.write_int64(11, v)?;
        }
        if let Some(v) = self.closingOrder {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.limitPrice {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.stopPrice {
            os.write_double(14, v)?;
        }
        if let Some(v) = self.stopLoss {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.takeProfit {
            os.write_double(16, v)?;
        }
        if let Some(v) = self.clientOrderId.as_ref() {
            os.write_string(17, v)?;
        }
        if let Some(v) = self.timeInForce {
            os.write_enum(18, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(19, v)?;
        }
        if let Some(v) = self.relativeStopLoss {
            os.write_int64(20, v)?;
        }
        if let Some(v) = self.relativeTakeProfit {
            os.write_int64(21, v)?;
        }
        if let Some(v) = self.isStopOut {
            os.write_bool(22, v)?;
        }
        if let Some(v) = self.trailingStopLoss {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.stopTriggerMethod {
            os.write_enum(24, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAOrder {
        ProtoOAOrder::new()
    }

    fn clear(&mut self) {
        self.orderId = ::std::option::Option::None;
        self.tradeData.clear();
        self.orderType = ::std::option::Option::None;
        self.orderStatus = ::std::option::Option::None;
        self.expirationTimestamp = ::std::option::Option::None;
        self.executionPrice = ::std::option::Option::None;
        self.executedVolume = ::std::option::Option::None;
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
        self.baseSlippagePrice = ::std::option::Option::None;
        self.slippageInPoints = ::std::option::Option::None;
        self.closingOrder = ::std::option::Option::None;
        self.limitPrice = ::std::option::Option::None;
        self.stopPrice = ::std::option::Option::None;
        self.stopLoss = ::std::option::Option::None;
        self.takeProfit = ::std::option::Option::None;
        self.clientOrderId = ::std::option::Option::None;
        self.timeInForce = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.relativeStopLoss = ::std::option::Option::None;
        self.relativeTakeProfit = ::std::option::Option::None;
        self.isStopOut = ::std::option::Option::None;
        self.trailingStopLoss = ::std::option::Option::None;
        self.stopTriggerMethod = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAOrder {
        static instance: ProtoOAOrder = ProtoOAOrder {
            orderId: ::std::option::Option::None,
            tradeData: ::protobuf::MessageField::none(),
            orderType: ::std::option::Option::None,
            orderStatus: ::std::option::Option::None,
            expirationTimestamp: ::std::option::Option::None,
            executionPrice: ::std::option::Option::None,
            executedVolume: ::std::option::Option::None,
            utcLastUpdateTimestamp: ::std::option::Option::None,
            baseSlippagePrice: ::std::option::Option::None,
            slippageInPoints: ::std::option::Option::None,
            closingOrder: ::std::option::Option::None,
            limitPrice: ::std::option::Option::None,
            stopPrice: ::std::option::Option::None,
            stopLoss: ::std::option::Option::None,
            takeProfit: ::std::option::Option::None,
            clientOrderId: ::std::option::Option::None,
            timeInForce: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            relativeStopLoss: ::std::option::Option::None,
            relativeTakeProfit: ::std::option::Option::None,
            isStopOut: ::std::option::Option::None,
            trailingStopLoss: ::std::option::Option::None,
            stopTriggerMethod: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAOrder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAOrder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAOrder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAOrder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOABonusDepositWithdraw)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOABonusDepositWithdraw {
    // message fields
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.operationType)
    pub operationType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAChangeBonusType>>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.bonusHistoryId)
    pub bonusHistoryId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.managerBonus)
    pub managerBonus: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.managerDelta)
    pub managerDelta: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.ibBonus)
    pub ibBonus: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.ibDelta)
    pub ibDelta: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.changeBonusTimestamp)
    pub changeBonusTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.externalNote)
    pub externalNote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.introducingBrokerId)
    pub introducingBrokerId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOABonusDepositWithdraw.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOABonusDepositWithdraw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOABonusDepositWithdraw {
    fn default() -> &'a ProtoOABonusDepositWithdraw {
        <ProtoOABonusDepositWithdraw as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOABonusDepositWithdraw {
    pub fn new() -> ProtoOABonusDepositWithdraw {
        ::std::default::Default::default()
    }

    // required .ProtoOAChangeBonusType operationType = 1;

    pub fn operationType(&self) -> ProtoOAChangeBonusType {
        match self.operationType {
            Some(e) => e.enum_value_or(ProtoOAChangeBonusType::BONUS_DEPOSIT),
            None => ProtoOAChangeBonusType::BONUS_DEPOSIT,
        }
    }

    pub fn clear_operationType(&mut self) {
        self.operationType = ::std::option::Option::None;
    }

    pub fn has_operationType(&self) -> bool {
        self.operationType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operationType(&mut self, v: ProtoOAChangeBonusType) {
        self.operationType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 bonusHistoryId = 2;

    pub fn bonusHistoryId(&self) -> i64 {
        self.bonusHistoryId.unwrap_or(0)
    }

    pub fn clear_bonusHistoryId(&mut self) {
        self.bonusHistoryId = ::std::option::Option::None;
    }

    pub fn has_bonusHistoryId(&self) -> bool {
        self.bonusHistoryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonusHistoryId(&mut self, v: i64) {
        self.bonusHistoryId = ::std::option::Option::Some(v);
    }

    // required int64 managerBonus = 3;

    pub fn managerBonus(&self) -> i64 {
        self.managerBonus.unwrap_or(0)
    }

    pub fn clear_managerBonus(&mut self) {
        self.managerBonus = ::std::option::Option::None;
    }

    pub fn has_managerBonus(&self) -> bool {
        self.managerBonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_managerBonus(&mut self, v: i64) {
        self.managerBonus = ::std::option::Option::Some(v);
    }

    // required int64 managerDelta = 4;

    pub fn managerDelta(&self) -> i64 {
        self.managerDelta.unwrap_or(0)
    }

    pub fn clear_managerDelta(&mut self) {
        self.managerDelta = ::std::option::Option::None;
    }

    pub fn has_managerDelta(&self) -> bool {
        self.managerDelta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_managerDelta(&mut self, v: i64) {
        self.managerDelta = ::std::option::Option::Some(v);
    }

    // required int64 ibBonus = 5;

    pub fn ibBonus(&self) -> i64 {
        self.ibBonus.unwrap_or(0)
    }

    pub fn clear_ibBonus(&mut self) {
        self.ibBonus = ::std::option::Option::None;
    }

    pub fn has_ibBonus(&self) -> bool {
        self.ibBonus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ibBonus(&mut self, v: i64) {
        self.ibBonus = ::std::option::Option::Some(v);
    }

    // required int64 ibDelta = 6;

    pub fn ibDelta(&self) -> i64 {
        self.ibDelta.unwrap_or(0)
    }

    pub fn clear_ibDelta(&mut self) {
        self.ibDelta = ::std::option::Option::None;
    }

    pub fn has_ibDelta(&self) -> bool {
        self.ibDelta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ibDelta(&mut self, v: i64) {
        self.ibDelta = ::std::option::Option::Some(v);
    }

    // required int64 changeBonusTimestamp = 7;

    pub fn changeBonusTimestamp(&self) -> i64 {
        self.changeBonusTimestamp.unwrap_or(0)
    }

    pub fn clear_changeBonusTimestamp(&mut self) {
        self.changeBonusTimestamp = ::std::option::Option::None;
    }

    pub fn has_changeBonusTimestamp(&self) -> bool {
        self.changeBonusTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeBonusTimestamp(&mut self, v: i64) {
        self.changeBonusTimestamp = ::std::option::Option::Some(v);
    }

    // optional string externalNote = 8;

    pub fn externalNote(&self) -> &str {
        match self.externalNote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_externalNote(&mut self) {
        self.externalNote = ::std::option::Option::None;
    }

    pub fn has_externalNote(&self) -> bool {
        self.externalNote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalNote(&mut self, v: ::std::string::String) {
        self.externalNote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalNote(&mut self) -> &mut ::std::string::String {
        if self.externalNote.is_none() {
            self.externalNote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.externalNote.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalNote(&mut self) -> ::std::string::String {
        self.externalNote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 introducingBrokerId = 9;

    pub fn introducingBrokerId(&self) -> i64 {
        self.introducingBrokerId.unwrap_or(0)
    }

    pub fn clear_introducingBrokerId(&mut self) {
        self.introducingBrokerId = ::std::option::Option::None;
    }

    pub fn has_introducingBrokerId(&self) -> bool {
        self.introducingBrokerId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_introducingBrokerId(&mut self, v: i64) {
        self.introducingBrokerId = ::std::option::Option::Some(v);
    }

    // optional uint32 moneyDigits = 10;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operationType",
            |m: &ProtoOABonusDepositWithdraw| { &m.operationType },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.operationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonusHistoryId",
            |m: &ProtoOABonusDepositWithdraw| { &m.bonusHistoryId },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.bonusHistoryId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "managerBonus",
            |m: &ProtoOABonusDepositWithdraw| { &m.managerBonus },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.managerBonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "managerDelta",
            |m: &ProtoOABonusDepositWithdraw| { &m.managerDelta },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.managerDelta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ibBonus",
            |m: &ProtoOABonusDepositWithdraw| { &m.ibBonus },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.ibBonus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ibDelta",
            |m: &ProtoOABonusDepositWithdraw| { &m.ibDelta },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.ibDelta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changeBonusTimestamp",
            |m: &ProtoOABonusDepositWithdraw| { &m.changeBonusTimestamp },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.changeBonusTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalNote",
            |m: &ProtoOABonusDepositWithdraw| { &m.externalNote },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.externalNote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "introducingBrokerId",
            |m: &ProtoOABonusDepositWithdraw| { &m.introducingBrokerId },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.introducingBrokerId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOABonusDepositWithdraw| { &m.moneyDigits },
            |m: &mut ProtoOABonusDepositWithdraw| { &mut m.moneyDigits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOABonusDepositWithdraw>(
            "ProtoOABonusDepositWithdraw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOABonusDepositWithdraw {
    const NAME: &'static str = "ProtoOABonusDepositWithdraw";

    fn is_initialized(&self) -> bool {
        if self.operationType.is_none() {
            return false;
        }
        if self.bonusHistoryId.is_none() {
            return false;
        }
        if self.managerBonus.is_none() {
            return false;
        }
        if self.managerDelta.is_none() {
            return false;
        }
        if self.ibBonus.is_none() {
            return false;
        }
        if self.ibDelta.is_none() {
            return false;
        }
        if self.changeBonusTimestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operationType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.bonusHistoryId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.managerBonus = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.managerDelta = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.ibBonus = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.ibDelta = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.changeBonusTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                66 => {
                    self.externalNote = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.introducingBrokerId = ::std::option::Option::Some(is.read_int64()?);
                },
                80 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operationType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.bonusHistoryId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.managerBonus {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.managerDelta {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.ibBonus {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.ibDelta {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.changeBonusTimestamp {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.externalNote.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.introducingBrokerId {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operationType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bonusHistoryId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.managerBonus {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.managerDelta {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.ibBonus {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.ibDelta {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.changeBonusTimestamp {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.externalNote.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.introducingBrokerId {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOABonusDepositWithdraw {
        ProtoOABonusDepositWithdraw::new()
    }

    fn clear(&mut self) {
        self.operationType = ::std::option::Option::None;
        self.bonusHistoryId = ::std::option::Option::None;
        self.managerBonus = ::std::option::Option::None;
        self.managerDelta = ::std::option::Option::None;
        self.ibBonus = ::std::option::Option::None;
        self.ibDelta = ::std::option::Option::None;
        self.changeBonusTimestamp = ::std::option::Option::None;
        self.externalNote = ::std::option::Option::None;
        self.introducingBrokerId = ::std::option::Option::None;
        self.moneyDigits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOABonusDepositWithdraw {
        static instance: ProtoOABonusDepositWithdraw = ProtoOABonusDepositWithdraw {
            operationType: ::std::option::Option::None,
            bonusHistoryId: ::std::option::Option::None,
            managerBonus: ::std::option::Option::None,
            managerDelta: ::std::option::Option::None,
            ibBonus: ::std::option::Option::None,
            ibDelta: ::std::option::Option::None,
            changeBonusTimestamp: ::std::option::Option::None,
            externalNote: ::std::option::Option::None,
            introducingBrokerId: ::std::option::Option::None,
            moneyDigits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOABonusDepositWithdraw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOABonusDepositWithdraw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOABonusDepositWithdraw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOABonusDepositWithdraw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADepositWithdraw)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADepositWithdraw {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.operationType)
    pub operationType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOAChangeBalanceType>>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.balanceHistoryId)
    pub balanceHistoryId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.balance)
    pub balance: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.delta)
    pub delta: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.changeBalanceTimestamp)
    pub changeBalanceTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.externalNote)
    pub externalNote: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.balanceVersion)
    pub balanceVersion: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.equity)
    pub equity: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADepositWithdraw.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADepositWithdraw.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADepositWithdraw {
    fn default() -> &'a ProtoOADepositWithdraw {
        <ProtoOADepositWithdraw as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADepositWithdraw {
    pub fn new() -> ProtoOADepositWithdraw {
        ::std::default::Default::default()
    }

    // required .ProtoOAChangeBalanceType operationType = 1;

    pub fn operationType(&self) -> ProtoOAChangeBalanceType {
        match self.operationType {
            Some(e) => e.enum_value_or(ProtoOAChangeBalanceType::BALANCE_DEPOSIT),
            None => ProtoOAChangeBalanceType::BALANCE_DEPOSIT,
        }
    }

    pub fn clear_operationType(&mut self) {
        self.operationType = ::std::option::Option::None;
    }

    pub fn has_operationType(&self) -> bool {
        self.operationType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operationType(&mut self, v: ProtoOAChangeBalanceType) {
        self.operationType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required int64 balanceHistoryId = 2;

    pub fn balanceHistoryId(&self) -> i64 {
        self.balanceHistoryId.unwrap_or(0)
    }

    pub fn clear_balanceHistoryId(&mut self) {
        self.balanceHistoryId = ::std::option::Option::None;
    }

    pub fn has_balanceHistoryId(&self) -> bool {
        self.balanceHistoryId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balanceHistoryId(&mut self, v: i64) {
        self.balanceHistoryId = ::std::option::Option::Some(v);
    }

    // required int64 balance = 3;

    pub fn balance(&self) -> i64 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = ::std::option::Option::Some(v);
    }

    // required int64 delta = 4;

    pub fn delta(&self) -> i64 {
        self.delta.unwrap_or(0)
    }

    pub fn clear_delta(&mut self) {
        self.delta = ::std::option::Option::None;
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i64) {
        self.delta = ::std::option::Option::Some(v);
    }

    // required int64 changeBalanceTimestamp = 5;

    pub fn changeBalanceTimestamp(&self) -> i64 {
        self.changeBalanceTimestamp.unwrap_or(0)
    }

    pub fn clear_changeBalanceTimestamp(&mut self) {
        self.changeBalanceTimestamp = ::std::option::Option::None;
    }

    pub fn has_changeBalanceTimestamp(&self) -> bool {
        self.changeBalanceTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_changeBalanceTimestamp(&mut self, v: i64) {
        self.changeBalanceTimestamp = ::std::option::Option::Some(v);
    }

    // optional string externalNote = 6;

    pub fn externalNote(&self) -> &str {
        match self.externalNote.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_externalNote(&mut self) {
        self.externalNote = ::std::option::Option::None;
    }

    pub fn has_externalNote(&self) -> bool {
        self.externalNote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalNote(&mut self, v: ::std::string::String) {
        self.externalNote = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalNote(&mut self) -> &mut ::std::string::String {
        if self.externalNote.is_none() {
            self.externalNote = ::std::option::Option::Some(::std::string::String::new());
        }
        self.externalNote.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalNote(&mut self) -> ::std::string::String {
        self.externalNote.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 balanceVersion = 7;

    pub fn balanceVersion(&self) -> i64 {
        self.balanceVersion.unwrap_or(0)
    }

    pub fn clear_balanceVersion(&mut self) {
        self.balanceVersion = ::std::option::Option::None;
    }

    pub fn has_balanceVersion(&self) -> bool {
        self.balanceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balanceVersion(&mut self, v: i64) {
        self.balanceVersion = ::std::option::Option::Some(v);
    }

    // optional int64 equity = 8;

    pub fn equity(&self) -> i64 {
        self.equity.unwrap_or(0)
    }

    pub fn clear_equity(&mut self) {
        self.equity = ::std::option::Option::None;
    }

    pub fn has_equity(&self) -> bool {
        self.equity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_equity(&mut self, v: i64) {
        self.equity = ::std::option::Option::Some(v);
    }

    // optional uint32 moneyDigits = 9;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "operationType",
            |m: &ProtoOADepositWithdraw| { &m.operationType },
            |m: &mut ProtoOADepositWithdraw| { &mut m.operationType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balanceHistoryId",
            |m: &ProtoOADepositWithdraw| { &m.balanceHistoryId },
            |m: &mut ProtoOADepositWithdraw| { &mut m.balanceHistoryId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &ProtoOADepositWithdraw| { &m.balance },
            |m: &mut ProtoOADepositWithdraw| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "delta",
            |m: &ProtoOADepositWithdraw| { &m.delta },
            |m: &mut ProtoOADepositWithdraw| { &mut m.delta },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "changeBalanceTimestamp",
            |m: &ProtoOADepositWithdraw| { &m.changeBalanceTimestamp },
            |m: &mut ProtoOADepositWithdraw| { &mut m.changeBalanceTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "externalNote",
            |m: &ProtoOADepositWithdraw| { &m.externalNote },
            |m: &mut ProtoOADepositWithdraw| { &mut m.externalNote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balanceVersion",
            |m: &ProtoOADepositWithdraw| { &m.balanceVersion },
            |m: &mut ProtoOADepositWithdraw| { &mut m.balanceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "equity",
            |m: &ProtoOADepositWithdraw| { &m.equity },
            |m: &mut ProtoOADepositWithdraw| { &mut m.equity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOADepositWithdraw| { &m.moneyDigits },
            |m: &mut ProtoOADepositWithdraw| { &mut m.moneyDigits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADepositWithdraw>(
            "ProtoOADepositWithdraw",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADepositWithdraw {
    const NAME: &'static str = "ProtoOADepositWithdraw";

    fn is_initialized(&self) -> bool {
        if self.operationType.is_none() {
            return false;
        }
        if self.balanceHistoryId.is_none() {
            return false;
        }
        if self.balance.is_none() {
            return false;
        }
        if self.delta.is_none() {
            return false;
        }
        if self.changeBalanceTimestamp.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.operationType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.balanceHistoryId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.balance = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.delta = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.changeBalanceTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.externalNote = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.balanceVersion = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.equity = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.operationType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.balanceHistoryId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.delta {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.changeBalanceTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.externalNote.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.balanceVersion {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.equity {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.operationType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.balanceHistoryId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.delta {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.changeBalanceTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.externalNote.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.balanceVersion {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.equity {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADepositWithdraw {
        ProtoOADepositWithdraw::new()
    }

    fn clear(&mut self) {
        self.operationType = ::std::option::Option::None;
        self.balanceHistoryId = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.delta = ::std::option::Option::None;
        self.changeBalanceTimestamp = ::std::option::Option::None;
        self.externalNote = ::std::option::Option::None;
        self.balanceVersion = ::std::option::Option::None;
        self.equity = ::std::option::Option::None;
        self.moneyDigits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADepositWithdraw {
        static instance: ProtoOADepositWithdraw = ProtoOADepositWithdraw {
            operationType: ::std::option::Option::None,
            balanceHistoryId: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            delta: ::std::option::Option::None,
            changeBalanceTimestamp: ::std::option::Option::None,
            externalNote: ::std::option::Option::None,
            balanceVersion: ::std::option::Option::None,
            equity: ::std::option::Option::None,
            moneyDigits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADepositWithdraw {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADepositWithdraw").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADepositWithdraw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADepositWithdraw {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADeal)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADeal {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADeal.dealId)
    pub dealId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.orderId)
    pub orderId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.filledVolume)
    pub filledVolume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.symbolId)
    pub symbolId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.createTimestamp)
    pub createTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.executionTimestamp)
    pub executionTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.utcLastUpdateTimestamp)
    pub utcLastUpdateTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.executionPrice)
    pub executionPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOADeal.tradeSide)
    pub tradeSide: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOATradeSide>>,
    // @@protoc_insertion_point(field:ProtoOADeal.dealStatus)
    pub dealStatus: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOADealStatus>>,
    // @@protoc_insertion_point(field:ProtoOADeal.marginRate)
    pub marginRate: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOADeal.commission)
    pub commission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADeal.baseToUsdConversionRate)
    pub baseToUsdConversionRate: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOADeal.closePositionDetail)
    pub closePositionDetail: ::protobuf::MessageField<ProtoOAClosePositionDetail>,
    // @@protoc_insertion_point(field:ProtoOADeal.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADeal.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADeal {
    fn default() -> &'a ProtoOADeal {
        <ProtoOADeal as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADeal {
    pub fn new() -> ProtoOADeal {
        ::std::default::Default::default()
    }

    // required int64 dealId = 1;

    pub fn dealId(&self) -> i64 {
        self.dealId.unwrap_or(0)
    }

    pub fn clear_dealId(&mut self) {
        self.dealId = ::std::option::Option::None;
    }

    pub fn has_dealId(&self) -> bool {
        self.dealId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dealId(&mut self, v: i64) {
        self.dealId = ::std::option::Option::Some(v);
    }

    // required int64 orderId = 2;

    pub fn orderId(&self) -> i64 {
        self.orderId.unwrap_or(0)
    }

    pub fn clear_orderId(&mut self) {
        self.orderId = ::std::option::Option::None;
    }

    pub fn has_orderId(&self) -> bool {
        self.orderId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orderId(&mut self, v: i64) {
        self.orderId = ::std::option::Option::Some(v);
    }

    // required int64 positionId = 3;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // required int64 volume = 4;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // required int64 filledVolume = 5;

    pub fn filledVolume(&self) -> i64 {
        self.filledVolume.unwrap_or(0)
    }

    pub fn clear_filledVolume(&mut self) {
        self.filledVolume = ::std::option::Option::None;
    }

    pub fn has_filledVolume(&self) -> bool {
        self.filledVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filledVolume(&mut self, v: i64) {
        self.filledVolume = ::std::option::Option::Some(v);
    }

    // required int64 symbolId = 6;

    pub fn symbolId(&self) -> i64 {
        self.symbolId.unwrap_or(0)
    }

    pub fn clear_symbolId(&mut self) {
        self.symbolId = ::std::option::Option::None;
    }

    pub fn has_symbolId(&self) -> bool {
        self.symbolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_symbolId(&mut self, v: i64) {
        self.symbolId = ::std::option::Option::Some(v);
    }

    // required int64 createTimestamp = 7;

    pub fn createTimestamp(&self) -> i64 {
        self.createTimestamp.unwrap_or(0)
    }

    pub fn clear_createTimestamp(&mut self) {
        self.createTimestamp = ::std::option::Option::None;
    }

    pub fn has_createTimestamp(&self) -> bool {
        self.createTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_createTimestamp(&mut self, v: i64) {
        self.createTimestamp = ::std::option::Option::Some(v);
    }

    // required int64 executionTimestamp = 8;

    pub fn executionTimestamp(&self) -> i64 {
        self.executionTimestamp.unwrap_or(0)
    }

    pub fn clear_executionTimestamp(&mut self) {
        self.executionTimestamp = ::std::option::Option::None;
    }

    pub fn has_executionTimestamp(&self) -> bool {
        self.executionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTimestamp(&mut self, v: i64) {
        self.executionTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 utcLastUpdateTimestamp = 9;

    pub fn utcLastUpdateTimestamp(&self) -> i64 {
        self.utcLastUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_utcLastUpdateTimestamp(&mut self) {
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_utcLastUpdateTimestamp(&self) -> bool {
        self.utcLastUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcLastUpdateTimestamp(&mut self, v: i64) {
        self.utcLastUpdateTimestamp = ::std::option::Option::Some(v);
    }

    // optional double executionPrice = 10;

    pub fn executionPrice(&self) -> f64 {
        self.executionPrice.unwrap_or(0.)
    }

    pub fn clear_executionPrice(&mut self) {
        self.executionPrice = ::std::option::Option::None;
    }

    pub fn has_executionPrice(&self) -> bool {
        self.executionPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionPrice(&mut self, v: f64) {
        self.executionPrice = ::std::option::Option::Some(v);
    }

    // required .ProtoOATradeSide tradeSide = 11;

    pub fn tradeSide(&self) -> ProtoOATradeSide {
        match self.tradeSide {
            Some(e) => e.enum_value_or(ProtoOATradeSide::BUY),
            None => ProtoOATradeSide::BUY,
        }
    }

    pub fn clear_tradeSide(&mut self) {
        self.tradeSide = ::std::option::Option::None;
    }

    pub fn has_tradeSide(&self) -> bool {
        self.tradeSide.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tradeSide(&mut self, v: ProtoOATradeSide) {
        self.tradeSide = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required .ProtoOADealStatus dealStatus = 12;

    pub fn dealStatus(&self) -> ProtoOADealStatus {
        match self.dealStatus {
            Some(e) => e.enum_value_or(ProtoOADealStatus::FILLED),
            None => ProtoOADealStatus::FILLED,
        }
    }

    pub fn clear_dealStatus(&mut self) {
        self.dealStatus = ::std::option::Option::None;
    }

    pub fn has_dealStatus(&self) -> bool {
        self.dealStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dealStatus(&mut self, v: ProtoOADealStatus) {
        self.dealStatus = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional double marginRate = 13;

    pub fn marginRate(&self) -> f64 {
        self.marginRate.unwrap_or(0.)
    }

    pub fn clear_marginRate(&mut self) {
        self.marginRate = ::std::option::Option::None;
    }

    pub fn has_marginRate(&self) -> bool {
        self.marginRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marginRate(&mut self, v: f64) {
        self.marginRate = ::std::option::Option::Some(v);
    }

    // optional int64 commission = 14;

    pub fn commission(&self) -> i64 {
        self.commission.unwrap_or(0)
    }

    pub fn clear_commission(&mut self) {
        self.commission = ::std::option::Option::None;
    }

    pub fn has_commission(&self) -> bool {
        self.commission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commission(&mut self, v: i64) {
        self.commission = ::std::option::Option::Some(v);
    }

    // optional double baseToUsdConversionRate = 15;

    pub fn baseToUsdConversionRate(&self) -> f64 {
        self.baseToUsdConversionRate.unwrap_or(0.)
    }

    pub fn clear_baseToUsdConversionRate(&mut self) {
        self.baseToUsdConversionRate = ::std::option::Option::None;
    }

    pub fn has_baseToUsdConversionRate(&self) -> bool {
        self.baseToUsdConversionRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_baseToUsdConversionRate(&mut self, v: f64) {
        self.baseToUsdConversionRate = ::std::option::Option::Some(v);
    }

    // optional uint32 moneyDigits = 17;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dealId",
            |m: &ProtoOADeal| { &m.dealId },
            |m: &mut ProtoOADeal| { &mut m.dealId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "orderId",
            |m: &ProtoOADeal| { &m.orderId },
            |m: &mut ProtoOADeal| { &mut m.orderId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOADeal| { &m.positionId },
            |m: &mut ProtoOADeal| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOADeal| { &m.volume },
            |m: &mut ProtoOADeal| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "filledVolume",
            |m: &ProtoOADeal| { &m.filledVolume },
            |m: &mut ProtoOADeal| { &mut m.filledVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "symbolId",
            |m: &ProtoOADeal| { &m.symbolId },
            |m: &mut ProtoOADeal| { &mut m.symbolId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "createTimestamp",
            |m: &ProtoOADeal| { &m.createTimestamp },
            |m: &mut ProtoOADeal| { &mut m.createTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executionTimestamp",
            |m: &ProtoOADeal| { &m.executionTimestamp },
            |m: &mut ProtoOADeal| { &mut m.executionTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcLastUpdateTimestamp",
            |m: &ProtoOADeal| { &m.utcLastUpdateTimestamp },
            |m: &mut ProtoOADeal| { &mut m.utcLastUpdateTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executionPrice",
            |m: &ProtoOADeal| { &m.executionPrice },
            |m: &mut ProtoOADeal| { &mut m.executionPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tradeSide",
            |m: &ProtoOADeal| { &m.tradeSide },
            |m: &mut ProtoOADeal| { &mut m.tradeSide },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dealStatus",
            |m: &ProtoOADeal| { &m.dealStatus },
            |m: &mut ProtoOADeal| { &mut m.dealStatus },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "marginRate",
            |m: &ProtoOADeal| { &m.marginRate },
            |m: &mut ProtoOADeal| { &mut m.marginRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commission",
            |m: &ProtoOADeal| { &m.commission },
            |m: &mut ProtoOADeal| { &mut m.commission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "baseToUsdConversionRate",
            |m: &ProtoOADeal| { &m.baseToUsdConversionRate },
            |m: &mut ProtoOADeal| { &mut m.baseToUsdConversionRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ProtoOAClosePositionDetail>(
            "closePositionDetail",
            |m: &ProtoOADeal| { &m.closePositionDetail },
            |m: &mut ProtoOADeal| { &mut m.closePositionDetail },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOADeal| { &m.moneyDigits },
            |m: &mut ProtoOADeal| { &mut m.moneyDigits },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADeal>(
            "ProtoOADeal",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADeal {
    const NAME: &'static str = "ProtoOADeal";

    fn is_initialized(&self) -> bool {
        if self.dealId.is_none() {
            return false;
        }
        if self.orderId.is_none() {
            return false;
        }
        if self.positionId.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        if self.filledVolume.is_none() {
            return false;
        }
        if self.symbolId.is_none() {
            return false;
        }
        if self.createTimestamp.is_none() {
            return false;
        }
        if self.executionTimestamp.is_none() {
            return false;
        }
        if self.tradeSide.is_none() {
            return false;
        }
        if self.dealStatus.is_none() {
            return false;
        }
        for v in &self.closePositionDetail {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dealId = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.orderId = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.filledVolume = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.symbolId = ::std::option::Option::Some(is.read_int64()?);
                },
                56 => {
                    self.createTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.executionTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.utcLastUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                81 => {
                    self.executionPrice = ::std::option::Option::Some(is.read_double()?);
                },
                88 => {
                    self.tradeSide = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                96 => {
                    self.dealStatus = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                105 => {
                    self.marginRate = ::std::option::Option::Some(is.read_double()?);
                },
                112 => {
                    self.commission = ::std::option::Option::Some(is.read_int64()?);
                },
                121 => {
                    self.baseToUsdConversionRate = ::std::option::Option::Some(is.read_double()?);
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.closePositionDetail)?;
                },
                136 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dealId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.orderId {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.filledVolume {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.symbolId {
            my_size += ::protobuf::rt::int64_size(6, v);
        }
        if let Some(v) = self.createTimestamp {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.executionTimestamp {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(9, v);
        }
        if let Some(v) = self.executionPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tradeSide {
            my_size += ::protobuf::rt::int32_size(11, v.value());
        }
        if let Some(v) = self.dealStatus {
            my_size += ::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.marginRate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.commission {
            my_size += ::protobuf::rt::int64_size(14, v);
        }
        if let Some(v) = self.baseToUsdConversionRate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.closePositionDetail.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dealId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.orderId {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.positionId {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.filledVolume {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.symbolId {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.createTimestamp {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.executionTimestamp {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            os.write_int64(9, v)?;
        }
        if let Some(v) = self.executionPrice {
            os.write_double(10, v)?;
        }
        if let Some(v) = self.tradeSide {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.dealStatus {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.marginRate {
            os.write_double(13, v)?;
        }
        if let Some(v) = self.commission {
            os.write_int64(14, v)?;
        }
        if let Some(v) = self.baseToUsdConversionRate {
            os.write_double(15, v)?;
        }
        if let Some(v) = self.closePositionDetail.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADeal {
        ProtoOADeal::new()
    }

    fn clear(&mut self) {
        self.dealId = ::std::option::Option::None;
        self.orderId = ::std::option::Option::None;
        self.positionId = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.filledVolume = ::std::option::Option::None;
        self.symbolId = ::std::option::Option::None;
        self.createTimestamp = ::std::option::Option::None;
        self.executionTimestamp = ::std::option::Option::None;
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
        self.executionPrice = ::std::option::Option::None;
        self.tradeSide = ::std::option::Option::None;
        self.dealStatus = ::std::option::Option::None;
        self.marginRate = ::std::option::Option::None;
        self.commission = ::std::option::Option::None;
        self.baseToUsdConversionRate = ::std::option::Option::None;
        self.closePositionDetail.clear();
        self.moneyDigits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADeal {
        static instance: ProtoOADeal = ProtoOADeal {
            dealId: ::std::option::Option::None,
            orderId: ::std::option::Option::None,
            positionId: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            filledVolume: ::std::option::Option::None,
            symbolId: ::std::option::Option::None,
            createTimestamp: ::std::option::Option::None,
            executionTimestamp: ::std::option::Option::None,
            utcLastUpdateTimestamp: ::std::option::Option::None,
            executionPrice: ::std::option::Option::None,
            tradeSide: ::std::option::Option::None,
            dealStatus: ::std::option::Option::None,
            marginRate: ::std::option::Option::None,
            commission: ::std::option::Option::None,
            baseToUsdConversionRate: ::std::option::Option::None,
            closePositionDetail: ::protobuf::MessageField::none(),
            moneyDigits: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADeal {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADeal").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADeal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADeal {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADealOffset)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADealOffset {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADealOffset.dealId)
    pub dealId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealOffset.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealOffset.executionTimestamp)
    pub executionTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADealOffset.executionPrice)
    pub executionPrice: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADealOffset.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADealOffset {
    fn default() -> &'a ProtoOADealOffset {
        <ProtoOADealOffset as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADealOffset {
    pub fn new() -> ProtoOADealOffset {
        ::std::default::Default::default()
    }

    // required int64 dealId = 1;

    pub fn dealId(&self) -> i64 {
        self.dealId.unwrap_or(0)
    }

    pub fn clear_dealId(&mut self) {
        self.dealId = ::std::option::Option::None;
    }

    pub fn has_dealId(&self) -> bool {
        self.dealId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dealId(&mut self, v: i64) {
        self.dealId = ::std::option::Option::Some(v);
    }

    // required int64 volume = 2;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // optional int64 executionTimestamp = 3;

    pub fn executionTimestamp(&self) -> i64 {
        self.executionTimestamp.unwrap_or(0)
    }

    pub fn clear_executionTimestamp(&mut self) {
        self.executionTimestamp = ::std::option::Option::None;
    }

    pub fn has_executionTimestamp(&self) -> bool {
        self.executionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionTimestamp(&mut self, v: i64) {
        self.executionTimestamp = ::std::option::Option::Some(v);
    }

    // optional double executionPrice = 4;

    pub fn executionPrice(&self) -> f64 {
        self.executionPrice.unwrap_or(0.)
    }

    pub fn clear_executionPrice(&mut self) {
        self.executionPrice = ::std::option::Option::None;
    }

    pub fn has_executionPrice(&self) -> bool {
        self.executionPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_executionPrice(&mut self, v: f64) {
        self.executionPrice = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dealId",
            |m: &ProtoOADealOffset| { &m.dealId },
            |m: &mut ProtoOADealOffset| { &mut m.dealId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOADealOffset| { &m.volume },
            |m: &mut ProtoOADealOffset| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executionTimestamp",
            |m: &ProtoOADealOffset| { &m.executionTimestamp },
            |m: &mut ProtoOADealOffset| { &mut m.executionTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "executionPrice",
            |m: &ProtoOADealOffset| { &m.executionPrice },
            |m: &mut ProtoOADealOffset| { &mut m.executionPrice },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADealOffset>(
            "ProtoOADealOffset",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADealOffset {
    const NAME: &'static str = "ProtoOADealOffset";

    fn is_initialized(&self) -> bool {
        if self.dealId.is_none() {
            return false;
        }
        if self.volume.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dealId = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.executionTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                33 => {
                    self.executionPrice = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dealId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.executionTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.executionPrice {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.dealId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.volume {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.executionTimestamp {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.executionPrice {
            os.write_double(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADealOffset {
        ProtoOADealOffset::new()
    }

    fn clear(&mut self) {
        self.dealId = ::std::option::Option::None;
        self.volume = ::std::option::Option::None;
        self.executionTimestamp = ::std::option::Option::None;
        self.executionPrice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADealOffset {
        static instance: ProtoOADealOffset = ProtoOADealOffset {
            dealId: ::std::option::Option::None,
            volume: ::std::option::Option::None,
            executionTimestamp: ::std::option::Option::None,
            executionPrice: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADealOffset {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADealOffset").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADealOffset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADealOffset {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAClosePositionDetail)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAClosePositionDetail {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.entryPrice)
    pub entryPrice: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.grossProfit)
    pub grossProfit: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.swap)
    pub swap: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.commission)
    pub commission: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.balance)
    pub balance: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.quoteToDepositConversionRate)
    pub quoteToDepositConversionRate: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.closedVolume)
    pub closedVolume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.balanceVersion)
    pub balanceVersion: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.moneyDigits)
    pub moneyDigits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ProtoOAClosePositionDetail.pnlConversionFee)
    pub pnlConversionFee: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAClosePositionDetail.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAClosePositionDetail {
    fn default() -> &'a ProtoOAClosePositionDetail {
        <ProtoOAClosePositionDetail as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAClosePositionDetail {
    pub fn new() -> ProtoOAClosePositionDetail {
        ::std::default::Default::default()
    }

    // required double entryPrice = 1;

    pub fn entryPrice(&self) -> f64 {
        self.entryPrice.unwrap_or(0.)
    }

    pub fn clear_entryPrice(&mut self) {
        self.entryPrice = ::std::option::Option::None;
    }

    pub fn has_entryPrice(&self) -> bool {
        self.entryPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryPrice(&mut self, v: f64) {
        self.entryPrice = ::std::option::Option::Some(v);
    }

    // required int64 grossProfit = 2;

    pub fn grossProfit(&self) -> i64 {
        self.grossProfit.unwrap_or(0)
    }

    pub fn clear_grossProfit(&mut self) {
        self.grossProfit = ::std::option::Option::None;
    }

    pub fn has_grossProfit(&self) -> bool {
        self.grossProfit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grossProfit(&mut self, v: i64) {
        self.grossProfit = ::std::option::Option::Some(v);
    }

    // required int64 swap = 3;

    pub fn swap(&self) -> i64 {
        self.swap.unwrap_or(0)
    }

    pub fn clear_swap(&mut self) {
        self.swap = ::std::option::Option::None;
    }

    pub fn has_swap(&self) -> bool {
        self.swap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swap(&mut self, v: i64) {
        self.swap = ::std::option::Option::Some(v);
    }

    // required int64 commission = 4;

    pub fn commission(&self) -> i64 {
        self.commission.unwrap_or(0)
    }

    pub fn clear_commission(&mut self) {
        self.commission = ::std::option::Option::None;
    }

    pub fn has_commission(&self) -> bool {
        self.commission.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commission(&mut self, v: i64) {
        self.commission = ::std::option::Option::Some(v);
    }

    // required int64 balance = 5;

    pub fn balance(&self) -> i64 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: i64) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional double quoteToDepositConversionRate = 6;

    pub fn quoteToDepositConversionRate(&self) -> f64 {
        self.quoteToDepositConversionRate.unwrap_or(0.)
    }

    pub fn clear_quoteToDepositConversionRate(&mut self) {
        self.quoteToDepositConversionRate = ::std::option::Option::None;
    }

    pub fn has_quoteToDepositConversionRate(&self) -> bool {
        self.quoteToDepositConversionRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quoteToDepositConversionRate(&mut self, v: f64) {
        self.quoteToDepositConversionRate = ::std::option::Option::Some(v);
    }

    // optional int64 closedVolume = 7;

    pub fn closedVolume(&self) -> i64 {
        self.closedVolume.unwrap_or(0)
    }

    pub fn clear_closedVolume(&mut self) {
        self.closedVolume = ::std::option::Option::None;
    }

    pub fn has_closedVolume(&self) -> bool {
        self.closedVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_closedVolume(&mut self, v: i64) {
        self.closedVolume = ::std::option::Option::Some(v);
    }

    // optional int64 balanceVersion = 8;

    pub fn balanceVersion(&self) -> i64 {
        self.balanceVersion.unwrap_or(0)
    }

    pub fn clear_balanceVersion(&mut self) {
        self.balanceVersion = ::std::option::Option::None;
    }

    pub fn has_balanceVersion(&self) -> bool {
        self.balanceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balanceVersion(&mut self, v: i64) {
        self.balanceVersion = ::std::option::Option::Some(v);
    }

    // optional uint32 moneyDigits = 9;

    pub fn moneyDigits(&self) -> u32 {
        self.moneyDigits.unwrap_or(0)
    }

    pub fn clear_moneyDigits(&mut self) {
        self.moneyDigits = ::std::option::Option::None;
    }

    pub fn has_moneyDigits(&self) -> bool {
        self.moneyDigits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_moneyDigits(&mut self, v: u32) {
        self.moneyDigits = ::std::option::Option::Some(v);
    }

    // optional int64 pnlConversionFee = 10;

    pub fn pnlConversionFee(&self) -> i64 {
        self.pnlConversionFee.unwrap_or(0)
    }

    pub fn clear_pnlConversionFee(&mut self) {
        self.pnlConversionFee = ::std::option::Option::None;
    }

    pub fn has_pnlConversionFee(&self) -> bool {
        self.pnlConversionFee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pnlConversionFee(&mut self, v: i64) {
        self.pnlConversionFee = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryPrice",
            |m: &ProtoOAClosePositionDetail| { &m.entryPrice },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.entryPrice },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "grossProfit",
            |m: &ProtoOAClosePositionDetail| { &m.grossProfit },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.grossProfit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "swap",
            |m: &ProtoOAClosePositionDetail| { &m.swap },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.swap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "commission",
            |m: &ProtoOAClosePositionDetail| { &m.commission },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.commission },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balance",
            |m: &ProtoOAClosePositionDetail| { &m.balance },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quoteToDepositConversionRate",
            |m: &ProtoOAClosePositionDetail| { &m.quoteToDepositConversionRate },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.quoteToDepositConversionRate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "closedVolume",
            |m: &ProtoOAClosePositionDetail| { &m.closedVolume },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.closedVolume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "balanceVersion",
            |m: &ProtoOAClosePositionDetail| { &m.balanceVersion },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.balanceVersion },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "moneyDigits",
            |m: &ProtoOAClosePositionDetail| { &m.moneyDigits },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.moneyDigits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pnlConversionFee",
            |m: &ProtoOAClosePositionDetail| { &m.pnlConversionFee },
            |m: &mut ProtoOAClosePositionDetail| { &mut m.pnlConversionFee },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAClosePositionDetail>(
            "ProtoOAClosePositionDetail",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAClosePositionDetail {
    const NAME: &'static str = "ProtoOAClosePositionDetail";

    fn is_initialized(&self) -> bool {
        if self.entryPrice.is_none() {
            return false;
        }
        if self.grossProfit.is_none() {
            return false;
        }
        if self.swap.is_none() {
            return false;
        }
        if self.commission.is_none() {
            return false;
        }
        if self.balance.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.entryPrice = ::std::option::Option::Some(is.read_double()?);
                },
                16 => {
                    self.grossProfit = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.swap = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.commission = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.balance = ::std::option::Option::Some(is.read_int64()?);
                },
                49 => {
                    self.quoteToDepositConversionRate = ::std::option::Option::Some(is.read_double()?);
                },
                56 => {
                    self.closedVolume = ::std::option::Option::Some(is.read_int64()?);
                },
                64 => {
                    self.balanceVersion = ::std::option::Option::Some(is.read_int64()?);
                },
                72 => {
                    self.moneyDigits = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.pnlConversionFee = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entryPrice {
            my_size += 1 + 8;
        }
        if let Some(v) = self.grossProfit {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.swap {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.commission {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.balance {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.quoteToDepositConversionRate {
            my_size += 1 + 8;
        }
        if let Some(v) = self.closedVolume {
            my_size += ::protobuf::rt::int64_size(7, v);
        }
        if let Some(v) = self.balanceVersion {
            my_size += ::protobuf::rt::int64_size(8, v);
        }
        if let Some(v) = self.moneyDigits {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.pnlConversionFee {
            my_size += ::protobuf::rt::int64_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entryPrice {
            os.write_double(1, v)?;
        }
        if let Some(v) = self.grossProfit {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.swap {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.commission {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.balance {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.quoteToDepositConversionRate {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.closedVolume {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.balanceVersion {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.moneyDigits {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pnlConversionFee {
            os.write_int64(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAClosePositionDetail {
        ProtoOAClosePositionDetail::new()
    }

    fn clear(&mut self) {
        self.entryPrice = ::std::option::Option::None;
        self.grossProfit = ::std::option::Option::None;
        self.swap = ::std::option::Option::None;
        self.commission = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.quoteToDepositConversionRate = ::std::option::Option::None;
        self.closedVolume = ::std::option::Option::None;
        self.balanceVersion = ::std::option::Option::None;
        self.moneyDigits = ::std::option::Option::None;
        self.pnlConversionFee = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAClosePositionDetail {
        static instance: ProtoOAClosePositionDetail = ProtoOAClosePositionDetail {
            entryPrice: ::std::option::Option::None,
            grossProfit: ::std::option::Option::None,
            swap: ::std::option::Option::None,
            commission: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            quoteToDepositConversionRate: ::std::option::Option::None,
            closedVolume: ::std::option::Option::None,
            balanceVersion: ::std::option::Option::None,
            moneyDigits: ::std::option::Option::None,
            pnlConversionFee: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAClosePositionDetail {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAClosePositionDetail").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAClosePositionDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAClosePositionDetail {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATrendbar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATrendbar {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATrendbar.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrendbar.period)
    pub period: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOATrendbarPeriod>>,
    // @@protoc_insertion_point(field:ProtoOATrendbar.low)
    pub low: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATrendbar.deltaOpen)
    pub deltaOpen: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOATrendbar.deltaClose)
    pub deltaClose: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOATrendbar.deltaHigh)
    pub deltaHigh: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOATrendbar.utcTimestampInMinutes)
    pub utcTimestampInMinutes: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATrendbar.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATrendbar {
    fn default() -> &'a ProtoOATrendbar {
        <ProtoOATrendbar as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATrendbar {
    pub fn new() -> ProtoOATrendbar {
        ::std::default::Default::default()
    }

    // required int64 volume = 3;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // optional .ProtoOATrendbarPeriod period = 4;

    pub fn period(&self) -> ProtoOATrendbarPeriod {
        match self.period {
            Some(e) => e.enum_value_or(ProtoOATrendbarPeriod::M1),
            None => ProtoOATrendbarPeriod::M1,
        }
    }

    pub fn clear_period(&mut self) {
        self.period = ::std::option::Option::None;
    }

    pub fn has_period(&self) -> bool {
        self.period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_period(&mut self, v: ProtoOATrendbarPeriod) {
        self.period = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // optional int64 low = 5;

    pub fn low(&self) -> i64 {
        self.low.unwrap_or(0)
    }

    pub fn clear_low(&mut self) {
        self.low = ::std::option::Option::None;
    }

    pub fn has_low(&self) -> bool {
        self.low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low(&mut self, v: i64) {
        self.low = ::std::option::Option::Some(v);
    }

    // optional uint64 deltaOpen = 6;

    pub fn deltaOpen(&self) -> u64 {
        self.deltaOpen.unwrap_or(0)
    }

    pub fn clear_deltaOpen(&mut self) {
        self.deltaOpen = ::std::option::Option::None;
    }

    pub fn has_deltaOpen(&self) -> bool {
        self.deltaOpen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltaOpen(&mut self, v: u64) {
        self.deltaOpen = ::std::option::Option::Some(v);
    }

    // optional uint64 deltaClose = 7;

    pub fn deltaClose(&self) -> u64 {
        self.deltaClose.unwrap_or(0)
    }

    pub fn clear_deltaClose(&mut self) {
        self.deltaClose = ::std::option::Option::None;
    }

    pub fn has_deltaClose(&self) -> bool {
        self.deltaClose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltaClose(&mut self, v: u64) {
        self.deltaClose = ::std::option::Option::Some(v);
    }

    // optional uint64 deltaHigh = 8;

    pub fn deltaHigh(&self) -> u64 {
        self.deltaHigh.unwrap_or(0)
    }

    pub fn clear_deltaHigh(&mut self) {
        self.deltaHigh = ::std::option::Option::None;
    }

    pub fn has_deltaHigh(&self) -> bool {
        self.deltaHigh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deltaHigh(&mut self, v: u64) {
        self.deltaHigh = ::std::option::Option::Some(v);
    }

    // optional uint32 utcTimestampInMinutes = 9;

    pub fn utcTimestampInMinutes(&self) -> u32 {
        self.utcTimestampInMinutes.unwrap_or(0)
    }

    pub fn clear_utcTimestampInMinutes(&mut self) {
        self.utcTimestampInMinutes = ::std::option::Option::None;
    }

    pub fn has_utcTimestampInMinutes(&self) -> bool {
        self.utcTimestampInMinutes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcTimestampInMinutes(&mut self, v: u32) {
        self.utcTimestampInMinutes = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOATrendbar| { &m.volume },
            |m: &mut ProtoOATrendbar| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "period",
            |m: &ProtoOATrendbar| { &m.period },
            |m: &mut ProtoOATrendbar| { &mut m.period },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "low",
            |m: &ProtoOATrendbar| { &m.low },
            |m: &mut ProtoOATrendbar| { &mut m.low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltaOpen",
            |m: &ProtoOATrendbar| { &m.deltaOpen },
            |m: &mut ProtoOATrendbar| { &mut m.deltaOpen },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltaClose",
            |m: &ProtoOATrendbar| { &m.deltaClose },
            |m: &mut ProtoOATrendbar| { &mut m.deltaClose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "deltaHigh",
            |m: &ProtoOATrendbar| { &m.deltaHigh },
            |m: &mut ProtoOATrendbar| { &mut m.deltaHigh },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcTimestampInMinutes",
            |m: &ProtoOATrendbar| { &m.utcTimestampInMinutes },
            |m: &mut ProtoOATrendbar| { &mut m.utcTimestampInMinutes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATrendbar>(
            "ProtoOATrendbar",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATrendbar {
    const NAME: &'static str = "ProtoOATrendbar";

    fn is_initialized(&self) -> bool {
        if self.volume.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.period = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.low = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.deltaOpen = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.deltaClose = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.deltaHigh = ::std::option::Option::Some(is.read_uint64()?);
                },
                72 => {
                    self.utcTimestampInMinutes = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.period {
            my_size += ::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.low {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.deltaOpen {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.deltaClose {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.deltaHigh {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.utcTimestampInMinutes {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volume {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.period {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.low {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.deltaOpen {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.deltaClose {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.deltaHigh {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.utcTimestampInMinutes {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATrendbar {
        ProtoOATrendbar::new()
    }

    fn clear(&mut self) {
        self.volume = ::std::option::Option::None;
        self.period = ::std::option::Option::None;
        self.low = ::std::option::Option::None;
        self.deltaOpen = ::std::option::Option::None;
        self.deltaClose = ::std::option::Option::None;
        self.deltaHigh = ::std::option::Option::None;
        self.utcTimestampInMinutes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATrendbar {
        static instance: ProtoOATrendbar = ProtoOATrendbar {
            volume: ::std::option::Option::None,
            period: ::std::option::Option::None,
            low: ::std::option::Option::None,
            deltaOpen: ::std::option::Option::None,
            deltaClose: ::std::option::Option::None,
            deltaHigh: ::std::option::Option::None,
            utcTimestampInMinutes: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATrendbar {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATrendbar").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATrendbar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATrendbar {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAExpectedMargin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAExpectedMargin {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAExpectedMargin.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMargin.buyMargin)
    pub buyMargin: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAExpectedMargin.sellMargin)
    pub sellMargin: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAExpectedMargin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAExpectedMargin {
    fn default() -> &'a ProtoOAExpectedMargin {
        <ProtoOAExpectedMargin as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAExpectedMargin {
    pub fn new() -> ProtoOAExpectedMargin {
        ::std::default::Default::default()
    }

    // required int64 volume = 1;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // required int64 buyMargin = 2;

    pub fn buyMargin(&self) -> i64 {
        self.buyMargin.unwrap_or(0)
    }

    pub fn clear_buyMargin(&mut self) {
        self.buyMargin = ::std::option::Option::None;
    }

    pub fn has_buyMargin(&self) -> bool {
        self.buyMargin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buyMargin(&mut self, v: i64) {
        self.buyMargin = ::std::option::Option::Some(v);
    }

    // required int64 sellMargin = 3;

    pub fn sellMargin(&self) -> i64 {
        self.sellMargin.unwrap_or(0)
    }

    pub fn clear_sellMargin(&mut self) {
        self.sellMargin = ::std::option::Option::None;
    }

    pub fn has_sellMargin(&self) -> bool {
        self.sellMargin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sellMargin(&mut self, v: i64) {
        self.sellMargin = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOAExpectedMargin| { &m.volume },
            |m: &mut ProtoOAExpectedMargin| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "buyMargin",
            |m: &ProtoOAExpectedMargin| { &m.buyMargin },
            |m: &mut ProtoOAExpectedMargin| { &mut m.buyMargin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sellMargin",
            |m: &ProtoOAExpectedMargin| { &m.sellMargin },
            |m: &mut ProtoOAExpectedMargin| { &mut m.sellMargin },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAExpectedMargin>(
            "ProtoOAExpectedMargin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAExpectedMargin {
    const NAME: &'static str = "ProtoOAExpectedMargin";

    fn is_initialized(&self) -> bool {
        if self.volume.is_none() {
            return false;
        }
        if self.buyMargin.is_none() {
            return false;
        }
        if self.sellMargin.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.buyMargin = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.sellMargin = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.buyMargin {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.sellMargin {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volume {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.buyMargin {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.sellMargin {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAExpectedMargin {
        ProtoOAExpectedMargin::new()
    }

    fn clear(&mut self) {
        self.volume = ::std::option::Option::None;
        self.buyMargin = ::std::option::Option::None;
        self.sellMargin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAExpectedMargin {
        static instance: ProtoOAExpectedMargin = ProtoOAExpectedMargin {
            volume: ::std::option::Option::None,
            buyMargin: ::std::option::Option::None,
            sellMargin: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAExpectedMargin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAExpectedMargin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAExpectedMargin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAExpectedMargin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOATickData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOATickData {
    // message fields
    // @@protoc_insertion_point(field:ProtoOATickData.timestamp)
    pub timestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOATickData.tick)
    pub tick: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOATickData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOATickData {
    fn default() -> &'a ProtoOATickData {
        <ProtoOATickData as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOATickData {
    pub fn new() -> ProtoOATickData {
        ::std::default::Default::default()
    }

    // required int64 timestamp = 1;

    pub fn timestamp(&self) -> i64 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // required int64 tick = 2;

    pub fn tick(&self) -> i64 {
        self.tick.unwrap_or(0)
    }

    pub fn clear_tick(&mut self) {
        self.tick = ::std::option::Option::None;
    }

    pub fn has_tick(&self) -> bool {
        self.tick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tick(&mut self, v: i64) {
        self.tick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &ProtoOATickData| { &m.timestamp },
            |m: &mut ProtoOATickData| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tick",
            |m: &ProtoOATickData| { &m.tick },
            |m: &mut ProtoOATickData| { &mut m.tick },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOATickData>(
            "ProtoOATickData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOATickData {
    const NAME: &'static str = "ProtoOATickData";

    fn is_initialized(&self) -> bool {
        if self.timestamp.is_none() {
            return false;
        }
        if self.tick.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.tick = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.tick {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.tick {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOATickData {
        ProtoOATickData::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.tick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOATickData {
        static instance: ProtoOATickData = ProtoOATickData {
            timestamp: ::std::option::Option::None,
            tick: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOATickData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOATickData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOATickData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOATickData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOACtidProfile)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOACtidProfile {
    // message fields
    // @@protoc_insertion_point(field:ProtoOACtidProfile.userId)
    pub userId: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOACtidProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOACtidProfile {
    fn default() -> &'a ProtoOACtidProfile {
        <ProtoOACtidProfile as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOACtidProfile {
    pub fn new() -> ProtoOACtidProfile {
        ::std::default::Default::default()
    }

    // required int64 userId = 1;

    pub fn userId(&self) -> i64 {
        self.userId.unwrap_or(0)
    }

    pub fn clear_userId(&mut self) {
        self.userId = ::std::option::Option::None;
    }

    pub fn has_userId(&self) -> bool {
        self.userId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_userId(&mut self, v: i64) {
        self.userId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "userId",
            |m: &ProtoOACtidProfile| { &m.userId },
            |m: &mut ProtoOACtidProfile| { &mut m.userId },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOACtidProfile>(
            "ProtoOACtidProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOACtidProfile {
    const NAME: &'static str = "ProtoOACtidProfile";

    fn is_initialized(&self) -> bool {
        if self.userId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.userId = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.userId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.userId {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOACtidProfile {
        ProtoOACtidProfile::new()
    }

    fn clear(&mut self) {
        self.userId = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOACtidProfile {
        static instance: ProtoOACtidProfile = ProtoOACtidProfile {
            userId: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOACtidProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOACtidProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOACtidProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOACtidProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOACtidTraderAccount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOACtidTraderAccount {
    // message fields
    // @@protoc_insertion_point(field:ProtoOACtidTraderAccount.ctidTraderAccountId)
    pub ctidTraderAccountId: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOACtidTraderAccount.isLive)
    pub isLive: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOACtidTraderAccount.traderLogin)
    pub traderLogin: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACtidTraderAccount.lastClosingDealTimestamp)
    pub lastClosingDealTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACtidTraderAccount.lastBalanceUpdateTimestamp)
    pub lastBalanceUpdateTimestamp: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOACtidTraderAccount.brokerTitleShort)
    pub brokerTitleShort: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOACtidTraderAccount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOACtidTraderAccount {
    fn default() -> &'a ProtoOACtidTraderAccount {
        <ProtoOACtidTraderAccount as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOACtidTraderAccount {
    pub fn new() -> ProtoOACtidTraderAccount {
        ::std::default::Default::default()
    }

    // required uint64 ctidTraderAccountId = 1;

    pub fn ctidTraderAccountId(&self) -> u64 {
        self.ctidTraderAccountId.unwrap_or(0)
    }

    pub fn clear_ctidTraderAccountId(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
    }

    pub fn has_ctidTraderAccountId(&self) -> bool {
        self.ctidTraderAccountId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctidTraderAccountId(&mut self, v: u64) {
        self.ctidTraderAccountId = ::std::option::Option::Some(v);
    }

    // optional bool isLive = 2;

    pub fn isLive(&self) -> bool {
        self.isLive.unwrap_or(false)
    }

    pub fn clear_isLive(&mut self) {
        self.isLive = ::std::option::Option::None;
    }

    pub fn has_isLive(&self) -> bool {
        self.isLive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isLive(&mut self, v: bool) {
        self.isLive = ::std::option::Option::Some(v);
    }

    // optional int64 traderLogin = 3;

    pub fn traderLogin(&self) -> i64 {
        self.traderLogin.unwrap_or(0)
    }

    pub fn clear_traderLogin(&mut self) {
        self.traderLogin = ::std::option::Option::None;
    }

    pub fn has_traderLogin(&self) -> bool {
        self.traderLogin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_traderLogin(&mut self, v: i64) {
        self.traderLogin = ::std::option::Option::Some(v);
    }

    // optional int64 lastClosingDealTimestamp = 4;

    pub fn lastClosingDealTimestamp(&self) -> i64 {
        self.lastClosingDealTimestamp.unwrap_or(0)
    }

    pub fn clear_lastClosingDealTimestamp(&mut self) {
        self.lastClosingDealTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastClosingDealTimestamp(&self) -> bool {
        self.lastClosingDealTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastClosingDealTimestamp(&mut self, v: i64) {
        self.lastClosingDealTimestamp = ::std::option::Option::Some(v);
    }

    // optional int64 lastBalanceUpdateTimestamp = 5;

    pub fn lastBalanceUpdateTimestamp(&self) -> i64 {
        self.lastBalanceUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_lastBalanceUpdateTimestamp(&mut self) {
        self.lastBalanceUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_lastBalanceUpdateTimestamp(&self) -> bool {
        self.lastBalanceUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastBalanceUpdateTimestamp(&mut self, v: i64) {
        self.lastBalanceUpdateTimestamp = ::std::option::Option::Some(v);
    }

    // optional string brokerTitleShort = 6;

    pub fn brokerTitleShort(&self) -> &str {
        match self.brokerTitleShort.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_brokerTitleShort(&mut self) {
        self.brokerTitleShort = ::std::option::Option::None;
    }

    pub fn has_brokerTitleShort(&self) -> bool {
        self.brokerTitleShort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_brokerTitleShort(&mut self, v: ::std::string::String) {
        self.brokerTitleShort = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_brokerTitleShort(&mut self) -> &mut ::std::string::String {
        if self.brokerTitleShort.is_none() {
            self.brokerTitleShort = ::std::option::Option::Some(::std::string::String::new());
        }
        self.brokerTitleShort.as_mut().unwrap()
    }

    // Take field
    pub fn take_brokerTitleShort(&mut self) -> ::std::string::String {
        self.brokerTitleShort.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctidTraderAccountId",
            |m: &ProtoOACtidTraderAccount| { &m.ctidTraderAccountId },
            |m: &mut ProtoOACtidTraderAccount| { &mut m.ctidTraderAccountId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isLive",
            |m: &ProtoOACtidTraderAccount| { &m.isLive },
            |m: &mut ProtoOACtidTraderAccount| { &mut m.isLive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "traderLogin",
            |m: &ProtoOACtidTraderAccount| { &m.traderLogin },
            |m: &mut ProtoOACtidTraderAccount| { &mut m.traderLogin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastClosingDealTimestamp",
            |m: &ProtoOACtidTraderAccount| { &m.lastClosingDealTimestamp },
            |m: &mut ProtoOACtidTraderAccount| { &mut m.lastClosingDealTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "lastBalanceUpdateTimestamp",
            |m: &ProtoOACtidTraderAccount| { &m.lastBalanceUpdateTimestamp },
            |m: &mut ProtoOACtidTraderAccount| { &mut m.lastBalanceUpdateTimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "brokerTitleShort",
            |m: &ProtoOACtidTraderAccount| { &m.brokerTitleShort },
            |m: &mut ProtoOACtidTraderAccount| { &mut m.brokerTitleShort },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOACtidTraderAccount>(
            "ProtoOACtidTraderAccount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOACtidTraderAccount {
    const NAME: &'static str = "ProtoOACtidTraderAccount";

    fn is_initialized(&self) -> bool {
        if self.ctidTraderAccountId.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctidTraderAccountId = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.isLive = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.traderLogin = ::std::option::Option::Some(is.read_int64()?);
                },
                32 => {
                    self.lastClosingDealTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.lastBalanceUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                50 => {
                    self.brokerTitleShort = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ctidTraderAccountId {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.isLive {
            my_size += 1 + 1;
        }
        if let Some(v) = self.traderLogin {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        if let Some(v) = self.lastClosingDealTimestamp {
            my_size += ::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.lastBalanceUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.brokerTitleShort.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ctidTraderAccountId {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.isLive {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.traderLogin {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.lastClosingDealTimestamp {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.lastBalanceUpdateTimestamp {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.brokerTitleShort.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOACtidTraderAccount {
        ProtoOACtidTraderAccount::new()
    }

    fn clear(&mut self) {
        self.ctidTraderAccountId = ::std::option::Option::None;
        self.isLive = ::std::option::Option::None;
        self.traderLogin = ::std::option::Option::None;
        self.lastClosingDealTimestamp = ::std::option::Option::None;
        self.lastBalanceUpdateTimestamp = ::std::option::Option::None;
        self.brokerTitleShort = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOACtidTraderAccount {
        static instance: ProtoOACtidTraderAccount = ProtoOACtidTraderAccount {
            ctidTraderAccountId: ::std::option::Option::None,
            isLive: ::std::option::Option::None,
            traderLogin: ::std::option::Option::None,
            lastClosingDealTimestamp: ::std::option::Option::None,
            lastBalanceUpdateTimestamp: ::std::option::Option::None,
            brokerTitleShort: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOACtidTraderAccount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOACtidTraderAccount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOACtidTraderAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOACtidTraderAccount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAAssetClass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAAssetClass {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAAssetClass.id)
    pub id: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAAssetClass.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAAssetClass.sortingNumber)
    pub sortingNumber: ::std::option::Option<f64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAAssetClass.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAAssetClass {
    fn default() -> &'a ProtoOAAssetClass {
        <ProtoOAAssetClass as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAAssetClass {
    pub fn new() -> ProtoOAAssetClass {
        ::std::default::Default::default()
    }

    // optional int64 id = 1;

    pub fn id(&self) -> i64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional double sortingNumber = 3;

    pub fn sortingNumber(&self) -> f64 {
        self.sortingNumber.unwrap_or(0.)
    }

    pub fn clear_sortingNumber(&mut self) {
        self.sortingNumber = ::std::option::Option::None;
    }

    pub fn has_sortingNumber(&self) -> bool {
        self.sortingNumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sortingNumber(&mut self, v: f64) {
        self.sortingNumber = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ProtoOAAssetClass| { &m.id },
            |m: &mut ProtoOAAssetClass| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ProtoOAAssetClass| { &m.name },
            |m: &mut ProtoOAAssetClass| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sortingNumber",
            |m: &ProtoOAAssetClass| { &m.sortingNumber },
            |m: &mut ProtoOAAssetClass| { &mut m.sortingNumber },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAAssetClass>(
            "ProtoOAAssetClass",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAAssetClass {
    const NAME: &'static str = "ProtoOAAssetClass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                25 => {
                    self.sortingNumber = ::std::option::Option::Some(is.read_double()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.sortingNumber {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.sortingNumber {
            os.write_double(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAAssetClass {
        ProtoOAAssetClass::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.sortingNumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAAssetClass {
        static instance: ProtoOAAssetClass = ProtoOAAssetClass {
            id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            sortingNumber: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAAssetClass {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAAssetClass").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAAssetClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAAssetClass {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADepthQuote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADepthQuote {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADepthQuote.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOADepthQuote.size)
    pub size: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOADepthQuote.bid)
    pub bid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ProtoOADepthQuote.ask)
    pub ask: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADepthQuote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADepthQuote {
    fn default() -> &'a ProtoOADepthQuote {
        <ProtoOADepthQuote as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADepthQuote {
    pub fn new() -> ProtoOADepthQuote {
        ::std::default::Default::default()
    }

    // required uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // required uint64 size = 3;

    pub fn size(&self) -> u64 {
        self.size.unwrap_or(0)
    }

    pub fn clear_size(&mut self) {
        self.size = ::std::option::Option::None;
    }

    pub fn has_size(&self) -> bool {
        self.size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: u64) {
        self.size = ::std::option::Option::Some(v);
    }

    // optional uint64 bid = 4;

    pub fn bid(&self) -> u64 {
        self.bid.unwrap_or(0)
    }

    pub fn clear_bid(&mut self) {
        self.bid = ::std::option::Option::None;
    }

    pub fn has_bid(&self) -> bool {
        self.bid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bid(&mut self, v: u64) {
        self.bid = ::std::option::Option::Some(v);
    }

    // optional uint64 ask = 5;

    pub fn ask(&self) -> u64 {
        self.ask.unwrap_or(0)
    }

    pub fn clear_ask(&mut self) {
        self.ask = ::std::option::Option::None;
    }

    pub fn has_ask(&self) -> bool {
        self.ask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ask(&mut self, v: u64) {
        self.ask = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &ProtoOADepthQuote| { &m.id },
            |m: &mut ProtoOADepthQuote| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "size",
            |m: &ProtoOADepthQuote| { &m.size },
            |m: &mut ProtoOADepthQuote| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bid",
            |m: &ProtoOADepthQuote| { &m.bid },
            |m: &mut ProtoOADepthQuote| { &mut m.bid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ask",
            |m: &ProtoOADepthQuote| { &m.ask },
            |m: &mut ProtoOADepthQuote| { &mut m.ask },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADepthQuote>(
            "ProtoOADepthQuote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADepthQuote {
    const NAME: &'static str = "ProtoOADepthQuote";

    fn is_initialized(&self) -> bool {
        if self.id.is_none() {
            return false;
        }
        if self.size.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.size = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.bid = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.ask = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.size {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.bid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.ask {
            my_size += ::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.size {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.bid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.ask {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADepthQuote {
        ProtoOADepthQuote::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.size = ::std::option::Option::None;
        self.bid = ::std::option::Option::None;
        self.ask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADepthQuote {
        static instance: ProtoOADepthQuote = ProtoOADepthQuote {
            id: ::std::option::Option::None,
            size: ::std::option::Option::None,
            bid: ::std::option::Option::None,
            ask: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADepthQuote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADepthQuote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADepthQuote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADepthQuote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAMarginCall)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAMarginCall {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAMarginCall.marginCallType)
    pub marginCallType: ::std::option::Option<::protobuf::EnumOrUnknown<ProtoOANotificationType>>,
    // @@protoc_insertion_point(field:ProtoOAMarginCall.marginLevelThreshold)
    pub marginLevelThreshold: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:ProtoOAMarginCall.utcLastUpdateTimestamp)
    pub utcLastUpdateTimestamp: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAMarginCall.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAMarginCall {
    fn default() -> &'a ProtoOAMarginCall {
        <ProtoOAMarginCall as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAMarginCall {
    pub fn new() -> ProtoOAMarginCall {
        ::std::default::Default::default()
    }

    // required .ProtoOANotificationType marginCallType = 1;

    pub fn marginCallType(&self) -> ProtoOANotificationType {
        match self.marginCallType {
            Some(e) => e.enum_value_or(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1),
            None => ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1,
        }
    }

    pub fn clear_marginCallType(&mut self) {
        self.marginCallType = ::std::option::Option::None;
    }

    pub fn has_marginCallType(&self) -> bool {
        self.marginCallType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marginCallType(&mut self, v: ProtoOANotificationType) {
        self.marginCallType = ::std::option::Option::Some(::protobuf::EnumOrUnknown::new(v));
    }

    // required double marginLevelThreshold = 2;

    pub fn marginLevelThreshold(&self) -> f64 {
        self.marginLevelThreshold.unwrap_or(0.)
    }

    pub fn clear_marginLevelThreshold(&mut self) {
        self.marginLevelThreshold = ::std::option::Option::None;
    }

    pub fn has_marginLevelThreshold(&self) -> bool {
        self.marginLevelThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_marginLevelThreshold(&mut self, v: f64) {
        self.marginLevelThreshold = ::std::option::Option::Some(v);
    }

    // optional int64 utcLastUpdateTimestamp = 3;

    pub fn utcLastUpdateTimestamp(&self) -> i64 {
        self.utcLastUpdateTimestamp.unwrap_or(0)
    }

    pub fn clear_utcLastUpdateTimestamp(&mut self) {
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
    }

    pub fn has_utcLastUpdateTimestamp(&self) -> bool {
        self.utcLastUpdateTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utcLastUpdateTimestamp(&mut self, v: i64) {
        self.utcLastUpdateTimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "marginCallType",
            |m: &ProtoOAMarginCall| { &m.marginCallType },
            |m: &mut ProtoOAMarginCall| { &mut m.marginCallType },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "marginLevelThreshold",
            |m: &ProtoOAMarginCall| { &m.marginLevelThreshold },
            |m: &mut ProtoOAMarginCall| { &mut m.marginLevelThreshold },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "utcLastUpdateTimestamp",
            |m: &ProtoOAMarginCall| { &m.utcLastUpdateTimestamp },
            |m: &mut ProtoOAMarginCall| { &mut m.utcLastUpdateTimestamp },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAMarginCall>(
            "ProtoOAMarginCall",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAMarginCall {
    const NAME: &'static str = "ProtoOAMarginCall";

    fn is_initialized(&self) -> bool {
        if self.marginCallType.is_none() {
            return false;
        }
        if self.marginLevelThreshold.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.marginCallType = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.marginLevelThreshold = ::std::option::Option::Some(is.read_double()?);
                },
                24 => {
                    self.utcLastUpdateTimestamp = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.marginCallType {
            my_size += ::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.marginLevelThreshold {
            my_size += 1 + 8;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.marginCallType {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.marginLevelThreshold {
            os.write_double(2, v)?;
        }
        if let Some(v) = self.utcLastUpdateTimestamp {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAMarginCall {
        ProtoOAMarginCall::new()
    }

    fn clear(&mut self) {
        self.marginCallType = ::std::option::Option::None;
        self.marginLevelThreshold = ::std::option::Option::None;
        self.utcLastUpdateTimestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAMarginCall {
        static instance: ProtoOAMarginCall = ProtoOAMarginCall {
            marginCallType: ::std::option::Option::None,
            marginLevelThreshold: ::std::option::Option::None,
            utcLastUpdateTimestamp: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAMarginCall {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAMarginCall").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAMarginCall {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAMarginCall {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAHoliday)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAHoliday {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAHoliday.holidayId)
    pub holidayId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.scheduleTimeZone)
    pub scheduleTimeZone: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.holidayDate)
    pub holidayDate: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.isRecurring)
    pub isRecurring: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.startSecond)
    pub startSecond: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:ProtoOAHoliday.endSecond)
    pub endSecond: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAHoliday.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAHoliday {
    fn default() -> &'a ProtoOAHoliday {
        <ProtoOAHoliday as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAHoliday {
    pub fn new() -> ProtoOAHoliday {
        ::std::default::Default::default()
    }

    // required int64 holidayId = 1;

    pub fn holidayId(&self) -> i64 {
        self.holidayId.unwrap_or(0)
    }

    pub fn clear_holidayId(&mut self) {
        self.holidayId = ::std::option::Option::None;
    }

    pub fn has_holidayId(&self) -> bool {
        self.holidayId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holidayId(&mut self, v: i64) {
        self.holidayId = ::std::option::Option::Some(v);
    }

    // required string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required string scheduleTimeZone = 4;

    pub fn scheduleTimeZone(&self) -> &str {
        match self.scheduleTimeZone.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_scheduleTimeZone(&mut self) {
        self.scheduleTimeZone = ::std::option::Option::None;
    }

    pub fn has_scheduleTimeZone(&self) -> bool {
        self.scheduleTimeZone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheduleTimeZone(&mut self, v: ::std::string::String) {
        self.scheduleTimeZone = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheduleTimeZone(&mut self) -> &mut ::std::string::String {
        if self.scheduleTimeZone.is_none() {
            self.scheduleTimeZone = ::std::option::Option::Some(::std::string::String::new());
        }
        self.scheduleTimeZone.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheduleTimeZone(&mut self) -> ::std::string::String {
        self.scheduleTimeZone.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // required int64 holidayDate = 5;

    pub fn holidayDate(&self) -> i64 {
        self.holidayDate.unwrap_or(0)
    }

    pub fn clear_holidayDate(&mut self) {
        self.holidayDate = ::std::option::Option::None;
    }

    pub fn has_holidayDate(&self) -> bool {
        self.holidayDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holidayDate(&mut self, v: i64) {
        self.holidayDate = ::std::option::Option::Some(v);
    }

    // required bool isRecurring = 6;

    pub fn isRecurring(&self) -> bool {
        self.isRecurring.unwrap_or(false)
    }

    pub fn clear_isRecurring(&mut self) {
        self.isRecurring = ::std::option::Option::None;
    }

    pub fn has_isRecurring(&self) -> bool {
        self.isRecurring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isRecurring(&mut self, v: bool) {
        self.isRecurring = ::std::option::Option::Some(v);
    }

    // optional int32 startSecond = 7;

    pub fn startSecond(&self) -> i32 {
        self.startSecond.unwrap_or(0)
    }

    pub fn clear_startSecond(&mut self) {
        self.startSecond = ::std::option::Option::None;
    }

    pub fn has_startSecond(&self) -> bool {
        self.startSecond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startSecond(&mut self, v: i32) {
        self.startSecond = ::std::option::Option::Some(v);
    }

    // optional int32 endSecond = 8;

    pub fn endSecond(&self) -> i32 {
        self.endSecond.unwrap_or(0)
    }

    pub fn clear_endSecond(&mut self) {
        self.endSecond = ::std::option::Option::None;
    }

    pub fn has_endSecond(&self) -> bool {
        self.endSecond.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endSecond(&mut self, v: i32) {
        self.endSecond = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "holidayId",
            |m: &ProtoOAHoliday| { &m.holidayId },
            |m: &mut ProtoOAHoliday| { &mut m.holidayId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ProtoOAHoliday| { &m.name },
            |m: &mut ProtoOAHoliday| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "description",
            |m: &ProtoOAHoliday| { &m.description },
            |m: &mut ProtoOAHoliday| { &mut m.description },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "scheduleTimeZone",
            |m: &ProtoOAHoliday| { &m.scheduleTimeZone },
            |m: &mut ProtoOAHoliday| { &mut m.scheduleTimeZone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "holidayDate",
            |m: &ProtoOAHoliday| { &m.holidayDate },
            |m: &mut ProtoOAHoliday| { &mut m.holidayDate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "isRecurring",
            |m: &ProtoOAHoliday| { &m.isRecurring },
            |m: &mut ProtoOAHoliday| { &mut m.isRecurring },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "startSecond",
            |m: &ProtoOAHoliday| { &m.startSecond },
            |m: &mut ProtoOAHoliday| { &mut m.startSecond },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "endSecond",
            |m: &ProtoOAHoliday| { &m.endSecond },
            |m: &mut ProtoOAHoliday| { &mut m.endSecond },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAHoliday>(
            "ProtoOAHoliday",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAHoliday {
    const NAME: &'static str = "ProtoOAHoliday";

    fn is_initialized(&self) -> bool {
        if self.holidayId.is_none() {
            return false;
        }
        if self.name.is_none() {
            return false;
        }
        if self.scheduleTimeZone.is_none() {
            return false;
        }
        if self.holidayDate.is_none() {
            return false;
        }
        if self.isRecurring.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.holidayId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.scheduleTimeZone = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.holidayDate = ::std::option::Option::Some(is.read_int64()?);
                },
                48 => {
                    self.isRecurring = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.startSecond = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.endSecond = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.holidayId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.scheduleTimeZone.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.holidayDate {
            my_size += ::protobuf::rt::int64_size(5, v);
        }
        if let Some(v) = self.isRecurring {
            my_size += 1 + 1;
        }
        if let Some(v) = self.startSecond {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.endSecond {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.holidayId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.scheduleTimeZone.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.holidayDate {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.isRecurring {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.startSecond {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.endSecond {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAHoliday {
        ProtoOAHoliday::new()
    }

    fn clear(&mut self) {
        self.holidayId = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.scheduleTimeZone = ::std::option::Option::None;
        self.holidayDate = ::std::option::Option::None;
        self.isRecurring = ::std::option::Option::None;
        self.startSecond = ::std::option::Option::None;
        self.endSecond = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAHoliday {
        static instance: ProtoOAHoliday = ProtoOAHoliday {
            holidayId: ::std::option::Option::None,
            name: ::std::option::Option::None,
            description: ::std::option::Option::None,
            scheduleTimeZone: ::std::option::Option::None,
            holidayDate: ::std::option::Option::None,
            isRecurring: ::std::option::Option::None,
            startSecond: ::std::option::Option::None,
            endSecond: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAHoliday {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAHoliday").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAHoliday {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAHoliday {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADynamicLeverage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADynamicLeverage {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADynamicLeverage.leverageId)
    pub leverageId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADynamicLeverage.tiers)
    pub tiers: ::std::vec::Vec<ProtoOADynamicLeverageTier>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADynamicLeverage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADynamicLeverage {
    fn default() -> &'a ProtoOADynamicLeverage {
        <ProtoOADynamicLeverage as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADynamicLeverage {
    pub fn new() -> ProtoOADynamicLeverage {
        ::std::default::Default::default()
    }

    // required int64 leverageId = 1;

    pub fn leverageId(&self) -> i64 {
        self.leverageId.unwrap_or(0)
    }

    pub fn clear_leverageId(&mut self) {
        self.leverageId = ::std::option::Option::None;
    }

    pub fn has_leverageId(&self) -> bool {
        self.leverageId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leverageId(&mut self, v: i64) {
        self.leverageId = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leverageId",
            |m: &ProtoOADynamicLeverage| { &m.leverageId },
            |m: &mut ProtoOADynamicLeverage| { &mut m.leverageId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tiers",
            |m: &ProtoOADynamicLeverage| { &m.tiers },
            |m: &mut ProtoOADynamicLeverage| { &mut m.tiers },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADynamicLeverage>(
            "ProtoOADynamicLeverage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADynamicLeverage {
    const NAME: &'static str = "ProtoOADynamicLeverage";

    fn is_initialized(&self) -> bool {
        if self.leverageId.is_none() {
            return false;
        }
        for v in &self.tiers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.leverageId = ::std::option::Option::Some(is.read_int64()?);
                },
                18 => {
                    self.tiers.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.leverageId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        for value in &self.tiers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.leverageId {
            os.write_int64(1, v)?;
        }
        for v in &self.tiers {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADynamicLeverage {
        ProtoOADynamicLeverage::new()
    }

    fn clear(&mut self) {
        self.leverageId = ::std::option::Option::None;
        self.tiers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADynamicLeverage {
        static instance: ProtoOADynamicLeverage = ProtoOADynamicLeverage {
            leverageId: ::std::option::Option::None,
            tiers: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADynamicLeverage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADynamicLeverage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADynamicLeverage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADynamicLeverage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOADynamicLeverageTier)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOADynamicLeverageTier {
    // message fields
    // @@protoc_insertion_point(field:ProtoOADynamicLeverageTier.volume)
    pub volume: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOADynamicLeverageTier.leverage)
    pub leverage: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOADynamicLeverageTier.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOADynamicLeverageTier {
    fn default() -> &'a ProtoOADynamicLeverageTier {
        <ProtoOADynamicLeverageTier as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOADynamicLeverageTier {
    pub fn new() -> ProtoOADynamicLeverageTier {
        ::std::default::Default::default()
    }

    // required int64 volume = 1;

    pub fn volume(&self) -> i64 {
        self.volume.unwrap_or(0)
    }

    pub fn clear_volume(&mut self) {
        self.volume = ::std::option::Option::None;
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: i64) {
        self.volume = ::std::option::Option::Some(v);
    }

    // required int32 leverage = 2;

    pub fn leverage(&self) -> i32 {
        self.leverage.unwrap_or(0)
    }

    pub fn clear_leverage(&mut self) {
        self.leverage = ::std::option::Option::None;
    }

    pub fn has_leverage(&self) -> bool {
        self.leverage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leverage(&mut self, v: i32) {
        self.leverage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "volume",
            |m: &ProtoOADynamicLeverageTier| { &m.volume },
            |m: &mut ProtoOADynamicLeverageTier| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "leverage",
            |m: &ProtoOADynamicLeverageTier| { &m.leverage },
            |m: &mut ProtoOADynamicLeverageTier| { &mut m.leverage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOADynamicLeverageTier>(
            "ProtoOADynamicLeverageTier",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOADynamicLeverageTier {
    const NAME: &'static str = "ProtoOADynamicLeverageTier";

    fn is_initialized(&self) -> bool {
        if self.volume.is_none() {
            return false;
        }
        if self.leverage.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.volume = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.leverage = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volume {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.leverage {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volume {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.leverage {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOADynamicLeverageTier {
        ProtoOADynamicLeverageTier::new()
    }

    fn clear(&mut self) {
        self.volume = ::std::option::Option::None;
        self.leverage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOADynamicLeverageTier {
        static instance: ProtoOADynamicLeverageTier = ProtoOADynamicLeverageTier {
            volume: ::std::option::Option::None,
            leverage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOADynamicLeverageTier {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOADynamicLeverageTier").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOADynamicLeverageTier {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOADynamicLeverageTier {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ProtoOAPositionUnrealizedPnL)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ProtoOAPositionUnrealizedPnL {
    // message fields
    // @@protoc_insertion_point(field:ProtoOAPositionUnrealizedPnL.positionId)
    pub positionId: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPositionUnrealizedPnL.grossUnrealizedPnL)
    pub grossUnrealizedPnL: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:ProtoOAPositionUnrealizedPnL.netUnrealizedPnL)
    pub netUnrealizedPnL: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:ProtoOAPositionUnrealizedPnL.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ProtoOAPositionUnrealizedPnL {
    fn default() -> &'a ProtoOAPositionUnrealizedPnL {
        <ProtoOAPositionUnrealizedPnL as ::protobuf::Message>::default_instance()
    }
}

impl ProtoOAPositionUnrealizedPnL {
    pub fn new() -> ProtoOAPositionUnrealizedPnL {
        ::std::default::Default::default()
    }

    // required int64 positionId = 1;

    pub fn positionId(&self) -> i64 {
        self.positionId.unwrap_or(0)
    }

    pub fn clear_positionId(&mut self) {
        self.positionId = ::std::option::Option::None;
    }

    pub fn has_positionId(&self) -> bool {
        self.positionId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positionId(&mut self, v: i64) {
        self.positionId = ::std::option::Option::Some(v);
    }

    // required int64 grossUnrealizedPnL = 2;

    pub fn grossUnrealizedPnL(&self) -> i64 {
        self.grossUnrealizedPnL.unwrap_or(0)
    }

    pub fn clear_grossUnrealizedPnL(&mut self) {
        self.grossUnrealizedPnL = ::std::option::Option::None;
    }

    pub fn has_grossUnrealizedPnL(&self) -> bool {
        self.grossUnrealizedPnL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grossUnrealizedPnL(&mut self, v: i64) {
        self.grossUnrealizedPnL = ::std::option::Option::Some(v);
    }

    // required int64 netUnrealizedPnL = 3;

    pub fn netUnrealizedPnL(&self) -> i64 {
        self.netUnrealizedPnL.unwrap_or(0)
    }

    pub fn clear_netUnrealizedPnL(&mut self) {
        self.netUnrealizedPnL = ::std::option::Option::None;
    }

    pub fn has_netUnrealizedPnL(&self) -> bool {
        self.netUnrealizedPnL.is_some()
    }

    // Param is passed by value, moved
    pub fn set_netUnrealizedPnL(&mut self, v: i64) {
        self.netUnrealizedPnL = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "positionId",
            |m: &ProtoOAPositionUnrealizedPnL| { &m.positionId },
            |m: &mut ProtoOAPositionUnrealizedPnL| { &mut m.positionId },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "grossUnrealizedPnL",
            |m: &ProtoOAPositionUnrealizedPnL| { &m.grossUnrealizedPnL },
            |m: &mut ProtoOAPositionUnrealizedPnL| { &mut m.grossUnrealizedPnL },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "netUnrealizedPnL",
            |m: &ProtoOAPositionUnrealizedPnL| { &m.netUnrealizedPnL },
            |m: &mut ProtoOAPositionUnrealizedPnL| { &mut m.netUnrealizedPnL },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ProtoOAPositionUnrealizedPnL>(
            "ProtoOAPositionUnrealizedPnL",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ProtoOAPositionUnrealizedPnL {
    const NAME: &'static str = "ProtoOAPositionUnrealizedPnL";

    fn is_initialized(&self) -> bool {
        if self.positionId.is_none() {
            return false;
        }
        if self.grossUnrealizedPnL.is_none() {
            return false;
        }
        if self.netUnrealizedPnL.is_none() {
            return false;
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.positionId = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.grossUnrealizedPnL = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.netUnrealizedPnL = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.positionId {
            my_size += ::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.grossUnrealizedPnL {
            my_size += ::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.netUnrealizedPnL {
            my_size += ::protobuf::rt::int64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.positionId {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.grossUnrealizedPnL {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.netUnrealizedPnL {
            os.write_int64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ProtoOAPositionUnrealizedPnL {
        ProtoOAPositionUnrealizedPnL::new()
    }

    fn clear(&mut self) {
        self.positionId = ::std::option::Option::None;
        self.grossUnrealizedPnL = ::std::option::Option::None;
        self.netUnrealizedPnL = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ProtoOAPositionUnrealizedPnL {
        static instance: ProtoOAPositionUnrealizedPnL = ProtoOAPositionUnrealizedPnL {
            positionId: ::std::option::Option::None,
            grossUnrealizedPnL: ::std::option::Option::None,
            netUnrealizedPnL: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ProtoOAPositionUnrealizedPnL {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ProtoOAPositionUnrealizedPnL").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ProtoOAPositionUnrealizedPnL {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProtoOAPositionUnrealizedPnL {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAPayloadType)
pub enum ProtoOAPayloadType {
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_APPLICATION_AUTH_REQ)
    PROTO_OA_APPLICATION_AUTH_REQ = 2100,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_APPLICATION_AUTH_RES)
    PROTO_OA_APPLICATION_AUTH_RES = 2101,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ACCOUNT_AUTH_REQ)
    PROTO_OA_ACCOUNT_AUTH_REQ = 2102,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ACCOUNT_AUTH_RES)
    PROTO_OA_ACCOUNT_AUTH_RES = 2103,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_VERSION_REQ)
    PROTO_OA_VERSION_REQ = 2104,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_VERSION_RES)
    PROTO_OA_VERSION_RES = 2105,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_NEW_ORDER_REQ)
    PROTO_OA_NEW_ORDER_REQ = 2106,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_TRAILING_SL_CHANGED_EVENT)
    PROTO_OA_TRAILING_SL_CHANGED_EVENT = 2107,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_CANCEL_ORDER_REQ)
    PROTO_OA_CANCEL_ORDER_REQ = 2108,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_AMEND_ORDER_REQ)
    PROTO_OA_AMEND_ORDER_REQ = 2109,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_AMEND_POSITION_SLTP_REQ)
    PROTO_OA_AMEND_POSITION_SLTP_REQ = 2110,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_CLOSE_POSITION_REQ)
    PROTO_OA_CLOSE_POSITION_REQ = 2111,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ASSET_LIST_REQ)
    PROTO_OA_ASSET_LIST_REQ = 2112,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ASSET_LIST_RES)
    PROTO_OA_ASSET_LIST_RES = 2113,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOLS_LIST_REQ)
    PROTO_OA_SYMBOLS_LIST_REQ = 2114,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOLS_LIST_RES)
    PROTO_OA_SYMBOLS_LIST_RES = 2115,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOL_BY_ID_REQ)
    PROTO_OA_SYMBOL_BY_ID_REQ = 2116,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOL_BY_ID_RES)
    PROTO_OA_SYMBOL_BY_ID_RES = 2117,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ)
    PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ = 2118,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOLS_FOR_CONVERSION_RES)
    PROTO_OA_SYMBOLS_FOR_CONVERSION_RES = 2119,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOL_CHANGED_EVENT)
    PROTO_OA_SYMBOL_CHANGED_EVENT = 2120,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_TRADER_REQ)
    PROTO_OA_TRADER_REQ = 2121,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_TRADER_RES)
    PROTO_OA_TRADER_RES = 2122,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_TRADER_UPDATE_EVENT)
    PROTO_OA_TRADER_UPDATE_EVENT = 2123,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_RECONCILE_REQ)
    PROTO_OA_RECONCILE_REQ = 2124,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_RECONCILE_RES)
    PROTO_OA_RECONCILE_RES = 2125,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_EXECUTION_EVENT)
    PROTO_OA_EXECUTION_EVENT = 2126,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SUBSCRIBE_SPOTS_REQ)
    PROTO_OA_SUBSCRIBE_SPOTS_REQ = 2127,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SUBSCRIBE_SPOTS_RES)
    PROTO_OA_SUBSCRIBE_SPOTS_RES = 2128,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_UNSUBSCRIBE_SPOTS_REQ)
    PROTO_OA_UNSUBSCRIBE_SPOTS_REQ = 2129,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_UNSUBSCRIBE_SPOTS_RES)
    PROTO_OA_UNSUBSCRIBE_SPOTS_RES = 2130,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SPOT_EVENT)
    PROTO_OA_SPOT_EVENT = 2131,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_ERROR_EVENT)
    PROTO_OA_ORDER_ERROR_EVENT = 2132,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEAL_LIST_REQ)
    PROTO_OA_DEAL_LIST_REQ = 2133,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEAL_LIST_RES)
    PROTO_OA_DEAL_LIST_RES = 2134,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ)
    PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ = 2135,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ)
    PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ = 2136,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_TRENDBARS_REQ)
    PROTO_OA_GET_TRENDBARS_REQ = 2137,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_TRENDBARS_RES)
    PROTO_OA_GET_TRENDBARS_RES = 2138,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_EXPECTED_MARGIN_REQ)
    PROTO_OA_EXPECTED_MARGIN_REQ = 2139,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_EXPECTED_MARGIN_RES)
    PROTO_OA_EXPECTED_MARGIN_RES = 2140,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CHANGED_EVENT)
    PROTO_OA_MARGIN_CHANGED_EVENT = 2141,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ERROR_RES)
    PROTO_OA_ERROR_RES = 2142,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ)
    PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ = 2143,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_CASH_FLOW_HISTORY_LIST_RES)
    PROTO_OA_CASH_FLOW_HISTORY_LIST_RES = 2144,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_TICKDATA_REQ)
    PROTO_OA_GET_TICKDATA_REQ = 2145,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_TICKDATA_RES)
    PROTO_OA_GET_TICKDATA_RES = 2146,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT)
    PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT = 2147,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_CLIENT_DISCONNECT_EVENT)
    PROTO_OA_CLIENT_DISCONNECT_EVENT = 2148,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ)
    PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ = 2149,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES)
    PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES = 2150,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ)
    PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ = 2151,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES)
    PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES = 2152,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ASSET_CLASS_LIST_REQ)
    PROTO_OA_ASSET_CLASS_LIST_REQ = 2153,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ASSET_CLASS_LIST_RES)
    PROTO_OA_ASSET_CLASS_LIST_RES = 2154,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEPTH_EVENT)
    PROTO_OA_DEPTH_EVENT = 2155,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ)
    PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ = 2156,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES)
    PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES = 2157,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ)
    PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ = 2158,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES)
    PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES = 2159,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOL_CATEGORY_REQ)
    PROTO_OA_SYMBOL_CATEGORY_REQ = 2160,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SYMBOL_CATEGORY_RES)
    PROTO_OA_SYMBOL_CATEGORY_RES = 2161,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ACCOUNT_LOGOUT_REQ)
    PROTO_OA_ACCOUNT_LOGOUT_REQ = 2162,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ACCOUNT_LOGOUT_RES)
    PROTO_OA_ACCOUNT_LOGOUT_RES = 2163,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ACCOUNT_DISCONNECT_EVENT)
    PROTO_OA_ACCOUNT_DISCONNECT_EVENT = 2164,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES)
    PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES = 2165,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES)
    PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES = 2166,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CALL_LIST_REQ)
    PROTO_OA_MARGIN_CALL_LIST_REQ = 2167,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CALL_LIST_RES)
    PROTO_OA_MARGIN_CALL_LIST_RES = 2168,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CALL_UPDATE_REQ)
    PROTO_OA_MARGIN_CALL_UPDATE_REQ = 2169,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CALL_UPDATE_RES)
    PROTO_OA_MARGIN_CALL_UPDATE_RES = 2170,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CALL_UPDATE_EVENT)
    PROTO_OA_MARGIN_CALL_UPDATE_EVENT = 2171,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_MARGIN_CALL_TRIGGER_EVENT)
    PROTO_OA_MARGIN_CALL_TRIGGER_EVENT = 2172,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_REFRESH_TOKEN_REQ)
    PROTO_OA_REFRESH_TOKEN_REQ = 2173,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_REFRESH_TOKEN_RES)
    PROTO_OA_REFRESH_TOKEN_RES = 2174,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_LIST_REQ)
    PROTO_OA_ORDER_LIST_REQ = 2175,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_LIST_RES)
    PROTO_OA_ORDER_LIST_RES = 2176,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ)
    PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ = 2177,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_DYNAMIC_LEVERAGE_RES)
    PROTO_OA_GET_DYNAMIC_LEVERAGE_RES = 2178,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ)
    PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ = 2179,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES)
    PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES = 2180,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_DETAILS_REQ)
    PROTO_OA_ORDER_DETAILS_REQ = 2181,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_DETAILS_RES)
    PROTO_OA_ORDER_DETAILS_RES = 2182,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ)
    PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ = 2183,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES)
    PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES = 2184,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEAL_OFFSET_LIST_REQ)
    PROTO_OA_DEAL_OFFSET_LIST_REQ = 2185,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_DEAL_OFFSET_LIST_RES)
    PROTO_OA_DEAL_OFFSET_LIST_RES = 2186,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ)
    PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ = 2187,
    // @@protoc_insertion_point(enum_value:ProtoOAPayloadType.PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES)
    PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES = 2188,
}

impl ::protobuf::Enum for ProtoOAPayloadType {
    const NAME: &'static str = "ProtoOAPayloadType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAPayloadType> {
        match value {
            2100 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ),
            2101 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_RES),
            2102 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_REQ),
            2103 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_RES),
            2104 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_VERSION_REQ),
            2105 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_VERSION_RES),
            2106 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_NEW_ORDER_REQ),
            2107 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRAILING_SL_CHANGED_EVENT),
            2108 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CANCEL_ORDER_REQ),
            2109 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_AMEND_ORDER_REQ),
            2110 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_AMEND_POSITION_SLTP_REQ),
            2111 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CLOSE_POSITION_REQ),
            2112 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_LIST_REQ),
            2113 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_LIST_RES),
            2114 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_REQ),
            2115 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_RES),
            2116 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_REQ),
            2117 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_RES),
            2118 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ),
            2119 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_RES),
            2120 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_CHANGED_EVENT),
            2121 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRADER_REQ),
            2122 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRADER_RES),
            2123 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRADER_UPDATE_EVENT),
            2124 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_RECONCILE_REQ),
            2125 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_RECONCILE_RES),
            2126 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_EXECUTION_EVENT),
            2127 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_REQ),
            2128 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_RES),
            2129 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_REQ),
            2130 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_RES),
            2131 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SPOT_EVENT),
            2132 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_ERROR_EVENT),
            2133 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_REQ),
            2134 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_RES),
            2135 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ),
            2136 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ),
            2137 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_REQ),
            2138 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_RES),
            2139 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_REQ),
            2140 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_RES),
            2141 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CHANGED_EVENT),
            2142 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ERROR_RES),
            2143 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ),
            2144 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_RES),
            2145 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_REQ),
            2146 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_RES),
            2147 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT),
            2148 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CLIENT_DISCONNECT_EVENT),
            2149 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ),
            2150 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES),
            2151 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ),
            2152 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES),
            2153 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_REQ),
            2154 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_RES),
            2155 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEPTH_EVENT),
            2156 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ),
            2157 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES),
            2158 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ),
            2159 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES),
            2160 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_REQ),
            2161 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_RES),
            2162 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_REQ),
            2163 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_RES),
            2164 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_DISCONNECT_EVENT),
            2165 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES),
            2166 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES),
            2167 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_REQ),
            2168 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_RES),
            2169 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_REQ),
            2170 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_RES),
            2171 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_EVENT),
            2172 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_TRIGGER_EVENT),
            2173 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_REQ),
            2174 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_RES),
            2175 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_REQ),
            2176 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_RES),
            2177 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ),
            2178 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_RES),
            2179 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ),
            2180 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES),
            2181 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_REQ),
            2182 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_RES),
            2183 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ),
            2184 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES),
            2185 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_REQ),
            2186 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_RES),
            2187 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ),
            2188 => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAPayloadType> {
        match str {
            "PROTO_OA_APPLICATION_AUTH_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ),
            "PROTO_OA_APPLICATION_AUTH_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_RES),
            "PROTO_OA_ACCOUNT_AUTH_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_REQ),
            "PROTO_OA_ACCOUNT_AUTH_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_RES),
            "PROTO_OA_VERSION_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_VERSION_REQ),
            "PROTO_OA_VERSION_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_VERSION_RES),
            "PROTO_OA_NEW_ORDER_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_NEW_ORDER_REQ),
            "PROTO_OA_TRAILING_SL_CHANGED_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRAILING_SL_CHANGED_EVENT),
            "PROTO_OA_CANCEL_ORDER_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CANCEL_ORDER_REQ),
            "PROTO_OA_AMEND_ORDER_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_AMEND_ORDER_REQ),
            "PROTO_OA_AMEND_POSITION_SLTP_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_AMEND_POSITION_SLTP_REQ),
            "PROTO_OA_CLOSE_POSITION_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CLOSE_POSITION_REQ),
            "PROTO_OA_ASSET_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_LIST_REQ),
            "PROTO_OA_ASSET_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_LIST_RES),
            "PROTO_OA_SYMBOLS_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_REQ),
            "PROTO_OA_SYMBOLS_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_RES),
            "PROTO_OA_SYMBOL_BY_ID_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_REQ),
            "PROTO_OA_SYMBOL_BY_ID_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_RES),
            "PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ),
            "PROTO_OA_SYMBOLS_FOR_CONVERSION_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_RES),
            "PROTO_OA_SYMBOL_CHANGED_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_CHANGED_EVENT),
            "PROTO_OA_TRADER_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRADER_REQ),
            "PROTO_OA_TRADER_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRADER_RES),
            "PROTO_OA_TRADER_UPDATE_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_TRADER_UPDATE_EVENT),
            "PROTO_OA_RECONCILE_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_RECONCILE_REQ),
            "PROTO_OA_RECONCILE_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_RECONCILE_RES),
            "PROTO_OA_EXECUTION_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_EXECUTION_EVENT),
            "PROTO_OA_SUBSCRIBE_SPOTS_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_REQ),
            "PROTO_OA_SUBSCRIBE_SPOTS_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_RES),
            "PROTO_OA_UNSUBSCRIBE_SPOTS_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_REQ),
            "PROTO_OA_UNSUBSCRIBE_SPOTS_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_RES),
            "PROTO_OA_SPOT_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SPOT_EVENT),
            "PROTO_OA_ORDER_ERROR_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_ERROR_EVENT),
            "PROTO_OA_DEAL_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_REQ),
            "PROTO_OA_DEAL_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_RES),
            "PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ),
            "PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ),
            "PROTO_OA_GET_TRENDBARS_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_REQ),
            "PROTO_OA_GET_TRENDBARS_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_RES),
            "PROTO_OA_EXPECTED_MARGIN_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_REQ),
            "PROTO_OA_EXPECTED_MARGIN_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_RES),
            "PROTO_OA_MARGIN_CHANGED_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CHANGED_EVENT),
            "PROTO_OA_ERROR_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ERROR_RES),
            "PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ),
            "PROTO_OA_CASH_FLOW_HISTORY_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_RES),
            "PROTO_OA_GET_TICKDATA_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_REQ),
            "PROTO_OA_GET_TICKDATA_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_RES),
            "PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT),
            "PROTO_OA_CLIENT_DISCONNECT_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_CLIENT_DISCONNECT_EVENT),
            "PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ),
            "PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES),
            "PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ),
            "PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES),
            "PROTO_OA_ASSET_CLASS_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_REQ),
            "PROTO_OA_ASSET_CLASS_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_RES),
            "PROTO_OA_DEPTH_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEPTH_EVENT),
            "PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ),
            "PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES),
            "PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ),
            "PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES),
            "PROTO_OA_SYMBOL_CATEGORY_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_REQ),
            "PROTO_OA_SYMBOL_CATEGORY_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_RES),
            "PROTO_OA_ACCOUNT_LOGOUT_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_REQ),
            "PROTO_OA_ACCOUNT_LOGOUT_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_RES),
            "PROTO_OA_ACCOUNT_DISCONNECT_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ACCOUNT_DISCONNECT_EVENT),
            "PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES),
            "PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES),
            "PROTO_OA_MARGIN_CALL_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_REQ),
            "PROTO_OA_MARGIN_CALL_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_RES),
            "PROTO_OA_MARGIN_CALL_UPDATE_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_REQ),
            "PROTO_OA_MARGIN_CALL_UPDATE_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_RES),
            "PROTO_OA_MARGIN_CALL_UPDATE_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_EVENT),
            "PROTO_OA_MARGIN_CALL_TRIGGER_EVENT" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_TRIGGER_EVENT),
            "PROTO_OA_REFRESH_TOKEN_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_REQ),
            "PROTO_OA_REFRESH_TOKEN_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_RES),
            "PROTO_OA_ORDER_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_REQ),
            "PROTO_OA_ORDER_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_RES),
            "PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ),
            "PROTO_OA_GET_DYNAMIC_LEVERAGE_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_RES),
            "PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ),
            "PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES),
            "PROTO_OA_ORDER_DETAILS_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_REQ),
            "PROTO_OA_ORDER_DETAILS_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_RES),
            "PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ),
            "PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES),
            "PROTO_OA_DEAL_OFFSET_LIST_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_REQ),
            "PROTO_OA_DEAL_OFFSET_LIST_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_RES),
            "PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ),
            "PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES" => ::std::option::Option::Some(ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAPayloadType] = &[
        ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ,
        ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_RES,
        ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_REQ,
        ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_RES,
        ProtoOAPayloadType::PROTO_OA_VERSION_REQ,
        ProtoOAPayloadType::PROTO_OA_VERSION_RES,
        ProtoOAPayloadType::PROTO_OA_NEW_ORDER_REQ,
        ProtoOAPayloadType::PROTO_OA_TRAILING_SL_CHANGED_EVENT,
        ProtoOAPayloadType::PROTO_OA_CANCEL_ORDER_REQ,
        ProtoOAPayloadType::PROTO_OA_AMEND_ORDER_REQ,
        ProtoOAPayloadType::PROTO_OA_AMEND_POSITION_SLTP_REQ,
        ProtoOAPayloadType::PROTO_OA_CLOSE_POSITION_REQ,
        ProtoOAPayloadType::PROTO_OA_ASSET_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_ASSET_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_REQ,
        ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_RES,
        ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ,
        ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_RES,
        ProtoOAPayloadType::PROTO_OA_SYMBOL_CHANGED_EVENT,
        ProtoOAPayloadType::PROTO_OA_TRADER_REQ,
        ProtoOAPayloadType::PROTO_OA_TRADER_RES,
        ProtoOAPayloadType::PROTO_OA_TRADER_UPDATE_EVENT,
        ProtoOAPayloadType::PROTO_OA_RECONCILE_REQ,
        ProtoOAPayloadType::PROTO_OA_RECONCILE_RES,
        ProtoOAPayloadType::PROTO_OA_EXECUTION_EVENT,
        ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_REQ,
        ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_RES,
        ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_REQ,
        ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_RES,
        ProtoOAPayloadType::PROTO_OA_SPOT_EVENT,
        ProtoOAPayloadType::PROTO_OA_ORDER_ERROR_EVENT,
        ProtoOAPayloadType::PROTO_OA_DEAL_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_DEAL_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ,
        ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_RES,
        ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_REQ,
        ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_RES,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CHANGED_EVENT,
        ProtoOAPayloadType::PROTO_OA_ERROR_RES,
        ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_RES,
        ProtoOAPayloadType::PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT,
        ProtoOAPayloadType::PROTO_OA_CLIENT_DISCONNECT_EVENT,
        ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES,
        ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES,
        ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_DEPTH_EVENT,
        ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ,
        ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES,
        ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ,
        ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES,
        ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_REQ,
        ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_RES,
        ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_REQ,
        ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_RES,
        ProtoOAPayloadType::PROTO_OA_ACCOUNT_DISCONNECT_EVENT,
        ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES,
        ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_REQ,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_RES,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_EVENT,
        ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_TRIGGER_EVENT,
        ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_REQ,
        ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_RES,
        ProtoOAPayloadType::PROTO_OA_ORDER_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_ORDER_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_RES,
        ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ,
        ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES,
        ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_REQ,
        ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_RES,
        ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ,
        ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES,
        ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_REQ,
        ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_RES,
        ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ,
        ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES,
    ];
}

impl ::protobuf::EnumFull for ProtoOAPayloadType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAPayloadType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ => 0,
            ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_RES => 1,
            ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_REQ => 2,
            ProtoOAPayloadType::PROTO_OA_ACCOUNT_AUTH_RES => 3,
            ProtoOAPayloadType::PROTO_OA_VERSION_REQ => 4,
            ProtoOAPayloadType::PROTO_OA_VERSION_RES => 5,
            ProtoOAPayloadType::PROTO_OA_NEW_ORDER_REQ => 6,
            ProtoOAPayloadType::PROTO_OA_TRAILING_SL_CHANGED_EVENT => 7,
            ProtoOAPayloadType::PROTO_OA_CANCEL_ORDER_REQ => 8,
            ProtoOAPayloadType::PROTO_OA_AMEND_ORDER_REQ => 9,
            ProtoOAPayloadType::PROTO_OA_AMEND_POSITION_SLTP_REQ => 10,
            ProtoOAPayloadType::PROTO_OA_CLOSE_POSITION_REQ => 11,
            ProtoOAPayloadType::PROTO_OA_ASSET_LIST_REQ => 12,
            ProtoOAPayloadType::PROTO_OA_ASSET_LIST_RES => 13,
            ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_REQ => 14,
            ProtoOAPayloadType::PROTO_OA_SYMBOLS_LIST_RES => 15,
            ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_REQ => 16,
            ProtoOAPayloadType::PROTO_OA_SYMBOL_BY_ID_RES => 17,
            ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_REQ => 18,
            ProtoOAPayloadType::PROTO_OA_SYMBOLS_FOR_CONVERSION_RES => 19,
            ProtoOAPayloadType::PROTO_OA_SYMBOL_CHANGED_EVENT => 20,
            ProtoOAPayloadType::PROTO_OA_TRADER_REQ => 21,
            ProtoOAPayloadType::PROTO_OA_TRADER_RES => 22,
            ProtoOAPayloadType::PROTO_OA_TRADER_UPDATE_EVENT => 23,
            ProtoOAPayloadType::PROTO_OA_RECONCILE_REQ => 24,
            ProtoOAPayloadType::PROTO_OA_RECONCILE_RES => 25,
            ProtoOAPayloadType::PROTO_OA_EXECUTION_EVENT => 26,
            ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_REQ => 27,
            ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_SPOTS_RES => 28,
            ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_REQ => 29,
            ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_SPOTS_RES => 30,
            ProtoOAPayloadType::PROTO_OA_SPOT_EVENT => 31,
            ProtoOAPayloadType::PROTO_OA_ORDER_ERROR_EVENT => 32,
            ProtoOAPayloadType::PROTO_OA_DEAL_LIST_REQ => 33,
            ProtoOAPayloadType::PROTO_OA_DEAL_LIST_RES => 34,
            ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_REQ => 35,
            ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_REQ => 36,
            ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_REQ => 37,
            ProtoOAPayloadType::PROTO_OA_GET_TRENDBARS_RES => 38,
            ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_REQ => 39,
            ProtoOAPayloadType::PROTO_OA_EXPECTED_MARGIN_RES => 40,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CHANGED_EVENT => 41,
            ProtoOAPayloadType::PROTO_OA_ERROR_RES => 42,
            ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_REQ => 43,
            ProtoOAPayloadType::PROTO_OA_CASH_FLOW_HISTORY_LIST_RES => 44,
            ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_REQ => 45,
            ProtoOAPayloadType::PROTO_OA_GET_TICKDATA_RES => 46,
            ProtoOAPayloadType::PROTO_OA_ACCOUNTS_TOKEN_INVALIDATED_EVENT => 47,
            ProtoOAPayloadType::PROTO_OA_CLIENT_DISCONNECT_EVENT => 48,
            ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ => 49,
            ProtoOAPayloadType::PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES => 50,
            ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ => 51,
            ProtoOAPayloadType::PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_RES => 52,
            ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_REQ => 53,
            ProtoOAPayloadType::PROTO_OA_ASSET_CLASS_LIST_RES => 54,
            ProtoOAPayloadType::PROTO_OA_DEPTH_EVENT => 55,
            ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_REQ => 56,
            ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES => 57,
            ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ => 58,
            ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES => 59,
            ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_REQ => 60,
            ProtoOAPayloadType::PROTO_OA_SYMBOL_CATEGORY_RES => 61,
            ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_REQ => 62,
            ProtoOAPayloadType::PROTO_OA_ACCOUNT_LOGOUT_RES => 63,
            ProtoOAPayloadType::PROTO_OA_ACCOUNT_DISCONNECT_EVENT => 64,
            ProtoOAPayloadType::PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_RES => 65,
            ProtoOAPayloadType::PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES => 66,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_REQ => 67,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_LIST_RES => 68,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_REQ => 69,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_RES => 70,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_UPDATE_EVENT => 71,
            ProtoOAPayloadType::PROTO_OA_MARGIN_CALL_TRIGGER_EVENT => 72,
            ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_REQ => 73,
            ProtoOAPayloadType::PROTO_OA_REFRESH_TOKEN_RES => 74,
            ProtoOAPayloadType::PROTO_OA_ORDER_LIST_REQ => 75,
            ProtoOAPayloadType::PROTO_OA_ORDER_LIST_RES => 76,
            ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ => 77,
            ProtoOAPayloadType::PROTO_OA_GET_DYNAMIC_LEVERAGE_RES => 78,
            ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_REQ => 79,
            ProtoOAPayloadType::PROTO_OA_DEAL_LIST_BY_POSITION_ID_RES => 80,
            ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_REQ => 81,
            ProtoOAPayloadType::PROTO_OA_ORDER_DETAILS_RES => 82,
            ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_REQ => 83,
            ProtoOAPayloadType::PROTO_OA_ORDER_LIST_BY_POSITION_ID_RES => 84,
            ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_REQ => 85,
            ProtoOAPayloadType::PROTO_OA_DEAL_OFFSET_LIST_RES => 86,
            ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ => 87,
            ProtoOAPayloadType::PROTO_OA_GET_POSITION_UNREALIZED_PNL_RES => 88,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAPayloadType {
    fn default() -> Self {
        ProtoOAPayloadType::PROTO_OA_APPLICATION_AUTH_REQ
    }
}

impl ProtoOAPayloadType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAPayloadType>("ProtoOAPayloadType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOADayOfWeek)
pub enum ProtoOADayOfWeek {
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.NONE)
    NONE = 0,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.MONDAY)
    MONDAY = 1,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.TUESDAY)
    TUESDAY = 2,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.WEDNESDAY)
    WEDNESDAY = 3,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.THURSDAY)
    THURSDAY = 4,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.FRIDAY)
    FRIDAY = 5,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.SATURDAY)
    SATURDAY = 6,
    // @@protoc_insertion_point(enum_value:ProtoOADayOfWeek.SUNDAY)
    SUNDAY = 7,
}

impl ::protobuf::Enum for ProtoOADayOfWeek {
    const NAME: &'static str = "ProtoOADayOfWeek";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOADayOfWeek> {
        match value {
            0 => ::std::option::Option::Some(ProtoOADayOfWeek::NONE),
            1 => ::std::option::Option::Some(ProtoOADayOfWeek::MONDAY),
            2 => ::std::option::Option::Some(ProtoOADayOfWeek::TUESDAY),
            3 => ::std::option::Option::Some(ProtoOADayOfWeek::WEDNESDAY),
            4 => ::std::option::Option::Some(ProtoOADayOfWeek::THURSDAY),
            5 => ::std::option::Option::Some(ProtoOADayOfWeek::FRIDAY),
            6 => ::std::option::Option::Some(ProtoOADayOfWeek::SATURDAY),
            7 => ::std::option::Option::Some(ProtoOADayOfWeek::SUNDAY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOADayOfWeek> {
        match str {
            "NONE" => ::std::option::Option::Some(ProtoOADayOfWeek::NONE),
            "MONDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::MONDAY),
            "TUESDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::TUESDAY),
            "WEDNESDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::WEDNESDAY),
            "THURSDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::THURSDAY),
            "FRIDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::FRIDAY),
            "SATURDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::SATURDAY),
            "SUNDAY" => ::std::option::Option::Some(ProtoOADayOfWeek::SUNDAY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOADayOfWeek] = &[
        ProtoOADayOfWeek::NONE,
        ProtoOADayOfWeek::MONDAY,
        ProtoOADayOfWeek::TUESDAY,
        ProtoOADayOfWeek::WEDNESDAY,
        ProtoOADayOfWeek::THURSDAY,
        ProtoOADayOfWeek::FRIDAY,
        ProtoOADayOfWeek::SATURDAY,
        ProtoOADayOfWeek::SUNDAY,
    ];
}

impl ::protobuf::EnumFull for ProtoOADayOfWeek {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOADayOfWeek").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOADayOfWeek {
    fn default() -> Self {
        ProtoOADayOfWeek::NONE
    }
}

impl ProtoOADayOfWeek {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOADayOfWeek>("ProtoOADayOfWeek")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOACommissionType)
pub enum ProtoOACommissionType {
    // @@protoc_insertion_point(enum_value:ProtoOACommissionType.USD_PER_MILLION_USD)
    USD_PER_MILLION_USD = 1,
    // @@protoc_insertion_point(enum_value:ProtoOACommissionType.USD_PER_LOT)
    USD_PER_LOT = 2,
    // @@protoc_insertion_point(enum_value:ProtoOACommissionType.PERCENTAGE_OF_VALUE)
    PERCENTAGE_OF_VALUE = 3,
    // @@protoc_insertion_point(enum_value:ProtoOACommissionType.QUOTE_CCY_PER_LOT)
    QUOTE_CCY_PER_LOT = 4,
}

impl ::protobuf::Enum for ProtoOACommissionType {
    const NAME: &'static str = "ProtoOACommissionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOACommissionType> {
        match value {
            1 => ::std::option::Option::Some(ProtoOACommissionType::USD_PER_MILLION_USD),
            2 => ::std::option::Option::Some(ProtoOACommissionType::USD_PER_LOT),
            3 => ::std::option::Option::Some(ProtoOACommissionType::PERCENTAGE_OF_VALUE),
            4 => ::std::option::Option::Some(ProtoOACommissionType::QUOTE_CCY_PER_LOT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOACommissionType> {
        match str {
            "USD_PER_MILLION_USD" => ::std::option::Option::Some(ProtoOACommissionType::USD_PER_MILLION_USD),
            "USD_PER_LOT" => ::std::option::Option::Some(ProtoOACommissionType::USD_PER_LOT),
            "PERCENTAGE_OF_VALUE" => ::std::option::Option::Some(ProtoOACommissionType::PERCENTAGE_OF_VALUE),
            "QUOTE_CCY_PER_LOT" => ::std::option::Option::Some(ProtoOACommissionType::QUOTE_CCY_PER_LOT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOACommissionType] = &[
        ProtoOACommissionType::USD_PER_MILLION_USD,
        ProtoOACommissionType::USD_PER_LOT,
        ProtoOACommissionType::PERCENTAGE_OF_VALUE,
        ProtoOACommissionType::QUOTE_CCY_PER_LOT,
    ];
}

impl ::protobuf::EnumFull for ProtoOACommissionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOACommissionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOACommissionType::USD_PER_MILLION_USD => 0,
            ProtoOACommissionType::USD_PER_LOT => 1,
            ProtoOACommissionType::PERCENTAGE_OF_VALUE => 2,
            ProtoOACommissionType::QUOTE_CCY_PER_LOT => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOACommissionType {
    fn default() -> Self {
        ProtoOACommissionType::USD_PER_MILLION_USD
    }
}

impl ProtoOACommissionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOACommissionType>("ProtoOACommissionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOASymbolDistanceType)
pub enum ProtoOASymbolDistanceType {
    // @@protoc_insertion_point(enum_value:ProtoOASymbolDistanceType.SYMBOL_DISTANCE_IN_POINTS)
    SYMBOL_DISTANCE_IN_POINTS = 1,
    // @@protoc_insertion_point(enum_value:ProtoOASymbolDistanceType.SYMBOL_DISTANCE_IN_PERCENTAGE)
    SYMBOL_DISTANCE_IN_PERCENTAGE = 2,
}

impl ::protobuf::Enum for ProtoOASymbolDistanceType {
    const NAME: &'static str = "ProtoOASymbolDistanceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOASymbolDistanceType> {
        match value {
            1 => ::std::option::Option::Some(ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS),
            2 => ::std::option::Option::Some(ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_PERCENTAGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOASymbolDistanceType> {
        match str {
            "SYMBOL_DISTANCE_IN_POINTS" => ::std::option::Option::Some(ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS),
            "SYMBOL_DISTANCE_IN_PERCENTAGE" => ::std::option::Option::Some(ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_PERCENTAGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOASymbolDistanceType] = &[
        ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS,
        ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_PERCENTAGE,
    ];
}

impl ::protobuf::EnumFull for ProtoOASymbolDistanceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOASymbolDistanceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS => 0,
            ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_PERCENTAGE => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOASymbolDistanceType {
    fn default() -> Self {
        ProtoOASymbolDistanceType::SYMBOL_DISTANCE_IN_POINTS
    }
}

impl ProtoOASymbolDistanceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOASymbolDistanceType>("ProtoOASymbolDistanceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAMinCommissionType)
pub enum ProtoOAMinCommissionType {
    // @@protoc_insertion_point(enum_value:ProtoOAMinCommissionType.CURRENCY)
    CURRENCY = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAMinCommissionType.QUOTE_CURRENCY)
    QUOTE_CURRENCY = 2,
}

impl ::protobuf::Enum for ProtoOAMinCommissionType {
    const NAME: &'static str = "ProtoOAMinCommissionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAMinCommissionType> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAMinCommissionType::CURRENCY),
            2 => ::std::option::Option::Some(ProtoOAMinCommissionType::QUOTE_CURRENCY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAMinCommissionType> {
        match str {
            "CURRENCY" => ::std::option::Option::Some(ProtoOAMinCommissionType::CURRENCY),
            "QUOTE_CURRENCY" => ::std::option::Option::Some(ProtoOAMinCommissionType::QUOTE_CURRENCY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAMinCommissionType] = &[
        ProtoOAMinCommissionType::CURRENCY,
        ProtoOAMinCommissionType::QUOTE_CURRENCY,
    ];
}

impl ::protobuf::EnumFull for ProtoOAMinCommissionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAMinCommissionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAMinCommissionType::CURRENCY => 0,
            ProtoOAMinCommissionType::QUOTE_CURRENCY => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAMinCommissionType {
    fn default() -> Self {
        ProtoOAMinCommissionType::CURRENCY
    }
}

impl ProtoOAMinCommissionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAMinCommissionType>("ProtoOAMinCommissionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOATradingMode)
pub enum ProtoOATradingMode {
    // @@protoc_insertion_point(enum_value:ProtoOATradingMode.ENABLED)
    ENABLED = 0,
    // @@protoc_insertion_point(enum_value:ProtoOATradingMode.DISABLED_WITHOUT_PENDINGS_EXECUTION)
    DISABLED_WITHOUT_PENDINGS_EXECUTION = 1,
    // @@protoc_insertion_point(enum_value:ProtoOATradingMode.DISABLED_WITH_PENDINGS_EXECUTION)
    DISABLED_WITH_PENDINGS_EXECUTION = 2,
    // @@protoc_insertion_point(enum_value:ProtoOATradingMode.CLOSE_ONLY_MODE)
    CLOSE_ONLY_MODE = 3,
}

impl ::protobuf::Enum for ProtoOATradingMode {
    const NAME: &'static str = "ProtoOATradingMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOATradingMode> {
        match value {
            0 => ::std::option::Option::Some(ProtoOATradingMode::ENABLED),
            1 => ::std::option::Option::Some(ProtoOATradingMode::DISABLED_WITHOUT_PENDINGS_EXECUTION),
            2 => ::std::option::Option::Some(ProtoOATradingMode::DISABLED_WITH_PENDINGS_EXECUTION),
            3 => ::std::option::Option::Some(ProtoOATradingMode::CLOSE_ONLY_MODE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOATradingMode> {
        match str {
            "ENABLED" => ::std::option::Option::Some(ProtoOATradingMode::ENABLED),
            "DISABLED_WITHOUT_PENDINGS_EXECUTION" => ::std::option::Option::Some(ProtoOATradingMode::DISABLED_WITHOUT_PENDINGS_EXECUTION),
            "DISABLED_WITH_PENDINGS_EXECUTION" => ::std::option::Option::Some(ProtoOATradingMode::DISABLED_WITH_PENDINGS_EXECUTION),
            "CLOSE_ONLY_MODE" => ::std::option::Option::Some(ProtoOATradingMode::CLOSE_ONLY_MODE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOATradingMode] = &[
        ProtoOATradingMode::ENABLED,
        ProtoOATradingMode::DISABLED_WITHOUT_PENDINGS_EXECUTION,
        ProtoOATradingMode::DISABLED_WITH_PENDINGS_EXECUTION,
        ProtoOATradingMode::CLOSE_ONLY_MODE,
    ];
}

impl ::protobuf::EnumFull for ProtoOATradingMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOATradingMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOATradingMode {
    fn default() -> Self {
        ProtoOATradingMode::ENABLED
    }
}

impl ProtoOATradingMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOATradingMode>("ProtoOATradingMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOASwapCalculationType)
pub enum ProtoOASwapCalculationType {
    // @@protoc_insertion_point(enum_value:ProtoOASwapCalculationType.PIPS)
    PIPS = 0,
    // @@protoc_insertion_point(enum_value:ProtoOASwapCalculationType.PERCENTAGE)
    PERCENTAGE = 1,
    // @@protoc_insertion_point(enum_value:ProtoOASwapCalculationType.POINTS)
    POINTS = 2,
}

impl ::protobuf::Enum for ProtoOASwapCalculationType {
    const NAME: &'static str = "ProtoOASwapCalculationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOASwapCalculationType> {
        match value {
            0 => ::std::option::Option::Some(ProtoOASwapCalculationType::PIPS),
            1 => ::std::option::Option::Some(ProtoOASwapCalculationType::PERCENTAGE),
            2 => ::std::option::Option::Some(ProtoOASwapCalculationType::POINTS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOASwapCalculationType> {
        match str {
            "PIPS" => ::std::option::Option::Some(ProtoOASwapCalculationType::PIPS),
            "PERCENTAGE" => ::std::option::Option::Some(ProtoOASwapCalculationType::PERCENTAGE),
            "POINTS" => ::std::option::Option::Some(ProtoOASwapCalculationType::POINTS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOASwapCalculationType] = &[
        ProtoOASwapCalculationType::PIPS,
        ProtoOASwapCalculationType::PERCENTAGE,
        ProtoOASwapCalculationType::POINTS,
    ];
}

impl ::protobuf::EnumFull for ProtoOASwapCalculationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOASwapCalculationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOASwapCalculationType {
    fn default() -> Self {
        ProtoOASwapCalculationType::PIPS
    }
}

impl ProtoOASwapCalculationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOASwapCalculationType>("ProtoOASwapCalculationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAAccessRights)
pub enum ProtoOAAccessRights {
    // @@protoc_insertion_point(enum_value:ProtoOAAccessRights.FULL_ACCESS)
    FULL_ACCESS = 0,
    // @@protoc_insertion_point(enum_value:ProtoOAAccessRights.CLOSE_ONLY)
    CLOSE_ONLY = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAAccessRights.NO_TRADING)
    NO_TRADING = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAAccessRights.NO_LOGIN)
    NO_LOGIN = 3,
}

impl ::protobuf::Enum for ProtoOAAccessRights {
    const NAME: &'static str = "ProtoOAAccessRights";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAAccessRights> {
        match value {
            0 => ::std::option::Option::Some(ProtoOAAccessRights::FULL_ACCESS),
            1 => ::std::option::Option::Some(ProtoOAAccessRights::CLOSE_ONLY),
            2 => ::std::option::Option::Some(ProtoOAAccessRights::NO_TRADING),
            3 => ::std::option::Option::Some(ProtoOAAccessRights::NO_LOGIN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAAccessRights> {
        match str {
            "FULL_ACCESS" => ::std::option::Option::Some(ProtoOAAccessRights::FULL_ACCESS),
            "CLOSE_ONLY" => ::std::option::Option::Some(ProtoOAAccessRights::CLOSE_ONLY),
            "NO_TRADING" => ::std::option::Option::Some(ProtoOAAccessRights::NO_TRADING),
            "NO_LOGIN" => ::std::option::Option::Some(ProtoOAAccessRights::NO_LOGIN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAAccessRights] = &[
        ProtoOAAccessRights::FULL_ACCESS,
        ProtoOAAccessRights::CLOSE_ONLY,
        ProtoOAAccessRights::NO_TRADING,
        ProtoOAAccessRights::NO_LOGIN,
    ];
}

impl ::protobuf::EnumFull for ProtoOAAccessRights {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAAccessRights").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOAAccessRights {
    fn default() -> Self {
        ProtoOAAccessRights::FULL_ACCESS
    }
}

impl ProtoOAAccessRights {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAAccessRights>("ProtoOAAccessRights")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOATotalMarginCalculationType)
pub enum ProtoOATotalMarginCalculationType {
    // @@protoc_insertion_point(enum_value:ProtoOATotalMarginCalculationType.MAX)
    MAX = 0,
    // @@protoc_insertion_point(enum_value:ProtoOATotalMarginCalculationType.SUM)
    SUM = 1,
    // @@protoc_insertion_point(enum_value:ProtoOATotalMarginCalculationType.NET)
    NET = 2,
}

impl ::protobuf::Enum for ProtoOATotalMarginCalculationType {
    const NAME: &'static str = "ProtoOATotalMarginCalculationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOATotalMarginCalculationType> {
        match value {
            0 => ::std::option::Option::Some(ProtoOATotalMarginCalculationType::MAX),
            1 => ::std::option::Option::Some(ProtoOATotalMarginCalculationType::SUM),
            2 => ::std::option::Option::Some(ProtoOATotalMarginCalculationType::NET),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOATotalMarginCalculationType> {
        match str {
            "MAX" => ::std::option::Option::Some(ProtoOATotalMarginCalculationType::MAX),
            "SUM" => ::std::option::Option::Some(ProtoOATotalMarginCalculationType::SUM),
            "NET" => ::std::option::Option::Some(ProtoOATotalMarginCalculationType::NET),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOATotalMarginCalculationType] = &[
        ProtoOATotalMarginCalculationType::MAX,
        ProtoOATotalMarginCalculationType::SUM,
        ProtoOATotalMarginCalculationType::NET,
    ];
}

impl ::protobuf::EnumFull for ProtoOATotalMarginCalculationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOATotalMarginCalculationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOATotalMarginCalculationType {
    fn default() -> Self {
        ProtoOATotalMarginCalculationType::MAX
    }
}

impl ProtoOATotalMarginCalculationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOATotalMarginCalculationType>("ProtoOATotalMarginCalculationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAAccountType)
pub enum ProtoOAAccountType {
    // @@protoc_insertion_point(enum_value:ProtoOAAccountType.HEDGED)
    HEDGED = 0,
    // @@protoc_insertion_point(enum_value:ProtoOAAccountType.NETTED)
    NETTED = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAAccountType.SPREAD_BETTING)
    SPREAD_BETTING = 2,
}

impl ::protobuf::Enum for ProtoOAAccountType {
    const NAME: &'static str = "ProtoOAAccountType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAAccountType> {
        match value {
            0 => ::std::option::Option::Some(ProtoOAAccountType::HEDGED),
            1 => ::std::option::Option::Some(ProtoOAAccountType::NETTED),
            2 => ::std::option::Option::Some(ProtoOAAccountType::SPREAD_BETTING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAAccountType> {
        match str {
            "HEDGED" => ::std::option::Option::Some(ProtoOAAccountType::HEDGED),
            "NETTED" => ::std::option::Option::Some(ProtoOAAccountType::NETTED),
            "SPREAD_BETTING" => ::std::option::Option::Some(ProtoOAAccountType::SPREAD_BETTING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAAccountType] = &[
        ProtoOAAccountType::HEDGED,
        ProtoOAAccountType::NETTED,
        ProtoOAAccountType::SPREAD_BETTING,
    ];
}

impl ::protobuf::EnumFull for ProtoOAAccountType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAAccountType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOAAccountType {
    fn default() -> Self {
        ProtoOAAccountType::HEDGED
    }
}

impl ProtoOAAccountType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAAccountType>("ProtoOAAccountType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAPositionStatus)
pub enum ProtoOAPositionStatus {
    // @@protoc_insertion_point(enum_value:ProtoOAPositionStatus.POSITION_STATUS_OPEN)
    POSITION_STATUS_OPEN = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAPositionStatus.POSITION_STATUS_CLOSED)
    POSITION_STATUS_CLOSED = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAPositionStatus.POSITION_STATUS_CREATED)
    POSITION_STATUS_CREATED = 3,
    // @@protoc_insertion_point(enum_value:ProtoOAPositionStatus.POSITION_STATUS_ERROR)
    POSITION_STATUS_ERROR = 4,
}

impl ::protobuf::Enum for ProtoOAPositionStatus {
    const NAME: &'static str = "ProtoOAPositionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAPositionStatus> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_OPEN),
            2 => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_CLOSED),
            3 => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_CREATED),
            4 => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAPositionStatus> {
        match str {
            "POSITION_STATUS_OPEN" => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_OPEN),
            "POSITION_STATUS_CLOSED" => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_CLOSED),
            "POSITION_STATUS_CREATED" => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_CREATED),
            "POSITION_STATUS_ERROR" => ::std::option::Option::Some(ProtoOAPositionStatus::POSITION_STATUS_ERROR),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAPositionStatus] = &[
        ProtoOAPositionStatus::POSITION_STATUS_OPEN,
        ProtoOAPositionStatus::POSITION_STATUS_CLOSED,
        ProtoOAPositionStatus::POSITION_STATUS_CREATED,
        ProtoOAPositionStatus::POSITION_STATUS_ERROR,
    ];
}

impl ::protobuf::EnumFull for ProtoOAPositionStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAPositionStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAPositionStatus::POSITION_STATUS_OPEN => 0,
            ProtoOAPositionStatus::POSITION_STATUS_CLOSED => 1,
            ProtoOAPositionStatus::POSITION_STATUS_CREATED => 2,
            ProtoOAPositionStatus::POSITION_STATUS_ERROR => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAPositionStatus {
    fn default() -> Self {
        ProtoOAPositionStatus::POSITION_STATUS_OPEN
    }
}

impl ProtoOAPositionStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAPositionStatus>("ProtoOAPositionStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOATradeSide)
pub enum ProtoOATradeSide {
    // @@protoc_insertion_point(enum_value:ProtoOATradeSide.BUY)
    BUY = 1,
    // @@protoc_insertion_point(enum_value:ProtoOATradeSide.SELL)
    SELL = 2,
}

impl ::protobuf::Enum for ProtoOATradeSide {
    const NAME: &'static str = "ProtoOATradeSide";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOATradeSide> {
        match value {
            1 => ::std::option::Option::Some(ProtoOATradeSide::BUY),
            2 => ::std::option::Option::Some(ProtoOATradeSide::SELL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOATradeSide> {
        match str {
            "BUY" => ::std::option::Option::Some(ProtoOATradeSide::BUY),
            "SELL" => ::std::option::Option::Some(ProtoOATradeSide::SELL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOATradeSide] = &[
        ProtoOATradeSide::BUY,
        ProtoOATradeSide::SELL,
    ];
}

impl ::protobuf::EnumFull for ProtoOATradeSide {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOATradeSide").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOATradeSide::BUY => 0,
            ProtoOATradeSide::SELL => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOATradeSide {
    fn default() -> Self {
        ProtoOATradeSide::BUY
    }
}

impl ProtoOATradeSide {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOATradeSide>("ProtoOATradeSide")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAOrderType)
pub enum ProtoOAOrderType {
    // @@protoc_insertion_point(enum_value:ProtoOAOrderType.MARKET)
    MARKET = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderType.LIMIT)
    LIMIT = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderType.STOP)
    STOP = 3,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderType.STOP_LOSS_TAKE_PROFIT)
    STOP_LOSS_TAKE_PROFIT = 4,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderType.MARKET_RANGE)
    MARKET_RANGE = 5,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderType.STOP_LIMIT)
    STOP_LIMIT = 6,
}

impl ::protobuf::Enum for ProtoOAOrderType {
    const NAME: &'static str = "ProtoOAOrderType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAOrderType> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAOrderType::MARKET),
            2 => ::std::option::Option::Some(ProtoOAOrderType::LIMIT),
            3 => ::std::option::Option::Some(ProtoOAOrderType::STOP),
            4 => ::std::option::Option::Some(ProtoOAOrderType::STOP_LOSS_TAKE_PROFIT),
            5 => ::std::option::Option::Some(ProtoOAOrderType::MARKET_RANGE),
            6 => ::std::option::Option::Some(ProtoOAOrderType::STOP_LIMIT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAOrderType> {
        match str {
            "MARKET" => ::std::option::Option::Some(ProtoOAOrderType::MARKET),
            "LIMIT" => ::std::option::Option::Some(ProtoOAOrderType::LIMIT),
            "STOP" => ::std::option::Option::Some(ProtoOAOrderType::STOP),
            "STOP_LOSS_TAKE_PROFIT" => ::std::option::Option::Some(ProtoOAOrderType::STOP_LOSS_TAKE_PROFIT),
            "MARKET_RANGE" => ::std::option::Option::Some(ProtoOAOrderType::MARKET_RANGE),
            "STOP_LIMIT" => ::std::option::Option::Some(ProtoOAOrderType::STOP_LIMIT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAOrderType] = &[
        ProtoOAOrderType::MARKET,
        ProtoOAOrderType::LIMIT,
        ProtoOAOrderType::STOP,
        ProtoOAOrderType::STOP_LOSS_TAKE_PROFIT,
        ProtoOAOrderType::MARKET_RANGE,
        ProtoOAOrderType::STOP_LIMIT,
    ];
}

impl ::protobuf::EnumFull for ProtoOAOrderType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAOrderType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAOrderType::MARKET => 0,
            ProtoOAOrderType::LIMIT => 1,
            ProtoOAOrderType::STOP => 2,
            ProtoOAOrderType::STOP_LOSS_TAKE_PROFIT => 3,
            ProtoOAOrderType::MARKET_RANGE => 4,
            ProtoOAOrderType::STOP_LIMIT => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAOrderType {
    fn default() -> Self {
        ProtoOAOrderType::MARKET
    }
}

impl ProtoOAOrderType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAOrderType>("ProtoOAOrderType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOATimeInForce)
pub enum ProtoOATimeInForce {
    // @@protoc_insertion_point(enum_value:ProtoOATimeInForce.GOOD_TILL_DATE)
    GOOD_TILL_DATE = 1,
    // @@protoc_insertion_point(enum_value:ProtoOATimeInForce.GOOD_TILL_CANCEL)
    GOOD_TILL_CANCEL = 2,
    // @@protoc_insertion_point(enum_value:ProtoOATimeInForce.IMMEDIATE_OR_CANCEL)
    IMMEDIATE_OR_CANCEL = 3,
    // @@protoc_insertion_point(enum_value:ProtoOATimeInForce.FILL_OR_KILL)
    FILL_OR_KILL = 4,
    // @@protoc_insertion_point(enum_value:ProtoOATimeInForce.MARKET_ON_OPEN)
    MARKET_ON_OPEN = 5,
}

impl ::protobuf::Enum for ProtoOATimeInForce {
    const NAME: &'static str = "ProtoOATimeInForce";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOATimeInForce> {
        match value {
            1 => ::std::option::Option::Some(ProtoOATimeInForce::GOOD_TILL_DATE),
            2 => ::std::option::Option::Some(ProtoOATimeInForce::GOOD_TILL_CANCEL),
            3 => ::std::option::Option::Some(ProtoOATimeInForce::IMMEDIATE_OR_CANCEL),
            4 => ::std::option::Option::Some(ProtoOATimeInForce::FILL_OR_KILL),
            5 => ::std::option::Option::Some(ProtoOATimeInForce::MARKET_ON_OPEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOATimeInForce> {
        match str {
            "GOOD_TILL_DATE" => ::std::option::Option::Some(ProtoOATimeInForce::GOOD_TILL_DATE),
            "GOOD_TILL_CANCEL" => ::std::option::Option::Some(ProtoOATimeInForce::GOOD_TILL_CANCEL),
            "IMMEDIATE_OR_CANCEL" => ::std::option::Option::Some(ProtoOATimeInForce::IMMEDIATE_OR_CANCEL),
            "FILL_OR_KILL" => ::std::option::Option::Some(ProtoOATimeInForce::FILL_OR_KILL),
            "MARKET_ON_OPEN" => ::std::option::Option::Some(ProtoOATimeInForce::MARKET_ON_OPEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOATimeInForce] = &[
        ProtoOATimeInForce::GOOD_TILL_DATE,
        ProtoOATimeInForce::GOOD_TILL_CANCEL,
        ProtoOATimeInForce::IMMEDIATE_OR_CANCEL,
        ProtoOATimeInForce::FILL_OR_KILL,
        ProtoOATimeInForce::MARKET_ON_OPEN,
    ];
}

impl ::protobuf::EnumFull for ProtoOATimeInForce {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOATimeInForce").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOATimeInForce::GOOD_TILL_DATE => 0,
            ProtoOATimeInForce::GOOD_TILL_CANCEL => 1,
            ProtoOATimeInForce::IMMEDIATE_OR_CANCEL => 2,
            ProtoOATimeInForce::FILL_OR_KILL => 3,
            ProtoOATimeInForce::MARKET_ON_OPEN => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOATimeInForce {
    fn default() -> Self {
        ProtoOATimeInForce::GOOD_TILL_DATE
    }
}

impl ProtoOATimeInForce {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOATimeInForce>("ProtoOATimeInForce")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAOrderStatus)
pub enum ProtoOAOrderStatus {
    // @@protoc_insertion_point(enum_value:ProtoOAOrderStatus.ORDER_STATUS_ACCEPTED)
    ORDER_STATUS_ACCEPTED = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderStatus.ORDER_STATUS_FILLED)
    ORDER_STATUS_FILLED = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderStatus.ORDER_STATUS_REJECTED)
    ORDER_STATUS_REJECTED = 3,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderStatus.ORDER_STATUS_EXPIRED)
    ORDER_STATUS_EXPIRED = 4,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderStatus.ORDER_STATUS_CANCELLED)
    ORDER_STATUS_CANCELLED = 5,
}

impl ::protobuf::Enum for ProtoOAOrderStatus {
    const NAME: &'static str = "ProtoOAOrderStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAOrderStatus> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED),
            2 => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_FILLED),
            3 => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_REJECTED),
            4 => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_EXPIRED),
            5 => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAOrderStatus> {
        match str {
            "ORDER_STATUS_ACCEPTED" => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED),
            "ORDER_STATUS_FILLED" => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_FILLED),
            "ORDER_STATUS_REJECTED" => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_REJECTED),
            "ORDER_STATUS_EXPIRED" => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_EXPIRED),
            "ORDER_STATUS_CANCELLED" => ::std::option::Option::Some(ProtoOAOrderStatus::ORDER_STATUS_CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAOrderStatus] = &[
        ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED,
        ProtoOAOrderStatus::ORDER_STATUS_FILLED,
        ProtoOAOrderStatus::ORDER_STATUS_REJECTED,
        ProtoOAOrderStatus::ORDER_STATUS_EXPIRED,
        ProtoOAOrderStatus::ORDER_STATUS_CANCELLED,
    ];
}

impl ::protobuf::EnumFull for ProtoOAOrderStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAOrderStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED => 0,
            ProtoOAOrderStatus::ORDER_STATUS_FILLED => 1,
            ProtoOAOrderStatus::ORDER_STATUS_REJECTED => 2,
            ProtoOAOrderStatus::ORDER_STATUS_EXPIRED => 3,
            ProtoOAOrderStatus::ORDER_STATUS_CANCELLED => 4,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAOrderStatus {
    fn default() -> Self {
        ProtoOAOrderStatus::ORDER_STATUS_ACCEPTED
    }
}

impl ProtoOAOrderStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAOrderStatus>("ProtoOAOrderStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAOrderTriggerMethod)
pub enum ProtoOAOrderTriggerMethod {
    // @@protoc_insertion_point(enum_value:ProtoOAOrderTriggerMethod.TRADE)
    TRADE = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderTriggerMethod.OPPOSITE)
    OPPOSITE = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderTriggerMethod.DOUBLE_TRADE)
    DOUBLE_TRADE = 3,
    // @@protoc_insertion_point(enum_value:ProtoOAOrderTriggerMethod.DOUBLE_OPPOSITE)
    DOUBLE_OPPOSITE = 4,
}

impl ::protobuf::Enum for ProtoOAOrderTriggerMethod {
    const NAME: &'static str = "ProtoOAOrderTriggerMethod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAOrderTriggerMethod> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::TRADE),
            2 => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::OPPOSITE),
            3 => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::DOUBLE_TRADE),
            4 => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::DOUBLE_OPPOSITE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAOrderTriggerMethod> {
        match str {
            "TRADE" => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::TRADE),
            "OPPOSITE" => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::OPPOSITE),
            "DOUBLE_TRADE" => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::DOUBLE_TRADE),
            "DOUBLE_OPPOSITE" => ::std::option::Option::Some(ProtoOAOrderTriggerMethod::DOUBLE_OPPOSITE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAOrderTriggerMethod] = &[
        ProtoOAOrderTriggerMethod::TRADE,
        ProtoOAOrderTriggerMethod::OPPOSITE,
        ProtoOAOrderTriggerMethod::DOUBLE_TRADE,
        ProtoOAOrderTriggerMethod::DOUBLE_OPPOSITE,
    ];
}

impl ::protobuf::EnumFull for ProtoOAOrderTriggerMethod {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAOrderTriggerMethod").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAOrderTriggerMethod::TRADE => 0,
            ProtoOAOrderTriggerMethod::OPPOSITE => 1,
            ProtoOAOrderTriggerMethod::DOUBLE_TRADE => 2,
            ProtoOAOrderTriggerMethod::DOUBLE_OPPOSITE => 3,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAOrderTriggerMethod {
    fn default() -> Self {
        ProtoOAOrderTriggerMethod::TRADE
    }
}

impl ProtoOAOrderTriggerMethod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAOrderTriggerMethod>("ProtoOAOrderTriggerMethod")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAExecutionType)
pub enum ProtoOAExecutionType {
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_ACCEPTED)
    ORDER_ACCEPTED = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_FILLED)
    ORDER_FILLED = 3,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_REPLACED)
    ORDER_REPLACED = 4,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_CANCELLED)
    ORDER_CANCELLED = 5,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_EXPIRED)
    ORDER_EXPIRED = 6,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_REJECTED)
    ORDER_REJECTED = 7,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_CANCEL_REJECTED)
    ORDER_CANCEL_REJECTED = 8,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.SWAP)
    SWAP = 9,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.DEPOSIT_WITHDRAW)
    DEPOSIT_WITHDRAW = 10,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.ORDER_PARTIAL_FILL)
    ORDER_PARTIAL_FILL = 11,
    // @@protoc_insertion_point(enum_value:ProtoOAExecutionType.BONUS_DEPOSIT_WITHDRAW)
    BONUS_DEPOSIT_WITHDRAW = 12,
}

impl ::protobuf::Enum for ProtoOAExecutionType {
    const NAME: &'static str = "ProtoOAExecutionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAExecutionType> {
        match value {
            2 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_ACCEPTED),
            3 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_FILLED),
            4 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_REPLACED),
            5 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_CANCELLED),
            6 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_EXPIRED),
            7 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_REJECTED),
            8 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_CANCEL_REJECTED),
            9 => ::std::option::Option::Some(ProtoOAExecutionType::SWAP),
            10 => ::std::option::Option::Some(ProtoOAExecutionType::DEPOSIT_WITHDRAW),
            11 => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_PARTIAL_FILL),
            12 => ::std::option::Option::Some(ProtoOAExecutionType::BONUS_DEPOSIT_WITHDRAW),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAExecutionType> {
        match str {
            "ORDER_ACCEPTED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_ACCEPTED),
            "ORDER_FILLED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_FILLED),
            "ORDER_REPLACED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_REPLACED),
            "ORDER_CANCELLED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_CANCELLED),
            "ORDER_EXPIRED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_EXPIRED),
            "ORDER_REJECTED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_REJECTED),
            "ORDER_CANCEL_REJECTED" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_CANCEL_REJECTED),
            "SWAP" => ::std::option::Option::Some(ProtoOAExecutionType::SWAP),
            "DEPOSIT_WITHDRAW" => ::std::option::Option::Some(ProtoOAExecutionType::DEPOSIT_WITHDRAW),
            "ORDER_PARTIAL_FILL" => ::std::option::Option::Some(ProtoOAExecutionType::ORDER_PARTIAL_FILL),
            "BONUS_DEPOSIT_WITHDRAW" => ::std::option::Option::Some(ProtoOAExecutionType::BONUS_DEPOSIT_WITHDRAW),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAExecutionType] = &[
        ProtoOAExecutionType::ORDER_ACCEPTED,
        ProtoOAExecutionType::ORDER_FILLED,
        ProtoOAExecutionType::ORDER_REPLACED,
        ProtoOAExecutionType::ORDER_CANCELLED,
        ProtoOAExecutionType::ORDER_EXPIRED,
        ProtoOAExecutionType::ORDER_REJECTED,
        ProtoOAExecutionType::ORDER_CANCEL_REJECTED,
        ProtoOAExecutionType::SWAP,
        ProtoOAExecutionType::DEPOSIT_WITHDRAW,
        ProtoOAExecutionType::ORDER_PARTIAL_FILL,
        ProtoOAExecutionType::BONUS_DEPOSIT_WITHDRAW,
    ];
}

impl ::protobuf::EnumFull for ProtoOAExecutionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAExecutionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAExecutionType::ORDER_ACCEPTED => 0,
            ProtoOAExecutionType::ORDER_FILLED => 1,
            ProtoOAExecutionType::ORDER_REPLACED => 2,
            ProtoOAExecutionType::ORDER_CANCELLED => 3,
            ProtoOAExecutionType::ORDER_EXPIRED => 4,
            ProtoOAExecutionType::ORDER_REJECTED => 5,
            ProtoOAExecutionType::ORDER_CANCEL_REJECTED => 6,
            ProtoOAExecutionType::SWAP => 7,
            ProtoOAExecutionType::DEPOSIT_WITHDRAW => 8,
            ProtoOAExecutionType::ORDER_PARTIAL_FILL => 9,
            ProtoOAExecutionType::BONUS_DEPOSIT_WITHDRAW => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAExecutionType {
    fn default() -> Self {
        ProtoOAExecutionType::ORDER_ACCEPTED
    }
}

impl ProtoOAExecutionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAExecutionType>("ProtoOAExecutionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAChangeBonusType)
pub enum ProtoOAChangeBonusType {
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBonusType.BONUS_DEPOSIT)
    BONUS_DEPOSIT = 0,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBonusType.BONUS_WITHDRAW)
    BONUS_WITHDRAW = 1,
}

impl ::protobuf::Enum for ProtoOAChangeBonusType {
    const NAME: &'static str = "ProtoOAChangeBonusType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAChangeBonusType> {
        match value {
            0 => ::std::option::Option::Some(ProtoOAChangeBonusType::BONUS_DEPOSIT),
            1 => ::std::option::Option::Some(ProtoOAChangeBonusType::BONUS_WITHDRAW),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAChangeBonusType> {
        match str {
            "BONUS_DEPOSIT" => ::std::option::Option::Some(ProtoOAChangeBonusType::BONUS_DEPOSIT),
            "BONUS_WITHDRAW" => ::std::option::Option::Some(ProtoOAChangeBonusType::BONUS_WITHDRAW),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAChangeBonusType] = &[
        ProtoOAChangeBonusType::BONUS_DEPOSIT,
        ProtoOAChangeBonusType::BONUS_WITHDRAW,
    ];
}

impl ::protobuf::EnumFull for ProtoOAChangeBonusType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAChangeBonusType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOAChangeBonusType {
    fn default() -> Self {
        ProtoOAChangeBonusType::BONUS_DEPOSIT
    }
}

impl ProtoOAChangeBonusType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAChangeBonusType>("ProtoOAChangeBonusType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAChangeBalanceType)
pub enum ProtoOAChangeBalanceType {
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT)
    BALANCE_DEPOSIT = 0,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW)
    BALANCE_WITHDRAW = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER)
    BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER = 3,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER)
    BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER = 4,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_IB_COMMISSIONS)
    BALANCE_DEPOSIT_IB_COMMISSIONS = 5,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE)
    BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE = 6,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB)
    BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB = 7,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER)
    BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER = 8,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_REBATE)
    BALANCE_DEPOSIT_REBATE = 9,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_REBATE)
    BALANCE_WITHDRAW_REBATE = 10,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER)
    BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER = 11,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER)
    BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER = 12,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_BONUS_COMPENSATION)
    BALANCE_WITHDRAW_BONUS_COMPENSATION = 13,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER)
    BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER = 14,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_DIVIDENDS)
    BALANCE_DEPOSIT_DIVIDENDS = 15,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_DIVIDENDS)
    BALANCE_WITHDRAW_DIVIDENDS = 16,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_GSL_CHARGE)
    BALANCE_WITHDRAW_GSL_CHARGE = 17,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_ROLLOVER)
    BALANCE_WITHDRAW_ROLLOVER = 18,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS)
    BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS = 19,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS)
    BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS = 20,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_SWAP)
    BALANCE_DEPOSIT_SWAP = 21,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_SWAP)
    BALANCE_WITHDRAW_SWAP = 22,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_MANAGEMENT_FEE)
    BALANCE_DEPOSIT_MANAGEMENT_FEE = 27,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_MANAGEMENT_FEE)
    BALANCE_WITHDRAW_MANAGEMENT_FEE = 28,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_PERFORMANCE_FEE)
    BALANCE_DEPOSIT_PERFORMANCE_FEE = 29,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_FOR_SUBACCOUNT)
    BALANCE_WITHDRAW_FOR_SUBACCOUNT = 30,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_TO_SUBACCOUNT)
    BALANCE_DEPOSIT_TO_SUBACCOUNT = 31,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_FROM_SUBACCOUNT)
    BALANCE_WITHDRAW_FROM_SUBACCOUNT = 32,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_FROM_SUBACCOUNT)
    BALANCE_DEPOSIT_FROM_SUBACCOUNT = 33,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_COPY_FEE)
    BALANCE_WITHDRAW_COPY_FEE = 34,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_INACTIVITY_FEE)
    BALANCE_WITHDRAW_INACTIVITY_FEE = 35,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_TRANSFER)
    BALANCE_DEPOSIT_TRANSFER = 36,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_WITHDRAW_TRANSFER)
    BALANCE_WITHDRAW_TRANSFER = 37,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_CONVERTED_BONUS)
    BALANCE_DEPOSIT_CONVERTED_BONUS = 38,
    // @@protoc_insertion_point(enum_value:ProtoOAChangeBalanceType.BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION)
    BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION = 39,
}

impl ::protobuf::Enum for ProtoOAChangeBalanceType {
    const NAME: &'static str = "ProtoOAChangeBalanceType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAChangeBalanceType> {
        match value {
            0 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT),
            1 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW),
            3 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER),
            4 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER),
            5 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_COMMISSIONS),
            6 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE),
            7 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB),
            8 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER),
            9 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_REBATE),
            10 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_REBATE),
            11 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER),
            12 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER),
            13 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_BONUS_COMPENSATION),
            14 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER),
            15 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_DIVIDENDS),
            16 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_DIVIDENDS),
            17 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_GSL_CHARGE),
            18 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_ROLLOVER),
            19 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS),
            20 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS),
            21 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_SWAP),
            22 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_SWAP),
            27 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_MANAGEMENT_FEE),
            28 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_MANAGEMENT_FEE),
            29 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_PERFORMANCE_FEE),
            30 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FOR_SUBACCOUNT),
            31 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TO_SUBACCOUNT),
            32 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FROM_SUBACCOUNT),
            33 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_FROM_SUBACCOUNT),
            34 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_COPY_FEE),
            35 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_INACTIVITY_FEE),
            36 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TRANSFER),
            37 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_TRANSFER),
            38 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_CONVERTED_BONUS),
            39 => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAChangeBalanceType> {
        match str {
            "BALANCE_DEPOSIT" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT),
            "BALANCE_WITHDRAW" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW),
            "BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER),
            "BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER),
            "BALANCE_DEPOSIT_IB_COMMISSIONS" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_COMMISSIONS),
            "BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE),
            "BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB),
            "BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER),
            "BALANCE_DEPOSIT_REBATE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_REBATE),
            "BALANCE_WITHDRAW_REBATE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_REBATE),
            "BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER),
            "BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER),
            "BALANCE_WITHDRAW_BONUS_COMPENSATION" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_BONUS_COMPENSATION),
            "BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER),
            "BALANCE_DEPOSIT_DIVIDENDS" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_DIVIDENDS),
            "BALANCE_WITHDRAW_DIVIDENDS" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_DIVIDENDS),
            "BALANCE_WITHDRAW_GSL_CHARGE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_GSL_CHARGE),
            "BALANCE_WITHDRAW_ROLLOVER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_ROLLOVER),
            "BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS),
            "BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS),
            "BALANCE_DEPOSIT_SWAP" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_SWAP),
            "BALANCE_WITHDRAW_SWAP" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_SWAP),
            "BALANCE_DEPOSIT_MANAGEMENT_FEE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_MANAGEMENT_FEE),
            "BALANCE_WITHDRAW_MANAGEMENT_FEE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_MANAGEMENT_FEE),
            "BALANCE_DEPOSIT_PERFORMANCE_FEE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_PERFORMANCE_FEE),
            "BALANCE_WITHDRAW_FOR_SUBACCOUNT" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FOR_SUBACCOUNT),
            "BALANCE_DEPOSIT_TO_SUBACCOUNT" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TO_SUBACCOUNT),
            "BALANCE_WITHDRAW_FROM_SUBACCOUNT" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FROM_SUBACCOUNT),
            "BALANCE_DEPOSIT_FROM_SUBACCOUNT" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_FROM_SUBACCOUNT),
            "BALANCE_WITHDRAW_COPY_FEE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_COPY_FEE),
            "BALANCE_WITHDRAW_INACTIVITY_FEE" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_INACTIVITY_FEE),
            "BALANCE_DEPOSIT_TRANSFER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TRANSFER),
            "BALANCE_WITHDRAW_TRANSFER" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_WITHDRAW_TRANSFER),
            "BALANCE_DEPOSIT_CONVERTED_BONUS" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_CONVERTED_BONUS),
            "BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION" => ::std::option::Option::Some(ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAChangeBalanceType] = &[
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_COMMISSIONS,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_REBATE,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_REBATE,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_BONUS_COMPENSATION,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_DIVIDENDS,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_DIVIDENDS,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_GSL_CHARGE,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_ROLLOVER,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_SWAP,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_SWAP,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_MANAGEMENT_FEE,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_MANAGEMENT_FEE,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_PERFORMANCE_FEE,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FOR_SUBACCOUNT,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TO_SUBACCOUNT,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FROM_SUBACCOUNT,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_FROM_SUBACCOUNT,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_COPY_FEE,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_INACTIVITY_FEE,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TRANSFER,
        ProtoOAChangeBalanceType::BALANCE_WITHDRAW_TRANSFER,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_CONVERTED_BONUS,
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION,
    ];
}

impl ::protobuf::EnumFull for ProtoOAChangeBalanceType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAChangeBalanceType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT => 0,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW => 1,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER => 2,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER => 3,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_COMMISSIONS => 4,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE => 5,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB => 6,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER => 7,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_REBATE => 8,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_REBATE => 9,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER => 10,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER => 11,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_BONUS_COMPENSATION => 12,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_IB_SHARED_PERCENTAGE_TO_BROKER => 13,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_DIVIDENDS => 14,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_DIVIDENDS => 15,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_GSL_CHARGE => 16,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_ROLLOVER => 17,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS => 18,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_NONWITHDRAWABLE_BONUS => 19,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_SWAP => 20,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_SWAP => 21,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_MANAGEMENT_FEE => 22,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_MANAGEMENT_FEE => 23,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_PERFORMANCE_FEE => 24,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FOR_SUBACCOUNT => 25,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TO_SUBACCOUNT => 26,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_FROM_SUBACCOUNT => 27,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_FROM_SUBACCOUNT => 28,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_COPY_FEE => 29,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_INACTIVITY_FEE => 30,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_TRANSFER => 31,
            ProtoOAChangeBalanceType::BALANCE_WITHDRAW_TRANSFER => 32,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_CONVERTED_BONUS => 33,
            ProtoOAChangeBalanceType::BALANCE_DEPOSIT_NEGATIVE_BALANCE_PROTECTION => 34,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOAChangeBalanceType {
    fn default() -> Self {
        ProtoOAChangeBalanceType::BALANCE_DEPOSIT
    }
}

impl ProtoOAChangeBalanceType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAChangeBalanceType>("ProtoOAChangeBalanceType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOADealStatus)
pub enum ProtoOADealStatus {
    // @@protoc_insertion_point(enum_value:ProtoOADealStatus.FILLED)
    FILLED = 2,
    // @@protoc_insertion_point(enum_value:ProtoOADealStatus.PARTIALLY_FILLED)
    PARTIALLY_FILLED = 3,
    // @@protoc_insertion_point(enum_value:ProtoOADealStatus.REJECTED)
    REJECTED = 4,
    // @@protoc_insertion_point(enum_value:ProtoOADealStatus.INTERNALLY_REJECTED)
    INTERNALLY_REJECTED = 5,
    // @@protoc_insertion_point(enum_value:ProtoOADealStatus.ERROR)
    ERROR = 6,
    // @@protoc_insertion_point(enum_value:ProtoOADealStatus.MISSED)
    MISSED = 7,
}

impl ::protobuf::Enum for ProtoOADealStatus {
    const NAME: &'static str = "ProtoOADealStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOADealStatus> {
        match value {
            2 => ::std::option::Option::Some(ProtoOADealStatus::FILLED),
            3 => ::std::option::Option::Some(ProtoOADealStatus::PARTIALLY_FILLED),
            4 => ::std::option::Option::Some(ProtoOADealStatus::REJECTED),
            5 => ::std::option::Option::Some(ProtoOADealStatus::INTERNALLY_REJECTED),
            6 => ::std::option::Option::Some(ProtoOADealStatus::ERROR),
            7 => ::std::option::Option::Some(ProtoOADealStatus::MISSED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOADealStatus> {
        match str {
            "FILLED" => ::std::option::Option::Some(ProtoOADealStatus::FILLED),
            "PARTIALLY_FILLED" => ::std::option::Option::Some(ProtoOADealStatus::PARTIALLY_FILLED),
            "REJECTED" => ::std::option::Option::Some(ProtoOADealStatus::REJECTED),
            "INTERNALLY_REJECTED" => ::std::option::Option::Some(ProtoOADealStatus::INTERNALLY_REJECTED),
            "ERROR" => ::std::option::Option::Some(ProtoOADealStatus::ERROR),
            "MISSED" => ::std::option::Option::Some(ProtoOADealStatus::MISSED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOADealStatus] = &[
        ProtoOADealStatus::FILLED,
        ProtoOADealStatus::PARTIALLY_FILLED,
        ProtoOADealStatus::REJECTED,
        ProtoOADealStatus::INTERNALLY_REJECTED,
        ProtoOADealStatus::ERROR,
        ProtoOADealStatus::MISSED,
    ];
}

impl ::protobuf::EnumFull for ProtoOADealStatus {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOADealStatus").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOADealStatus::FILLED => 0,
            ProtoOADealStatus::PARTIALLY_FILLED => 1,
            ProtoOADealStatus::REJECTED => 2,
            ProtoOADealStatus::INTERNALLY_REJECTED => 3,
            ProtoOADealStatus::ERROR => 4,
            ProtoOADealStatus::MISSED => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOADealStatus {
    fn default() -> Self {
        ProtoOADealStatus::FILLED
    }
}

impl ProtoOADealStatus {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOADealStatus>("ProtoOADealStatus")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOATrendbarPeriod)
pub enum ProtoOATrendbarPeriod {
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M1)
    M1 = 1,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M2)
    M2 = 2,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M3)
    M3 = 3,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M4)
    M4 = 4,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M5)
    M5 = 5,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M10)
    M10 = 6,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M15)
    M15 = 7,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.M30)
    M30 = 8,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.H1)
    H1 = 9,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.H4)
    H4 = 10,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.H12)
    H12 = 11,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.D1)
    D1 = 12,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.W1)
    W1 = 13,
    // @@protoc_insertion_point(enum_value:ProtoOATrendbarPeriod.MN1)
    MN1 = 14,
}

impl ::protobuf::Enum for ProtoOATrendbarPeriod {
    const NAME: &'static str = "ProtoOATrendbarPeriod";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOATrendbarPeriod> {
        match value {
            1 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M1),
            2 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M2),
            3 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M3),
            4 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M4),
            5 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M5),
            6 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M10),
            7 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M15),
            8 => ::std::option::Option::Some(ProtoOATrendbarPeriod::M30),
            9 => ::std::option::Option::Some(ProtoOATrendbarPeriod::H1),
            10 => ::std::option::Option::Some(ProtoOATrendbarPeriod::H4),
            11 => ::std::option::Option::Some(ProtoOATrendbarPeriod::H12),
            12 => ::std::option::Option::Some(ProtoOATrendbarPeriod::D1),
            13 => ::std::option::Option::Some(ProtoOATrendbarPeriod::W1),
            14 => ::std::option::Option::Some(ProtoOATrendbarPeriod::MN1),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOATrendbarPeriod> {
        match str {
            "M1" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M1),
            "M2" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M2),
            "M3" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M3),
            "M4" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M4),
            "M5" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M5),
            "M10" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M10),
            "M15" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M15),
            "M30" => ::std::option::Option::Some(ProtoOATrendbarPeriod::M30),
            "H1" => ::std::option::Option::Some(ProtoOATrendbarPeriod::H1),
            "H4" => ::std::option::Option::Some(ProtoOATrendbarPeriod::H4),
            "H12" => ::std::option::Option::Some(ProtoOATrendbarPeriod::H12),
            "D1" => ::std::option::Option::Some(ProtoOATrendbarPeriod::D1),
            "W1" => ::std::option::Option::Some(ProtoOATrendbarPeriod::W1),
            "MN1" => ::std::option::Option::Some(ProtoOATrendbarPeriod::MN1),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOATrendbarPeriod] = &[
        ProtoOATrendbarPeriod::M1,
        ProtoOATrendbarPeriod::M2,
        ProtoOATrendbarPeriod::M3,
        ProtoOATrendbarPeriod::M4,
        ProtoOATrendbarPeriod::M5,
        ProtoOATrendbarPeriod::M10,
        ProtoOATrendbarPeriod::M15,
        ProtoOATrendbarPeriod::M30,
        ProtoOATrendbarPeriod::H1,
        ProtoOATrendbarPeriod::H4,
        ProtoOATrendbarPeriod::H12,
        ProtoOATrendbarPeriod::D1,
        ProtoOATrendbarPeriod::W1,
        ProtoOATrendbarPeriod::MN1,
    ];
}

impl ::protobuf::EnumFull for ProtoOATrendbarPeriod {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOATrendbarPeriod").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOATrendbarPeriod::M1 => 0,
            ProtoOATrendbarPeriod::M2 => 1,
            ProtoOATrendbarPeriod::M3 => 2,
            ProtoOATrendbarPeriod::M4 => 3,
            ProtoOATrendbarPeriod::M5 => 4,
            ProtoOATrendbarPeriod::M10 => 5,
            ProtoOATrendbarPeriod::M15 => 6,
            ProtoOATrendbarPeriod::M30 => 7,
            ProtoOATrendbarPeriod::H1 => 8,
            ProtoOATrendbarPeriod::H4 => 9,
            ProtoOATrendbarPeriod::H12 => 10,
            ProtoOATrendbarPeriod::D1 => 11,
            ProtoOATrendbarPeriod::W1 => 12,
            ProtoOATrendbarPeriod::MN1 => 13,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOATrendbarPeriod {
    fn default() -> Self {
        ProtoOATrendbarPeriod::M1
    }
}

impl ProtoOATrendbarPeriod {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOATrendbarPeriod>("ProtoOATrendbarPeriod")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAQuoteType)
pub enum ProtoOAQuoteType {
    // @@protoc_insertion_point(enum_value:ProtoOAQuoteType.BID)
    BID = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAQuoteType.ASK)
    ASK = 2,
}

impl ::protobuf::Enum for ProtoOAQuoteType {
    const NAME: &'static str = "ProtoOAQuoteType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAQuoteType> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAQuoteType::BID),
            2 => ::std::option::Option::Some(ProtoOAQuoteType::ASK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAQuoteType> {
        match str {
            "BID" => ::std::option::Option::Some(ProtoOAQuoteType::BID),
            "ASK" => ::std::option::Option::Some(ProtoOAQuoteType::ASK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAQuoteType] = &[
        ProtoOAQuoteType::BID,
        ProtoOAQuoteType::ASK,
    ];
}

impl ::protobuf::EnumFull for ProtoOAQuoteType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAQuoteType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAQuoteType::BID => 0,
            ProtoOAQuoteType::ASK => 1,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAQuoteType {
    fn default() -> Self {
        ProtoOAQuoteType::BID
    }
}

impl ProtoOAQuoteType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAQuoteType>("ProtoOAQuoteType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAClientPermissionScope)
pub enum ProtoOAClientPermissionScope {
    // @@protoc_insertion_point(enum_value:ProtoOAClientPermissionScope.SCOPE_VIEW)
    SCOPE_VIEW = 0,
    // @@protoc_insertion_point(enum_value:ProtoOAClientPermissionScope.SCOPE_TRADE)
    SCOPE_TRADE = 1,
}

impl ::protobuf::Enum for ProtoOAClientPermissionScope {
    const NAME: &'static str = "ProtoOAClientPermissionScope";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAClientPermissionScope> {
        match value {
            0 => ::std::option::Option::Some(ProtoOAClientPermissionScope::SCOPE_VIEW),
            1 => ::std::option::Option::Some(ProtoOAClientPermissionScope::SCOPE_TRADE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAClientPermissionScope> {
        match str {
            "SCOPE_VIEW" => ::std::option::Option::Some(ProtoOAClientPermissionScope::SCOPE_VIEW),
            "SCOPE_TRADE" => ::std::option::Option::Some(ProtoOAClientPermissionScope::SCOPE_TRADE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAClientPermissionScope] = &[
        ProtoOAClientPermissionScope::SCOPE_VIEW,
        ProtoOAClientPermissionScope::SCOPE_TRADE,
    ];
}

impl ::protobuf::EnumFull for ProtoOAClientPermissionScope {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAClientPermissionScope").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOAClientPermissionScope {
    fn default() -> Self {
        ProtoOAClientPermissionScope::SCOPE_VIEW
    }
}

impl ProtoOAClientPermissionScope {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAClientPermissionScope>("ProtoOAClientPermissionScope")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOANotificationType)
pub enum ProtoOANotificationType {
    // @@protoc_insertion_point(enum_value:ProtoOANotificationType.MARGIN_LEVEL_THRESHOLD_1)
    MARGIN_LEVEL_THRESHOLD_1 = 61,
    // @@protoc_insertion_point(enum_value:ProtoOANotificationType.MARGIN_LEVEL_THRESHOLD_2)
    MARGIN_LEVEL_THRESHOLD_2 = 62,
    // @@protoc_insertion_point(enum_value:ProtoOANotificationType.MARGIN_LEVEL_THRESHOLD_3)
    MARGIN_LEVEL_THRESHOLD_3 = 63,
}

impl ::protobuf::Enum for ProtoOANotificationType {
    const NAME: &'static str = "ProtoOANotificationType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOANotificationType> {
        match value {
            61 => ::std::option::Option::Some(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1),
            62 => ::std::option::Option::Some(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_2),
            63 => ::std::option::Option::Some(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_3),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOANotificationType> {
        match str {
            "MARGIN_LEVEL_THRESHOLD_1" => ::std::option::Option::Some(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1),
            "MARGIN_LEVEL_THRESHOLD_2" => ::std::option::Option::Some(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_2),
            "MARGIN_LEVEL_THRESHOLD_3" => ::std::option::Option::Some(ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_3),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOANotificationType] = &[
        ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1,
        ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_2,
        ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_3,
    ];
}

impl ::protobuf::EnumFull for ProtoOANotificationType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOANotificationType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1 => 0,
            ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_2 => 1,
            ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_3 => 2,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOANotificationType {
    fn default() -> Self {
        ProtoOANotificationType::MARGIN_LEVEL_THRESHOLD_1
    }
}

impl ProtoOANotificationType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOANotificationType>("ProtoOANotificationType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAErrorCode)
pub enum ProtoOAErrorCode {
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.OA_AUTH_TOKEN_EXPIRED)
    OA_AUTH_TOKEN_EXPIRED = 1,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.ACCOUNT_NOT_AUTHORIZED)
    ACCOUNT_NOT_AUTHORIZED = 2,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.RET_NO_SUCH_LOGIN)
    RET_NO_SUCH_LOGIN = 12,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.ALREADY_LOGGED_IN)
    ALREADY_LOGGED_IN = 14,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.RET_ACCOUNT_DISABLED)
    RET_ACCOUNT_DISABLED = 64,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_CLIENT_AUTH_FAILURE)
    CH_CLIENT_AUTH_FAILURE = 101,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_CLIENT_NOT_AUTHENTICATED)
    CH_CLIENT_NOT_AUTHENTICATED = 102,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_CLIENT_ALREADY_AUTHENTICATED)
    CH_CLIENT_ALREADY_AUTHENTICATED = 103,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_ACCESS_TOKEN_INVALID)
    CH_ACCESS_TOKEN_INVALID = 104,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_SERVER_NOT_REACHABLE)
    CH_SERVER_NOT_REACHABLE = 105,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_CTID_TRADER_ACCOUNT_NOT_FOUND)
    CH_CTID_TRADER_ACCOUNT_NOT_FOUND = 106,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CH_OA_CLIENT_NOT_FOUND)
    CH_OA_CLIENT_NOT_FOUND = 107,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.REQUEST_FREQUENCY_EXCEEDED)
    REQUEST_FREQUENCY_EXCEEDED = 108,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.SERVER_IS_UNDER_MAINTENANCE)
    SERVER_IS_UNDER_MAINTENANCE = 109,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CHANNEL_IS_BLOCKED)
    CHANNEL_IS_BLOCKED = 110,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.CONNECTIONS_LIMIT_EXCEEDED)
    CONNECTIONS_LIMIT_EXCEEDED = 67,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.WORSE_GSL_NOT_ALLOWED)
    WORSE_GSL_NOT_ALLOWED = 68,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.SYMBOL_HAS_HOLIDAY)
    SYMBOL_HAS_HOLIDAY = 69,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.NOT_SUBSCRIBED_TO_SPOTS)
    NOT_SUBSCRIBED_TO_SPOTS = 112,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.ALREADY_SUBSCRIBED)
    ALREADY_SUBSCRIBED = 113,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.SYMBOL_NOT_FOUND)
    SYMBOL_NOT_FOUND = 114,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.UNKNOWN_SYMBOL)
    UNKNOWN_SYMBOL = 115,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.INCORRECT_BOUNDARIES)
    INCORRECT_BOUNDARIES = 35,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.NO_QUOTES)
    NO_QUOTES = 117,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.NOT_ENOUGH_MONEY)
    NOT_ENOUGH_MONEY = 118,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.MAX_EXPOSURE_REACHED)
    MAX_EXPOSURE_REACHED = 119,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.POSITION_NOT_FOUND)
    POSITION_NOT_FOUND = 120,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.ORDER_NOT_FOUND)
    ORDER_NOT_FOUND = 121,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.POSITION_NOT_OPEN)
    POSITION_NOT_OPEN = 122,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.POSITION_LOCKED)
    POSITION_LOCKED = 123,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TOO_MANY_POSITIONS)
    TOO_MANY_POSITIONS = 124,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_BAD_VOLUME)
    TRADING_BAD_VOLUME = 125,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_BAD_STOPS)
    TRADING_BAD_STOPS = 126,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_BAD_PRICES)
    TRADING_BAD_PRICES = 127,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_BAD_STAKE)
    TRADING_BAD_STAKE = 128,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.PROTECTION_IS_TOO_CLOSE_TO_MARKET)
    PROTECTION_IS_TOO_CLOSE_TO_MARKET = 129,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_BAD_EXPIRATION_DATE)
    TRADING_BAD_EXPIRATION_DATE = 130,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.PENDING_EXECUTION)
    PENDING_EXECUTION = 131,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_DISABLED)
    TRADING_DISABLED = 132,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.TRADING_NOT_ALLOWED)
    TRADING_NOT_ALLOWED = 133,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.UNABLE_TO_CANCEL_ORDER)
    UNABLE_TO_CANCEL_ORDER = 134,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.UNABLE_TO_AMEND_ORDER)
    UNABLE_TO_AMEND_ORDER = 135,
    // @@protoc_insertion_point(enum_value:ProtoOAErrorCode.SHORT_SELLING_NOT_ALLOWED)
    SHORT_SELLING_NOT_ALLOWED = 136,
}

impl ::protobuf::Enum for ProtoOAErrorCode {
    const NAME: &'static str = "ProtoOAErrorCode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAErrorCode> {
        match value {
            1 => ::std::option::Option::Some(ProtoOAErrorCode::OA_AUTH_TOKEN_EXPIRED),
            2 => ::std::option::Option::Some(ProtoOAErrorCode::ACCOUNT_NOT_AUTHORIZED),
            12 => ::std::option::Option::Some(ProtoOAErrorCode::RET_NO_SUCH_LOGIN),
            14 => ::std::option::Option::Some(ProtoOAErrorCode::ALREADY_LOGGED_IN),
            64 => ::std::option::Option::Some(ProtoOAErrorCode::RET_ACCOUNT_DISABLED),
            101 => ::std::option::Option::Some(ProtoOAErrorCode::CH_CLIENT_AUTH_FAILURE),
            102 => ::std::option::Option::Some(ProtoOAErrorCode::CH_CLIENT_NOT_AUTHENTICATED),
            103 => ::std::option::Option::Some(ProtoOAErrorCode::CH_CLIENT_ALREADY_AUTHENTICATED),
            104 => ::std::option::Option::Some(ProtoOAErrorCode::CH_ACCESS_TOKEN_INVALID),
            105 => ::std::option::Option::Some(ProtoOAErrorCode::CH_SERVER_NOT_REACHABLE),
            106 => ::std::option::Option::Some(ProtoOAErrorCode::CH_CTID_TRADER_ACCOUNT_NOT_FOUND),
            107 => ::std::option::Option::Some(ProtoOAErrorCode::CH_OA_CLIENT_NOT_FOUND),
            108 => ::std::option::Option::Some(ProtoOAErrorCode::REQUEST_FREQUENCY_EXCEEDED),
            109 => ::std::option::Option::Some(ProtoOAErrorCode::SERVER_IS_UNDER_MAINTENANCE),
            110 => ::std::option::Option::Some(ProtoOAErrorCode::CHANNEL_IS_BLOCKED),
            67 => ::std::option::Option::Some(ProtoOAErrorCode::CONNECTIONS_LIMIT_EXCEEDED),
            68 => ::std::option::Option::Some(ProtoOAErrorCode::WORSE_GSL_NOT_ALLOWED),
            69 => ::std::option::Option::Some(ProtoOAErrorCode::SYMBOL_HAS_HOLIDAY),
            112 => ::std::option::Option::Some(ProtoOAErrorCode::NOT_SUBSCRIBED_TO_SPOTS),
            113 => ::std::option::Option::Some(ProtoOAErrorCode::ALREADY_SUBSCRIBED),
            114 => ::std::option::Option::Some(ProtoOAErrorCode::SYMBOL_NOT_FOUND),
            115 => ::std::option::Option::Some(ProtoOAErrorCode::UNKNOWN_SYMBOL),
            35 => ::std::option::Option::Some(ProtoOAErrorCode::INCORRECT_BOUNDARIES),
            117 => ::std::option::Option::Some(ProtoOAErrorCode::NO_QUOTES),
            118 => ::std::option::Option::Some(ProtoOAErrorCode::NOT_ENOUGH_MONEY),
            119 => ::std::option::Option::Some(ProtoOAErrorCode::MAX_EXPOSURE_REACHED),
            120 => ::std::option::Option::Some(ProtoOAErrorCode::POSITION_NOT_FOUND),
            121 => ::std::option::Option::Some(ProtoOAErrorCode::ORDER_NOT_FOUND),
            122 => ::std::option::Option::Some(ProtoOAErrorCode::POSITION_NOT_OPEN),
            123 => ::std::option::Option::Some(ProtoOAErrorCode::POSITION_LOCKED),
            124 => ::std::option::Option::Some(ProtoOAErrorCode::TOO_MANY_POSITIONS),
            125 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_VOLUME),
            126 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_STOPS),
            127 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_PRICES),
            128 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_STAKE),
            129 => ::std::option::Option::Some(ProtoOAErrorCode::PROTECTION_IS_TOO_CLOSE_TO_MARKET),
            130 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_EXPIRATION_DATE),
            131 => ::std::option::Option::Some(ProtoOAErrorCode::PENDING_EXECUTION),
            132 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_DISABLED),
            133 => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_NOT_ALLOWED),
            134 => ::std::option::Option::Some(ProtoOAErrorCode::UNABLE_TO_CANCEL_ORDER),
            135 => ::std::option::Option::Some(ProtoOAErrorCode::UNABLE_TO_AMEND_ORDER),
            136 => ::std::option::Option::Some(ProtoOAErrorCode::SHORT_SELLING_NOT_ALLOWED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAErrorCode> {
        match str {
            "OA_AUTH_TOKEN_EXPIRED" => ::std::option::Option::Some(ProtoOAErrorCode::OA_AUTH_TOKEN_EXPIRED),
            "ACCOUNT_NOT_AUTHORIZED" => ::std::option::Option::Some(ProtoOAErrorCode::ACCOUNT_NOT_AUTHORIZED),
            "RET_NO_SUCH_LOGIN" => ::std::option::Option::Some(ProtoOAErrorCode::RET_NO_SUCH_LOGIN),
            "ALREADY_LOGGED_IN" => ::std::option::Option::Some(ProtoOAErrorCode::ALREADY_LOGGED_IN),
            "RET_ACCOUNT_DISABLED" => ::std::option::Option::Some(ProtoOAErrorCode::RET_ACCOUNT_DISABLED),
            "CH_CLIENT_AUTH_FAILURE" => ::std::option::Option::Some(ProtoOAErrorCode::CH_CLIENT_AUTH_FAILURE),
            "CH_CLIENT_NOT_AUTHENTICATED" => ::std::option::Option::Some(ProtoOAErrorCode::CH_CLIENT_NOT_AUTHENTICATED),
            "CH_CLIENT_ALREADY_AUTHENTICATED" => ::std::option::Option::Some(ProtoOAErrorCode::CH_CLIENT_ALREADY_AUTHENTICATED),
            "CH_ACCESS_TOKEN_INVALID" => ::std::option::Option::Some(ProtoOAErrorCode::CH_ACCESS_TOKEN_INVALID),
            "CH_SERVER_NOT_REACHABLE" => ::std::option::Option::Some(ProtoOAErrorCode::CH_SERVER_NOT_REACHABLE),
            "CH_CTID_TRADER_ACCOUNT_NOT_FOUND" => ::std::option::Option::Some(ProtoOAErrorCode::CH_CTID_TRADER_ACCOUNT_NOT_FOUND),
            "CH_OA_CLIENT_NOT_FOUND" => ::std::option::Option::Some(ProtoOAErrorCode::CH_OA_CLIENT_NOT_FOUND),
            "REQUEST_FREQUENCY_EXCEEDED" => ::std::option::Option::Some(ProtoOAErrorCode::REQUEST_FREQUENCY_EXCEEDED),
            "SERVER_IS_UNDER_MAINTENANCE" => ::std::option::Option::Some(ProtoOAErrorCode::SERVER_IS_UNDER_MAINTENANCE),
            "CHANNEL_IS_BLOCKED" => ::std::option::Option::Some(ProtoOAErrorCode::CHANNEL_IS_BLOCKED),
            "CONNECTIONS_LIMIT_EXCEEDED" => ::std::option::Option::Some(ProtoOAErrorCode::CONNECTIONS_LIMIT_EXCEEDED),
            "WORSE_GSL_NOT_ALLOWED" => ::std::option::Option::Some(ProtoOAErrorCode::WORSE_GSL_NOT_ALLOWED),
            "SYMBOL_HAS_HOLIDAY" => ::std::option::Option::Some(ProtoOAErrorCode::SYMBOL_HAS_HOLIDAY),
            "NOT_SUBSCRIBED_TO_SPOTS" => ::std::option::Option::Some(ProtoOAErrorCode::NOT_SUBSCRIBED_TO_SPOTS),
            "ALREADY_SUBSCRIBED" => ::std::option::Option::Some(ProtoOAErrorCode::ALREADY_SUBSCRIBED),
            "SYMBOL_NOT_FOUND" => ::std::option::Option::Some(ProtoOAErrorCode::SYMBOL_NOT_FOUND),
            "UNKNOWN_SYMBOL" => ::std::option::Option::Some(ProtoOAErrorCode::UNKNOWN_SYMBOL),
            "INCORRECT_BOUNDARIES" => ::std::option::Option::Some(ProtoOAErrorCode::INCORRECT_BOUNDARIES),
            "NO_QUOTES" => ::std::option::Option::Some(ProtoOAErrorCode::NO_QUOTES),
            "NOT_ENOUGH_MONEY" => ::std::option::Option::Some(ProtoOAErrorCode::NOT_ENOUGH_MONEY),
            "MAX_EXPOSURE_REACHED" => ::std::option::Option::Some(ProtoOAErrorCode::MAX_EXPOSURE_REACHED),
            "POSITION_NOT_FOUND" => ::std::option::Option::Some(ProtoOAErrorCode::POSITION_NOT_FOUND),
            "ORDER_NOT_FOUND" => ::std::option::Option::Some(ProtoOAErrorCode::ORDER_NOT_FOUND),
            "POSITION_NOT_OPEN" => ::std::option::Option::Some(ProtoOAErrorCode::POSITION_NOT_OPEN),
            "POSITION_LOCKED" => ::std::option::Option::Some(ProtoOAErrorCode::POSITION_LOCKED),
            "TOO_MANY_POSITIONS" => ::std::option::Option::Some(ProtoOAErrorCode::TOO_MANY_POSITIONS),
            "TRADING_BAD_VOLUME" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_VOLUME),
            "TRADING_BAD_STOPS" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_STOPS),
            "TRADING_BAD_PRICES" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_PRICES),
            "TRADING_BAD_STAKE" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_STAKE),
            "PROTECTION_IS_TOO_CLOSE_TO_MARKET" => ::std::option::Option::Some(ProtoOAErrorCode::PROTECTION_IS_TOO_CLOSE_TO_MARKET),
            "TRADING_BAD_EXPIRATION_DATE" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_BAD_EXPIRATION_DATE),
            "PENDING_EXECUTION" => ::std::option::Option::Some(ProtoOAErrorCode::PENDING_EXECUTION),
            "TRADING_DISABLED" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_DISABLED),
            "TRADING_NOT_ALLOWED" => ::std::option::Option::Some(ProtoOAErrorCode::TRADING_NOT_ALLOWED),
            "UNABLE_TO_CANCEL_ORDER" => ::std::option::Option::Some(ProtoOAErrorCode::UNABLE_TO_CANCEL_ORDER),
            "UNABLE_TO_AMEND_ORDER" => ::std::option::Option::Some(ProtoOAErrorCode::UNABLE_TO_AMEND_ORDER),
            "SHORT_SELLING_NOT_ALLOWED" => ::std::option::Option::Some(ProtoOAErrorCode::SHORT_SELLING_NOT_ALLOWED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAErrorCode] = &[
        ProtoOAErrorCode::OA_AUTH_TOKEN_EXPIRED,
        ProtoOAErrorCode::ACCOUNT_NOT_AUTHORIZED,
        ProtoOAErrorCode::RET_NO_SUCH_LOGIN,
        ProtoOAErrorCode::ALREADY_LOGGED_IN,
        ProtoOAErrorCode::RET_ACCOUNT_DISABLED,
        ProtoOAErrorCode::CH_CLIENT_AUTH_FAILURE,
        ProtoOAErrorCode::CH_CLIENT_NOT_AUTHENTICATED,
        ProtoOAErrorCode::CH_CLIENT_ALREADY_AUTHENTICATED,
        ProtoOAErrorCode::CH_ACCESS_TOKEN_INVALID,
        ProtoOAErrorCode::CH_SERVER_NOT_REACHABLE,
        ProtoOAErrorCode::CH_CTID_TRADER_ACCOUNT_NOT_FOUND,
        ProtoOAErrorCode::CH_OA_CLIENT_NOT_FOUND,
        ProtoOAErrorCode::REQUEST_FREQUENCY_EXCEEDED,
        ProtoOAErrorCode::SERVER_IS_UNDER_MAINTENANCE,
        ProtoOAErrorCode::CHANNEL_IS_BLOCKED,
        ProtoOAErrorCode::CONNECTIONS_LIMIT_EXCEEDED,
        ProtoOAErrorCode::WORSE_GSL_NOT_ALLOWED,
        ProtoOAErrorCode::SYMBOL_HAS_HOLIDAY,
        ProtoOAErrorCode::NOT_SUBSCRIBED_TO_SPOTS,
        ProtoOAErrorCode::ALREADY_SUBSCRIBED,
        ProtoOAErrorCode::SYMBOL_NOT_FOUND,
        ProtoOAErrorCode::UNKNOWN_SYMBOL,
        ProtoOAErrorCode::INCORRECT_BOUNDARIES,
        ProtoOAErrorCode::NO_QUOTES,
        ProtoOAErrorCode::NOT_ENOUGH_MONEY,
        ProtoOAErrorCode::MAX_EXPOSURE_REACHED,
        ProtoOAErrorCode::POSITION_NOT_FOUND,
        ProtoOAErrorCode::ORDER_NOT_FOUND,
        ProtoOAErrorCode::POSITION_NOT_OPEN,
        ProtoOAErrorCode::POSITION_LOCKED,
        ProtoOAErrorCode::TOO_MANY_POSITIONS,
        ProtoOAErrorCode::TRADING_BAD_VOLUME,
        ProtoOAErrorCode::TRADING_BAD_STOPS,
        ProtoOAErrorCode::TRADING_BAD_PRICES,
        ProtoOAErrorCode::TRADING_BAD_STAKE,
        ProtoOAErrorCode::PROTECTION_IS_TOO_CLOSE_TO_MARKET,
        ProtoOAErrorCode::TRADING_BAD_EXPIRATION_DATE,
        ProtoOAErrorCode::PENDING_EXECUTION,
        ProtoOAErrorCode::TRADING_DISABLED,
        ProtoOAErrorCode::TRADING_NOT_ALLOWED,
        ProtoOAErrorCode::UNABLE_TO_CANCEL_ORDER,
        ProtoOAErrorCode::UNABLE_TO_AMEND_ORDER,
        ProtoOAErrorCode::SHORT_SELLING_NOT_ALLOWED,
    ];
}

impl ::protobuf::EnumFull for ProtoOAErrorCode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAErrorCode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ProtoOAErrorCode::OA_AUTH_TOKEN_EXPIRED => 0,
            ProtoOAErrorCode::ACCOUNT_NOT_AUTHORIZED => 1,
            ProtoOAErrorCode::RET_NO_SUCH_LOGIN => 2,
            ProtoOAErrorCode::ALREADY_LOGGED_IN => 3,
            ProtoOAErrorCode::RET_ACCOUNT_DISABLED => 4,
            ProtoOAErrorCode::CH_CLIENT_AUTH_FAILURE => 5,
            ProtoOAErrorCode::CH_CLIENT_NOT_AUTHENTICATED => 6,
            ProtoOAErrorCode::CH_CLIENT_ALREADY_AUTHENTICATED => 7,
            ProtoOAErrorCode::CH_ACCESS_TOKEN_INVALID => 8,
            ProtoOAErrorCode::CH_SERVER_NOT_REACHABLE => 9,
            ProtoOAErrorCode::CH_CTID_TRADER_ACCOUNT_NOT_FOUND => 10,
            ProtoOAErrorCode::CH_OA_CLIENT_NOT_FOUND => 11,
            ProtoOAErrorCode::REQUEST_FREQUENCY_EXCEEDED => 12,
            ProtoOAErrorCode::SERVER_IS_UNDER_MAINTENANCE => 13,
            ProtoOAErrorCode::CHANNEL_IS_BLOCKED => 14,
            ProtoOAErrorCode::CONNECTIONS_LIMIT_EXCEEDED => 15,
            ProtoOAErrorCode::WORSE_GSL_NOT_ALLOWED => 16,
            ProtoOAErrorCode::SYMBOL_HAS_HOLIDAY => 17,
            ProtoOAErrorCode::NOT_SUBSCRIBED_TO_SPOTS => 18,
            ProtoOAErrorCode::ALREADY_SUBSCRIBED => 19,
            ProtoOAErrorCode::SYMBOL_NOT_FOUND => 20,
            ProtoOAErrorCode::UNKNOWN_SYMBOL => 21,
            ProtoOAErrorCode::INCORRECT_BOUNDARIES => 22,
            ProtoOAErrorCode::NO_QUOTES => 23,
            ProtoOAErrorCode::NOT_ENOUGH_MONEY => 24,
            ProtoOAErrorCode::MAX_EXPOSURE_REACHED => 25,
            ProtoOAErrorCode::POSITION_NOT_FOUND => 26,
            ProtoOAErrorCode::ORDER_NOT_FOUND => 27,
            ProtoOAErrorCode::POSITION_NOT_OPEN => 28,
            ProtoOAErrorCode::POSITION_LOCKED => 29,
            ProtoOAErrorCode::TOO_MANY_POSITIONS => 30,
            ProtoOAErrorCode::TRADING_BAD_VOLUME => 31,
            ProtoOAErrorCode::TRADING_BAD_STOPS => 32,
            ProtoOAErrorCode::TRADING_BAD_PRICES => 33,
            ProtoOAErrorCode::TRADING_BAD_STAKE => 34,
            ProtoOAErrorCode::PROTECTION_IS_TOO_CLOSE_TO_MARKET => 35,
            ProtoOAErrorCode::TRADING_BAD_EXPIRATION_DATE => 36,
            ProtoOAErrorCode::PENDING_EXECUTION => 37,
            ProtoOAErrorCode::TRADING_DISABLED => 38,
            ProtoOAErrorCode::TRADING_NOT_ALLOWED => 39,
            ProtoOAErrorCode::UNABLE_TO_CANCEL_ORDER => 40,
            ProtoOAErrorCode::UNABLE_TO_AMEND_ORDER => 41,
            ProtoOAErrorCode::SHORT_SELLING_NOT_ALLOWED => 42,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ProtoOAErrorCode {
    fn default() -> Self {
        ProtoOAErrorCode::OA_AUTH_TOKEN_EXPIRED
    }
}

impl ProtoOAErrorCode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAErrorCode>("ProtoOAErrorCode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOALimitedRiskMarginCalculationStrategy)
pub enum ProtoOALimitedRiskMarginCalculationStrategy {
    // @@protoc_insertion_point(enum_value:ProtoOALimitedRiskMarginCalculationStrategy.ACCORDING_TO_LEVERAGE)
    ACCORDING_TO_LEVERAGE = 0,
    // @@protoc_insertion_point(enum_value:ProtoOALimitedRiskMarginCalculationStrategy.ACCORDING_TO_GSL)
    ACCORDING_TO_GSL = 1,
    // @@protoc_insertion_point(enum_value:ProtoOALimitedRiskMarginCalculationStrategy.ACCORDING_TO_GSL_AND_LEVERAGE)
    ACCORDING_TO_GSL_AND_LEVERAGE = 2,
}

impl ::protobuf::Enum for ProtoOALimitedRiskMarginCalculationStrategy {
    const NAME: &'static str = "ProtoOALimitedRiskMarginCalculationStrategy";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOALimitedRiskMarginCalculationStrategy> {
        match value {
            0 => ::std::option::Option::Some(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_LEVERAGE),
            1 => ::std::option::Option::Some(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_GSL),
            2 => ::std::option::Option::Some(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_GSL_AND_LEVERAGE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOALimitedRiskMarginCalculationStrategy> {
        match str {
            "ACCORDING_TO_LEVERAGE" => ::std::option::Option::Some(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_LEVERAGE),
            "ACCORDING_TO_GSL" => ::std::option::Option::Some(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_GSL),
            "ACCORDING_TO_GSL_AND_LEVERAGE" => ::std::option::Option::Some(ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_GSL_AND_LEVERAGE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOALimitedRiskMarginCalculationStrategy] = &[
        ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_LEVERAGE,
        ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_GSL,
        ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_GSL_AND_LEVERAGE,
    ];
}

impl ::protobuf::EnumFull for ProtoOALimitedRiskMarginCalculationStrategy {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOALimitedRiskMarginCalculationStrategy").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOALimitedRiskMarginCalculationStrategy {
    fn default() -> Self {
        ProtoOALimitedRiskMarginCalculationStrategy::ACCORDING_TO_LEVERAGE
    }
}

impl ProtoOALimitedRiskMarginCalculationStrategy {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOALimitedRiskMarginCalculationStrategy>("ProtoOALimitedRiskMarginCalculationStrategy")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ProtoOAStopOutStrategy)
pub enum ProtoOAStopOutStrategy {
    // @@protoc_insertion_point(enum_value:ProtoOAStopOutStrategy.MOST_MARGIN_USED_FIRST)
    MOST_MARGIN_USED_FIRST = 0,
    // @@protoc_insertion_point(enum_value:ProtoOAStopOutStrategy.MOST_LOSING_FIRST)
    MOST_LOSING_FIRST = 1,
}

impl ::protobuf::Enum for ProtoOAStopOutStrategy {
    const NAME: &'static str = "ProtoOAStopOutStrategy";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ProtoOAStopOutStrategy> {
        match value {
            0 => ::std::option::Option::Some(ProtoOAStopOutStrategy::MOST_MARGIN_USED_FIRST),
            1 => ::std::option::Option::Some(ProtoOAStopOutStrategy::MOST_LOSING_FIRST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ProtoOAStopOutStrategy> {
        match str {
            "MOST_MARGIN_USED_FIRST" => ::std::option::Option::Some(ProtoOAStopOutStrategy::MOST_MARGIN_USED_FIRST),
            "MOST_LOSING_FIRST" => ::std::option::Option::Some(ProtoOAStopOutStrategy::MOST_LOSING_FIRST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ProtoOAStopOutStrategy] = &[
        ProtoOAStopOutStrategy::MOST_MARGIN_USED_FIRST,
        ProtoOAStopOutStrategy::MOST_LOSING_FIRST,
    ];
}

impl ::protobuf::EnumFull for ProtoOAStopOutStrategy {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ProtoOAStopOutStrategy").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ProtoOAStopOutStrategy {
    fn default() -> Self {
        ProtoOAStopOutStrategy::MOST_MARGIN_USED_FIRST
    }
}

impl ProtoOAStopOutStrategy {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ProtoOAStopOutStrategy>("ProtoOAStopOutStrategy")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1aOpenApiModelMessages.proto\"v\n\x0cProtoOAAsset\x12\x18\n\x07asset\
    Id\x18\x01\x20\x02(\x03R\x07assetId\x12\x12\n\x04name\x18\x02\x20\x02(\t\
    R\x04name\x12\x20\n\x0bdisplayName\x18\x03\x20\x01(\tR\x0bdisplayName\
    \x12\x16\n\x06digits\x18\x04\x20\x01(\x05R\x06digits\"\xc5\x0e\n\rProtoO\
    ASymbol\x12\x1a\n\x08symbolId\x18\x01\x20\x02(\x03R\x08symbolId\x12\x16\
    \n\x06digits\x18\x02\x20\x02(\x05R\x06digits\x12\x20\n\x0bpipPosition\
    \x18\x03\x20\x02(\x05R\x0bpipPosition\x12.\n\x12enableShortSelling\x18\
    \x04\x20\x01(\x08R\x12enableShortSelling\x12.\n\x12guaranteedStopLoss\
    \x18\x05\x20\x01(\x08R\x12guaranteedStopLoss\x12G\n\x11swapRollover3Days\
    \x18\x06\x20\x01(\x0e2\x11.ProtoOADayOfWeek:\x06MONDAYR\x11swapRollover3\
    Days\x12\x1a\n\x08swapLong\x18\x07\x20\x01(\x01R\x08swapLong\x12\x1c\n\t\
    swapShort\x18\x08\x20\x01(\x01R\tswapShort\x12\x1c\n\tmaxVolume\x18\t\
    \x20\x01(\x03R\tmaxVolume\x12\x1c\n\tminVolume\x18\n\x20\x01(\x03R\tminV\
    olume\x12\x1e\n\nstepVolume\x18\x0b\x20\x01(\x03R\nstepVolume\x12\x20\n\
    \x0bmaxExposure\x18\x0c\x20\x01(\x04R\x0bmaxExposure\x12,\n\x08schedule\
    \x18\r\x20\x03(\x0b2\x10.ProtoOAIntervalR\x08schedule\x12\"\n\ncommissio\
    n\x18\x0e\x20\x01(\x03R\ncommissionB\x02\x18\x01\x12S\n\x0ecommissionTyp\
    e\x18\x0f\x20\x01(\x0e2\x16.ProtoOACommissionType:\x13USD_PER_MILLION_US\
    DR\x0ecommissionType\x12\x1e\n\nslDistance\x18\x10\x20\x01(\rR\nslDistan\
    ce\x12\x1e\n\ntpDistance\x18\x11\x20\x01(\rR\ntpDistance\x12\x20\n\x0bgs\
    lDistance\x18\x12\x20\x01(\rR\x0bgslDistance\x12\x1c\n\tgslCharge\x18\
    \x13\x20\x01(\x03R\tgslCharge\x12[\n\rdistanceSetIn\x18\x14\x20\x01(\x0e\
    2\x1a.ProtoOASymbolDistanceType:\x19SYMBOL_DISTANCE_IN_POINTSR\rdistance\
    SetIn\x12(\n\rminCommission\x18\x15\x20\x01(\x03R\rminCommissionB\x02\
    \x18\x01\x12Q\n\x11minCommissionType\x18\x16\x20\x01(\x0e2\x19.ProtoOAMi\
    nCommissionType:\x08CURRENCYR\x11minCommissionType\x123\n\x12minCommissi\
    onAsset\x18\x17\x20\x01(\t:\x03USDR\x12minCommissionAsset\x12.\n\x12roll\
    overCommission\x18\x18\x20\x01(\x03R\x12rolloverCommission\x12*\n\x10ski\
    pRolloverDays\x18\x19\x20\x01(\x05R\x10skipRolloverDays\x12*\n\x10schedu\
    leTimeZone\x18\x1a\x20\x01(\tR\x10scheduleTimeZone\x12>\n\x0btradingMode\
    \x18\x1b\x20\x01(\x0e2\x13.ProtoOATradingMode:\x07ENABLEDR\x0btradingMod\
    e\x12S\n\x17rolloverCommission3Days\x18\x1c\x20\x01(\x0e2\x11.ProtoOADay\
    OfWeek:\x06MONDAYR\x17rolloverCommission3Days\x12S\n\x13swapCalculationT\
    ype\x18\x1d\x20\x01(\x0e2\x1b.ProtoOASwapCalculationType:\x04PIPSR\x13sw\
    apCalculationType\x12\x18\n\x07lotSize\x18\x1e\x20\x01(\x03R\x07lotSize\
    \x12B\n\x1cpreciseTradingCommissionRate\x18\x1f\x20\x01(\x03R\x1cprecise\
    TradingCommissionRate\x122\n\x14preciseMinCommission\x18\x20\x20\x01(\
    \x03R\x14preciseMinCommission\x12)\n\x07holiday\x18!\x20\x03(\x0b2\x0f.P\
    rotoOAHolidayR\x07holiday\x122\n\x14pnlConversionFeeRate\x18\"\x20\x01(\
    \x05R\x14pnlConversionFeeRate\x12\x1e\n\nleverageId\x18#\x20\x01(\x03R\n\
    leverageId\x12\x1e\n\nswapPeriod\x18$\x20\x01(\x05R\nswapPeriod\x12\x1a\
    \n\x08swapTime\x18%\x20\x01(\x05R\x08swapTime\x12(\n\x0fskipSWAPPeriods\
    \x18&\x20\x01(\x05R\x0fskipSWAPPeriods\x122\n\x14chargeSwapAtWeekends\
    \x18'\x20\x01(\x08R\x14chargeSwapAtWeekends\x12*\n\x10measurementUnits\
    \x18(\x20\x01(\tR\x10measurementUnits\"\xa4\x02\n\x12ProtoOALightSymbol\
    \x12\x1a\n\x08symbolId\x18\x01\x20\x02(\x03R\x08symbolId\x12\x1e\n\nsymb\
    olName\x18\x02\x20\x01(\tR\nsymbolName\x12\x18\n\x07enabled\x18\x03\x20\
    \x01(\x08R\x07enabled\x12\x20\n\x0bbaseAssetId\x18\x04\x20\x01(\x03R\x0b\
    baseAssetId\x12\"\n\x0cquoteAssetId\x18\x05\x20\x01(\x03R\x0cquoteAssetI\
    d\x12*\n\x10symbolCategoryId\x18\x06\x20\x01(\x03R\x10symbolCategoryId\
    \x12\x20\n\x0bdescription\x18\x07\x20\x01(\tR\x0bdescription\x12$\n\rsor\
    tingNumber\x18\x08\x20\x01(\x01R\rsortingNumber\"\xa1\x01\n\x15ProtoOAAr\
    chivedSymbol\x12\x1a\n\x08symbolId\x18\x01\x20\x02(\x03R\x08symbolId\x12\
    \x12\n\x04name\x18\x02\x20\x02(\tR\x04name\x126\n\x16utcLastUpdateTimest\
    amp\x18\x03\x20\x02(\x03R\x16utcLastUpdateTimestamp\x12\x20\n\x0bdescrip\
    tion\x18\x04\x20\x01(\tR\x0bdescription\"\x85\x01\n\x15ProtoOASymbolCate\
    gory\x12\x0e\n\x02id\x18\x01\x20\x02(\x03R\x02id\x12\"\n\x0cassetClassId\
    \x18\x02\x20\x02(\x03R\x0cassetClassId\x12\x12\n\x04name\x18\x03\x20\x02\
    (\tR\x04name\x12$\n\rsortingNumber\x18\x04\x20\x01(\x01R\rsortingNumber\
    \"Q\n\x0fProtoOAInterval\x12\x20\n\x0bstartSecond\x18\x03\x20\x02(\rR\
    \x0bstartSecond\x12\x1c\n\tendSecond\x18\x04\x20\x02(\rR\tendSecond\"\
    \xea\x08\n\rProtoOATrader\x120\n\x13ctidTraderAccountId\x18\x01\x20\x02(\
    \x03R\x13ctidTraderAccountId\x12\x18\n\x07balance\x18\x02\x20\x02(\x03R\
    \x07balance\x12&\n\x0ebalanceVersion\x18\x03\x20\x01(\x03R\x0ebalanceVer\
    sion\x12\"\n\x0cmanagerBonus\x18\x04\x20\x01(\x03R\x0cmanagerBonus\x12\
    \x18\n\x07ibBonus\x18\x05\x20\x01(\x03R\x07ibBonus\x122\n\x14nonWithdraw\
    ableBonus\x18\x06\x20\x01(\x03R\x14nonWithdrawableBonus\x12E\n\x0caccess\
    Rights\x18\x07\x20\x01(\x0e2\x14.ProtoOAAccessRights:\x0bFULL_ACCESSR\
    \x0caccessRights\x12&\n\x0edepositAssetId\x18\x08\x20\x02(\x03R\x0edepos\
    itAssetId\x12\x1a\n\x08swapFree\x18\t\x20\x01(\x08R\x08swapFree\x12(\n\
    \x0fleverageInCents\x18\n\x20\x01(\rR\x0fleverageInCents\x12b\n\x1atotal\
    MarginCalculationType\x18\x0b\x20\x01(\x0e2\".ProtoOATotalMarginCalculat\
    ionTypeR\x1atotalMarginCalculationType\x12\x20\n\x0bmaxLeverage\x18\x0c\
    \x20\x01(\rR\x0bmaxLeverage\x12\"\n\nfrenchRisk\x18\r\x20\x01(\x08R\nfre\
    nchRiskB\x02\x18\x01\x12\x20\n\x0btraderLogin\x18\x0e\x20\x01(\x03R\x0bt\
    raderLogin\x12=\n\x0baccountType\x18\x0f\x20\x01(\x0e2\x13.ProtoOAAccoun\
    tType:\x06HEDGEDR\x0baccountType\x12\x1e\n\nbrokerName\x18\x10\x20\x01(\
    \tR\nbrokerName\x124\n\x15registrationTimestamp\x18\x11\x20\x01(\x03R\
    \x15registrationTimestamp\x12$\n\risLimitedRisk\x18\x12\x20\x01(\x08R\ri\
    sLimitedRisk\x12\x97\x01\n$limitedRiskMarginCalculationStrategy\x18\x13\
    \x20\x01(\x0e2,.ProtoOALimitedRiskMarginCalculationStrategy:\x15ACCORDIN\
    G_TO_LEVERAGER$limitedRiskMarginCalculationStrategy\x12\x20\n\x0bmoneyDi\
    gits\x18\x14\x20\x01(\rR\x0bmoneyDigits\x12\x20\n\x0bfairStopOut\x18\x15\
    \x20\x01(\x08R\x0bfairStopOut\x12Y\n\x0fstopOutStrategy\x18\x16\x20\x01(\
    \x0e2\x17.ProtoOAStopOutStrategy:\x16MOST_MARGIN_USED_FIRSTR\x0fstopOutS\
    trategy\"\xa9\x05\n\x0fProtoOAPosition\x12\x1e\n\npositionId\x18\x01\x20\
    \x02(\x03R\npositionId\x12/\n\ttradeData\x18\x02\x20\x02(\x0b2\x11.Proto\
    OATradeDataR\ttradeData\x12>\n\x0epositionStatus\x18\x03\x20\x02(\x0e2\
    \x16.ProtoOAPositionStatusR\x0epositionStatus\x12\x12\n\x04swap\x18\x04\
    \x20\x02(\x03R\x04swap\x12\x14\n\x05price\x18\x05\x20\x01(\x01R\x05price\
    \x12\x1a\n\x08stopLoss\x18\x06\x20\x01(\x01R\x08stopLoss\x12\x1e\n\ntake\
    Profit\x18\x07\x20\x01(\x01R\ntakeProfit\x126\n\x16utcLastUpdateTimestam\
    p\x18\x08\x20\x01(\x03R\x16utcLastUpdateTimestamp\x12\x1e\n\ncommission\
    \x18\t\x20\x01(\x03R\ncommission\x12\x1e\n\nmarginRate\x18\n\x20\x01(\
    \x01R\nmarginRate\x120\n\x13mirroringCommission\x18\x0b\x20\x01(\x03R\
    \x13mirroringCommission\x12.\n\x12guaranteedStopLoss\x18\x0c\x20\x01(\
    \x08R\x12guaranteedStopLoss\x12\x1e\n\nusedMargin\x18\r\x20\x01(\x04R\nu\
    sedMargin\x12W\n\x15stopLossTriggerMethod\x18\x0e\x20\x01(\x0e2\x1a.Prot\
    oOAOrderTriggerMethod:\x05TRADER\x15stopLossTriggerMethod\x12\x20\n\x0bm\
    oneyDigits\x18\x0f\x20\x01(\rR\x0bmoneyDigits\x12*\n\x10trailingStopLoss\
    \x18\x10\x20\x01(\x08R\x10trailingStopLoss\"\xd1\x02\n\x10ProtoOATradeDa\
    ta\x12\x1a\n\x08symbolId\x18\x01\x20\x02(\x03R\x08symbolId\x12\x16\n\x06\
    volume\x18\x02\x20\x02(\x03R\x06volume\x12/\n\ttradeSide\x18\x03\x20\x02\
    (\x0e2\x11.ProtoOATradeSideR\ttradeSide\x12$\n\ropenTimestamp\x18\x04\
    \x20\x01(\x03R\ropenTimestamp\x12\x14\n\x05label\x18\x05\x20\x01(\tR\x05\
    label\x12.\n\x12guaranteedStopLoss\x18\x06\x20\x01(\x08R\x12guaranteedSt\
    opLoss\x12\x18\n\x07comment\x18\x07\x20\x01(\tR\x07comment\x12*\n\x10mea\
    surementUnits\x18\x08\x20\x01(\tR\x10measurementUnits\x12&\n\x0ecloseTim\
    estamp\x18\t\x20\x01(\x04R\x0ecloseTimestamp\"\xfc\x07\n\x0cProtoOAOrder\
    \x12\x18\n\x07orderId\x18\x01\x20\x02(\x03R\x07orderId\x12/\n\ttradeData\
    \x18\x02\x20\x02(\x0b2\x11.ProtoOATradeDataR\ttradeData\x12/\n\torderTyp\
    e\x18\x03\x20\x02(\x0e2\x11.ProtoOAOrderTypeR\torderType\x125\n\x0border\
    Status\x18\x04\x20\x02(\x0e2\x13.ProtoOAOrderStatusR\x0borderStatus\x120\
    \n\x13expirationTimestamp\x18\x06\x20\x01(\x03R\x13expirationTimestamp\
    \x12&\n\x0eexecutionPrice\x18\x07\x20\x01(\x01R\x0eexecutionPrice\x12&\n\
    \x0eexecutedVolume\x18\x08\x20\x01(\x03R\x0eexecutedVolume\x126\n\x16utc\
    LastUpdateTimestamp\x18\t\x20\x01(\x03R\x16utcLastUpdateTimestamp\x12,\n\
    \x11baseSlippagePrice\x18\n\x20\x01(\x01R\x11baseSlippagePrice\x12*\n\
    \x10slippageInPoints\x18\x0b\x20\x01(\x03R\x10slippageInPoints\x12\"\n\
    \x0cclosingOrder\x18\x0c\x20\x01(\x08R\x0cclosingOrder\x12\x1e\n\nlimitP\
    rice\x18\r\x20\x01(\x01R\nlimitPrice\x12\x1c\n\tstopPrice\x18\x0e\x20\
    \x01(\x01R\tstopPrice\x12\x1a\n\x08stopLoss\x18\x0f\x20\x01(\x01R\x08sto\
    pLoss\x12\x1e\n\ntakeProfit\x18\x10\x20\x01(\x01R\ntakeProfit\x12$\n\rcl\
    ientOrderId\x18\x11\x20\x01(\tR\rclientOrderId\x12J\n\x0btimeInForce\x18\
    \x12\x20\x01(\x0e2\x13.ProtoOATimeInForce:\x13IMMEDIATE_OR_CANCELR\x0bti\
    meInForce\x12\x1e\n\npositionId\x18\x13\x20\x01(\x03R\npositionId\x12*\n\
    \x10relativeStopLoss\x18\x14\x20\x01(\x03R\x10relativeStopLoss\x12.\n\
    \x12relativeTakeProfit\x18\x15\x20\x01(\x03R\x12relativeTakeProfit\x12\
    \x1c\n\tisStopOut\x18\x16\x20\x01(\x08R\tisStopOut\x12*\n\x10trailingSto\
    pLoss\x18\x17\x20\x01(\x08R\x10trailingStopLoss\x12O\n\x11stopTriggerMet\
    hod\x18\x18\x20\x01(\x0e2\x1a.ProtoOAOrderTriggerMethod:\x05TRADER\x11st\
    opTriggerMethod\"\xac\x03\n\x1bProtoOABonusDepositWithdraw\x12=\n\ropera\
    tionType\x18\x01\x20\x02(\x0e2\x17.ProtoOAChangeBonusTypeR\roperationTyp\
    e\x12&\n\x0ebonusHistoryId\x18\x02\x20\x02(\x03R\x0ebonusHistoryId\x12\"\
    \n\x0cmanagerBonus\x18\x03\x20\x02(\x03R\x0cmanagerBonus\x12\"\n\x0cmana\
    gerDelta\x18\x04\x20\x02(\x03R\x0cmanagerDelta\x12\x18\n\x07ibBonus\x18\
    \x05\x20\x02(\x03R\x07ibBonus\x12\x18\n\x07ibDelta\x18\x06\x20\x02(\x03R\
    \x07ibDelta\x122\n\x14changeBonusTimestamp\x18\x07\x20\x02(\x03R\x14chan\
    geBonusTimestamp\x12\"\n\x0cexternalNote\x18\x08\x20\x01(\tR\x0cexternal\
    Note\x120\n\x13introducingBrokerId\x18\t\x20\x01(\x03R\x13introducingBro\
    kerId\x12\x20\n\x0bmoneyDigits\x18\n\x20\x01(\rR\x0bmoneyDigits\"\xf3\
    \x02\n\x16ProtoOADepositWithdraw\x12?\n\roperationType\x18\x01\x20\x02(\
    \x0e2\x19.ProtoOAChangeBalanceTypeR\roperationType\x12*\n\x10balanceHist\
    oryId\x18\x02\x20\x02(\x03R\x10balanceHistoryId\x12\x18\n\x07balance\x18\
    \x03\x20\x02(\x03R\x07balance\x12\x14\n\x05delta\x18\x04\x20\x02(\x03R\
    \x05delta\x126\n\x16changeBalanceTimestamp\x18\x05\x20\x02(\x03R\x16chan\
    geBalanceTimestamp\x12\"\n\x0cexternalNote\x18\x06\x20\x01(\tR\x0cextern\
    alNote\x12&\n\x0ebalanceVersion\x18\x07\x20\x01(\x03R\x0ebalanceVersion\
    \x12\x16\n\x06equity\x18\x08\x20\x01(\x03R\x06equity\x12\x20\n\x0bmoneyD\
    igits\x18\t\x20\x01(\rR\x0bmoneyDigits\"\xc1\x05\n\x0bProtoOADeal\x12\
    \x16\n\x06dealId\x18\x01\x20\x02(\x03R\x06dealId\x12\x18\n\x07orderId\
    \x18\x02\x20\x02(\x03R\x07orderId\x12\x1e\n\npositionId\x18\x03\x20\x02(\
    \x03R\npositionId\x12\x16\n\x06volume\x18\x04\x20\x02(\x03R\x06volume\
    \x12\"\n\x0cfilledVolume\x18\x05\x20\x02(\x03R\x0cfilledVolume\x12\x1a\n\
    \x08symbolId\x18\x06\x20\x02(\x03R\x08symbolId\x12(\n\x0fcreateTimestamp\
    \x18\x07\x20\x02(\x03R\x0fcreateTimestamp\x12.\n\x12executionTimestamp\
    \x18\x08\x20\x02(\x03R\x12executionTimestamp\x126\n\x16utcLastUpdateTime\
    stamp\x18\t\x20\x01(\x03R\x16utcLastUpdateTimestamp\x12&\n\x0eexecutionP\
    rice\x18\n\x20\x01(\x01R\x0eexecutionPrice\x12/\n\ttradeSide\x18\x0b\x20\
    \x02(\x0e2\x11.ProtoOATradeSideR\ttradeSide\x122\n\ndealStatus\x18\x0c\
    \x20\x02(\x0e2\x12.ProtoOADealStatusR\ndealStatus\x12\x1e\n\nmarginRate\
    \x18\r\x20\x01(\x01R\nmarginRate\x12\x1e\n\ncommission\x18\x0e\x20\x01(\
    \x03R\ncommission\x128\n\x17baseToUsdConversionRate\x18\x0f\x20\x01(\x01\
    R\x17baseToUsdConversionRate\x12M\n\x13closePositionDetail\x18\x10\x20\
    \x01(\x0b2\x1b.ProtoOAClosePositionDetailR\x13closePositionDetail\x12\
    \x20\n\x0bmoneyDigits\x18\x11\x20\x01(\rR\x0bmoneyDigits\"\x9b\x01\n\x11\
    ProtoOADealOffset\x12\x16\n\x06dealId\x18\x01\x20\x02(\x03R\x06dealId\
    \x12\x16\n\x06volume\x18\x02\x20\x02(\x03R\x06volume\x12.\n\x12execution\
    Timestamp\x18\x03\x20\x01(\x03R\x12executionTimestamp\x12&\n\x0eexecutio\
    nPrice\x18\x04\x20\x01(\x01R\x0eexecutionPrice\"\x8a\x03\n\x1aProtoOAClo\
    sePositionDetail\x12\x1e\n\nentryPrice\x18\x01\x20\x02(\x01R\nentryPrice\
    \x12\x20\n\x0bgrossProfit\x18\x02\x20\x02(\x03R\x0bgrossProfit\x12\x12\n\
    \x04swap\x18\x03\x20\x02(\x03R\x04swap\x12\x1e\n\ncommission\x18\x04\x20\
    \x02(\x03R\ncommission\x12\x18\n\x07balance\x18\x05\x20\x02(\x03R\x07bal\
    ance\x12B\n\x1cquoteToDepositConversionRate\x18\x06\x20\x01(\x01R\x1cquo\
    teToDepositConversionRate\x12\"\n\x0cclosedVolume\x18\x07\x20\x01(\x03R\
    \x0cclosedVolume\x12&\n\x0ebalanceVersion\x18\x08\x20\x01(\x03R\x0ebalan\
    ceVersion\x12\x20\n\x0bmoneyDigits\x18\t\x20\x01(\rR\x0bmoneyDigits\x12*\
    \n\x10pnlConversionFee\x18\n\x20\x01(\x03R\x10pnlConversionFee\"\x81\x02\
    \n\x0fProtoOATrendbar\x12\x16\n\x06volume\x18\x03\x20\x02(\x03R\x06volum\
    e\x122\n\x06period\x18\x04\x20\x01(\x0e2\x16.ProtoOATrendbarPeriod:\x02M\
    1R\x06period\x12\x10\n\x03low\x18\x05\x20\x01(\x03R\x03low\x12\x1c\n\tde\
    ltaOpen\x18\x06\x20\x01(\x04R\tdeltaOpen\x12\x1e\n\ndeltaClose\x18\x07\
    \x20\x01(\x04R\ndeltaClose\x12\x1c\n\tdeltaHigh\x18\x08\x20\x01(\x04R\td\
    eltaHigh\x124\n\x15utcTimestampInMinutes\x18\t\x20\x01(\rR\x15utcTimesta\
    mpInMinutes\"m\n\x15ProtoOAExpectedMargin\x12\x16\n\x06volume\x18\x01\
    \x20\x02(\x03R\x06volume\x12\x1c\n\tbuyMargin\x18\x02\x20\x02(\x03R\tbuy\
    Margin\x12\x1e\n\nsellMargin\x18\x03\x20\x02(\x03R\nsellMargin\"C\n\x0fP\
    rotoOATickData\x12\x1c\n\ttimestamp\x18\x01\x20\x02(\x03R\ttimestamp\x12\
    \x12\n\x04tick\x18\x02\x20\x02(\x03R\x04tick\",\n\x12ProtoOACtidProfile\
    \x12\x16\n\x06userId\x18\x01\x20\x02(\x03R\x06userId\"\xae\x02\n\x18Prot\
    oOACtidTraderAccount\x120\n\x13ctidTraderAccountId\x18\x01\x20\x02(\x04R\
    \x13ctidTraderAccountId\x12\x16\n\x06isLive\x18\x02\x20\x01(\x08R\x06isL\
    ive\x12\x20\n\x0btraderLogin\x18\x03\x20\x01(\x03R\x0btraderLogin\x12:\n\
    \x18lastClosingDealTimestamp\x18\x04\x20\x01(\x03R\x18lastClosingDealTim\
    estamp\x12>\n\x1alastBalanceUpdateTimestamp\x18\x05\x20\x01(\x03R\x1alas\
    tBalanceUpdateTimestamp\x12*\n\x10brokerTitleShort\x18\x06\x20\x01(\tR\
    \x10brokerTitleShort\"]\n\x11ProtoOAAssetClass\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x03R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12$\
    \n\rsortingNumber\x18\x03\x20\x01(\x01R\rsortingNumber\"[\n\x11ProtoOADe\
    pthQuote\x12\x0e\n\x02id\x18\x01\x20\x02(\x04R\x02id\x12\x12\n\x04size\
    \x18\x03\x20\x02(\x04R\x04size\x12\x10\n\x03bid\x18\x04\x20\x01(\x04R\
    \x03bid\x12\x10\n\x03ask\x18\x05\x20\x01(\x04R\x03ask\"\xc1\x01\n\x11Pro\
    toOAMarginCall\x12@\n\x0emarginCallType\x18\x01\x20\x02(\x0e2\x18.ProtoO\
    ANotificationTypeR\x0emarginCallType\x122\n\x14marginLevelThreshold\x18\
    \x02\x20\x02(\x01R\x14marginLevelThreshold\x126\n\x16utcLastUpdateTimest\
    amp\x18\x03\x20\x01(\x03R\x16utcLastUpdateTimestamp\"\x94\x02\n\x0eProto\
    OAHoliday\x12\x1c\n\tholidayId\x18\x01\x20\x02(\x03R\tholidayId\x12\x12\
    \n\x04name\x18\x02\x20\x02(\tR\x04name\x12\x20\n\x0bdescription\x18\x03\
    \x20\x01(\tR\x0bdescription\x12*\n\x10scheduleTimeZone\x18\x04\x20\x02(\
    \tR\x10scheduleTimeZone\x12\x20\n\x0bholidayDate\x18\x05\x20\x02(\x03R\
    \x0bholidayDate\x12\x20\n\x0bisRecurring\x18\x06\x20\x02(\x08R\x0bisRecu\
    rring\x12\x20\n\x0bstartSecond\x18\x07\x20\x01(\x05R\x0bstartSecond\x12\
    \x1c\n\tendSecond\x18\x08\x20\x01(\x05R\tendSecond\"k\n\x16ProtoOADynami\
    cLeverage\x12\x1e\n\nleverageId\x18\x01\x20\x02(\x03R\nleverageId\x121\n\
    \x05tiers\x18\x02\x20\x03(\x0b2\x1b.ProtoOADynamicLeverageTierR\x05tiers\
    \"P\n\x1aProtoOADynamicLeverageTier\x12\x16\n\x06volume\x18\x01\x20\x02(\
    \x03R\x06volume\x12\x1a\n\x08leverage\x18\x02\x20\x02(\x05R\x08leverage\
    \"\x9a\x01\n\x1cProtoOAPositionUnrealizedPnL\x12\x1e\n\npositionId\x18\
    \x01\x20\x02(\x03R\npositionId\x12.\n\x12grossUnrealizedPnL\x18\x02\x20\
    \x02(\x03R\x12grossUnrealizedPnL\x12*\n\x10netUnrealizedPnL\x18\x03\x20\
    \x02(\x03R\x10netUnrealizedPnL*\xb1\x19\n\x12ProtoOAPayloadType\x12\"\n\
    \x1dPROTO_OA_APPLICATION_AUTH_REQ\x10\xb4\x10\x12\"\n\x1dPROTO_OA_APPLIC\
    ATION_AUTH_RES\x10\xb5\x10\x12\x1e\n\x19PROTO_OA_ACCOUNT_AUTH_REQ\x10\
    \xb6\x10\x12\x1e\n\x19PROTO_OA_ACCOUNT_AUTH_RES\x10\xb7\x10\x12\x19\n\
    \x14PROTO_OA_VERSION_REQ\x10\xb8\x10\x12\x19\n\x14PROTO_OA_VERSION_RES\
    \x10\xb9\x10\x12\x1b\n\x16PROTO_OA_NEW_ORDER_REQ\x10\xba\x10\x12'\n\"PRO\
    TO_OA_TRAILING_SL_CHANGED_EVENT\x10\xbb\x10\x12\x1e\n\x19PROTO_OA_CANCEL\
    _ORDER_REQ\x10\xbc\x10\x12\x1d\n\x18PROTO_OA_AMEND_ORDER_REQ\x10\xbd\x10\
    \x12%\n\x20PROTO_OA_AMEND_POSITION_SLTP_REQ\x10\xbe\x10\x12\x20\n\x1bPRO\
    TO_OA_CLOSE_POSITION_REQ\x10\xbf\x10\x12\x1c\n\x17PROTO_OA_ASSET_LIST_RE\
    Q\x10\xc0\x10\x12\x1c\n\x17PROTO_OA_ASSET_LIST_RES\x10\xc1\x10\x12\x1e\n\
    \x19PROTO_OA_SYMBOLS_LIST_REQ\x10\xc2\x10\x12\x1e\n\x19PROTO_OA_SYMBOLS_\
    LIST_RES\x10\xc3\x10\x12\x1e\n\x19PROTO_OA_SYMBOL_BY_ID_REQ\x10\xc4\x10\
    \x12\x1e\n\x19PROTO_OA_SYMBOL_BY_ID_RES\x10\xc5\x10\x12(\n#PROTO_OA_SYMB\
    OLS_FOR_CONVERSION_REQ\x10\xc6\x10\x12(\n#PROTO_OA_SYMBOLS_FOR_CONVERSIO\
    N_RES\x10\xc7\x10\x12\"\n\x1dPROTO_OA_SYMBOL_CHANGED_EVENT\x10\xc8\x10\
    \x12\x18\n\x13PROTO_OA_TRADER_REQ\x10\xc9\x10\x12\x18\n\x13PROTO_OA_TRAD\
    ER_RES\x10\xca\x10\x12!\n\x1cPROTO_OA_TRADER_UPDATE_EVENT\x10\xcb\x10\
    \x12\x1b\n\x16PROTO_OA_RECONCILE_REQ\x10\xcc\x10\x12\x1b\n\x16PROTO_OA_R\
    ECONCILE_RES\x10\xcd\x10\x12\x1d\n\x18PROTO_OA_EXECUTION_EVENT\x10\xce\
    \x10\x12!\n\x1cPROTO_OA_SUBSCRIBE_SPOTS_REQ\x10\xcf\x10\x12!\n\x1cPROTO_\
    OA_SUBSCRIBE_SPOTS_RES\x10\xd0\x10\x12#\n\x1ePROTO_OA_UNSUBSCRIBE_SPOTS_\
    REQ\x10\xd1\x10\x12#\n\x1ePROTO_OA_UNSUBSCRIBE_SPOTS_RES\x10\xd2\x10\x12\
    \x18\n\x13PROTO_OA_SPOT_EVENT\x10\xd3\x10\x12\x1f\n\x1aPROTO_OA_ORDER_ER\
    ROR_EVENT\x10\xd4\x10\x12\x1b\n\x16PROTO_OA_DEAL_LIST_REQ\x10\xd5\x10\
    \x12\x1b\n\x16PROTO_OA_DEAL_LIST_RES\x10\xd6\x10\x12)\n$PROTO_OA_SUBSCRI\
    BE_LIVE_TRENDBAR_REQ\x10\xd7\x10\x12+\n&PROTO_OA_UNSUBSCRIBE_LIVE_TRENDB\
    AR_REQ\x10\xd8\x10\x12\x1f\n\x1aPROTO_OA_GET_TRENDBARS_REQ\x10\xd9\x10\
    \x12\x1f\n\x1aPROTO_OA_GET_TRENDBARS_RES\x10\xda\x10\x12!\n\x1cPROTO_OA_\
    EXPECTED_MARGIN_REQ\x10\xdb\x10\x12!\n\x1cPROTO_OA_EXPECTED_MARGIN_RES\
    \x10\xdc\x10\x12\"\n\x1dPROTO_OA_MARGIN_CHANGED_EVENT\x10\xdd\x10\x12\
    \x17\n\x12PROTO_OA_ERROR_RES\x10\xde\x10\x12(\n#PROTO_OA_CASH_FLOW_HISTO\
    RY_LIST_REQ\x10\xdf\x10\x12(\n#PROTO_OA_CASH_FLOW_HISTORY_LIST_RES\x10\
    \xe0\x10\x12\x1e\n\x19PROTO_OA_GET_TICKDATA_REQ\x10\xe1\x10\x12\x1e\n\
    \x19PROTO_OA_GET_TICKDATA_RES\x10\xe2\x10\x12.\n)PROTO_OA_ACCOUNTS_TOKEN\
    _INVALIDATED_EVENT\x10\xe3\x10\x12%\n\x20PROTO_OA_CLIENT_DISCONNECT_EVEN\
    T\x10\xe4\x10\x12.\n)PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_REQ\x10\xe5\
    \x10\x12.\n)PROTO_OA_GET_ACCOUNTS_BY_ACCESS_TOKEN_RES\x10\xe6\x10\x12+\n\
    &PROTO_OA_GET_CTID_PROFILE_BY_TOKEN_REQ\x10\xe7\x10\x12+\n&PROTO_OA_GET_\
    CTID_PROFILE_BY_TOKEN_RES\x10\xe8\x10\x12\"\n\x1dPROTO_OA_ASSET_CLASS_LI\
    ST_REQ\x10\xe9\x10\x12\"\n\x1dPROTO_OA_ASSET_CLASS_LIST_RES\x10\xea\x10\
    \x12\x19\n\x14PROTO_OA_DEPTH_EVENT\x10\xeb\x10\x12(\n#PROTO_OA_SUBSCRIBE\
    _DEPTH_QUOTES_REQ\x10\xec\x10\x12(\n#PROTO_OA_SUBSCRIBE_DEPTH_QUOTES_RES\
    \x10\xed\x10\x12*\n%PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_REQ\x10\xee\x10\
    \x12*\n%PROTO_OA_UNSUBSCRIBE_DEPTH_QUOTES_RES\x10\xef\x10\x12!\n\x1cPROT\
    O_OA_SYMBOL_CATEGORY_REQ\x10\xf0\x10\x12!\n\x1cPROTO_OA_SYMBOL_CATEGORY_\
    RES\x10\xf1\x10\x12\x20\n\x1bPROTO_OA_ACCOUNT_LOGOUT_REQ\x10\xf2\x10\x12\
    \x20\n\x1bPROTO_OA_ACCOUNT_LOGOUT_RES\x10\xf3\x10\x12&\n!PROTO_OA_ACCOUN\
    T_DISCONNECT_EVENT\x10\xf4\x10\x12)\n$PROTO_OA_SUBSCRIBE_LIVE_TRENDBAR_R\
    ES\x10\xf5\x10\x12+\n&PROTO_OA_UNSUBSCRIBE_LIVE_TRENDBAR_RES\x10\xf6\x10\
    \x12\"\n\x1dPROTO_OA_MARGIN_CALL_LIST_REQ\x10\xf7\x10\x12\"\n\x1dPROTO_O\
    A_MARGIN_CALL_LIST_RES\x10\xf8\x10\x12$\n\x1fPROTO_OA_MARGIN_CALL_UPDATE\
    _REQ\x10\xf9\x10\x12$\n\x1fPROTO_OA_MARGIN_CALL_UPDATE_RES\x10\xfa\x10\
    \x12&\n!PROTO_OA_MARGIN_CALL_UPDATE_EVENT\x10\xfb\x10\x12'\n\"PROTO_OA_M\
    ARGIN_CALL_TRIGGER_EVENT\x10\xfc\x10\x12\x1f\n\x1aPROTO_OA_REFRESH_TOKEN\
    _REQ\x10\xfd\x10\x12\x1f\n\x1aPROTO_OA_REFRESH_TOKEN_RES\x10\xfe\x10\x12\
    \x1c\n\x17PROTO_OA_ORDER_LIST_REQ\x10\xff\x10\x12\x1c\n\x17PROTO_OA_ORDE\
    R_LIST_RES\x10\x80\x11\x12&\n!PROTO_OA_GET_DYNAMIC_LEVERAGE_REQ\x10\x81\
    \x11\x12&\n!PROTO_OA_GET_DYNAMIC_LEVERAGE_RES\x10\x82\x11\x12*\n%PROTO_O\
    A_DEAL_LIST_BY_POSITION_ID_REQ\x10\x83\x11\x12*\n%PROTO_OA_DEAL_LIST_BY_\
    POSITION_ID_RES\x10\x84\x11\x12\x1f\n\x1aPROTO_OA_ORDER_DETAILS_REQ\x10\
    \x85\x11\x12\x1f\n\x1aPROTO_OA_ORDER_DETAILS_RES\x10\x86\x11\x12+\n&PROT\
    O_OA_ORDER_LIST_BY_POSITION_ID_REQ\x10\x87\x11\x12+\n&PROTO_OA_ORDER_LIS\
    T_BY_POSITION_ID_RES\x10\x88\x11\x12\"\n\x1dPROTO_OA_DEAL_OFFSET_LIST_RE\
    Q\x10\x89\x11\x12\"\n\x1dPROTO_OA_DEAL_OFFSET_LIST_RES\x10\x8a\x11\x12-\
    \n(PROTO_OA_GET_POSITION_UNREALIZED_PNL_REQ\x10\x8b\x11\x12-\n(PROTO_OA_\
    GET_POSITION_UNREALIZED_PNL_RES\x10\x8c\x11*x\n\x10ProtoOADayOfWeek\x12\
    \x08\n\x04NONE\x10\0\x12\n\n\x06MONDAY\x10\x01\x12\x0b\n\x07TUESDAY\x10\
    \x02\x12\r\n\tWEDNESDAY\x10\x03\x12\x0c\n\x08THURSDAY\x10\x04\x12\n\n\
    \x06FRIDAY\x10\x05\x12\x0c\n\x08SATURDAY\x10\x06\x12\n\n\x06SUNDAY\x10\
    \x07*q\n\x15ProtoOACommissionType\x12\x17\n\x13USD_PER_MILLION_USD\x10\
    \x01\x12\x0f\n\x0bUSD_PER_LOT\x10\x02\x12\x17\n\x13PERCENTAGE_OF_VALUE\
    \x10\x03\x12\x15\n\x11QUOTE_CCY_PER_LOT\x10\x04*]\n\x19ProtoOASymbolDist\
    anceType\x12\x1d\n\x19SYMBOL_DISTANCE_IN_POINTS\x10\x01\x12!\n\x1dSYMBOL\
    _DISTANCE_IN_PERCENTAGE\x10\x02*<\n\x18ProtoOAMinCommissionType\x12\x0c\
    \n\x08CURRENCY\x10\x01\x12\x12\n\x0eQUOTE_CURRENCY\x10\x02*\x85\x01\n\
    \x12ProtoOATradingMode\x12\x0b\n\x07ENABLED\x10\0\x12'\n#DISABLED_WITHOU\
    T_PENDINGS_EXECUTION\x10\x01\x12$\n\x20DISABLED_WITH_PENDINGS_EXECUTION\
    \x10\x02\x12\x13\n\x0fCLOSE_ONLY_MODE\x10\x03*B\n\x1aProtoOASwapCalculat\
    ionType\x12\x08\n\x04PIPS\x10\0\x12\x0e\n\nPERCENTAGE\x10\x01\x12\n\n\
    \x06POINTS\x10\x02*T\n\x13ProtoOAAccessRights\x12\x0f\n\x0bFULL_ACCESS\
    \x10\0\x12\x0e\n\nCLOSE_ONLY\x10\x01\x12\x0e\n\nNO_TRADING\x10\x02\x12\
    \x0c\n\x08NO_LOGIN\x10\x03*>\n!ProtoOATotalMarginCalculationType\x12\x07\
    \n\x03MAX\x10\0\x12\x07\n\x03SUM\x10\x01\x12\x07\n\x03NET\x10\x02*@\n\
    \x12ProtoOAAccountType\x12\n\n\x06HEDGED\x10\0\x12\n\n\x06NETTED\x10\x01\
    \x12\x12\n\x0eSPREAD_BETTING\x10\x02*\x85\x01\n\x15ProtoOAPositionStatus\
    \x12\x18\n\x14POSITION_STATUS_OPEN\x10\x01\x12\x1a\n\x16POSITION_STATUS_\
    CLOSED\x10\x02\x12\x1b\n\x17POSITION_STATUS_CREATED\x10\x03\x12\x19\n\
    \x15POSITION_STATUS_ERROR\x10\x04*%\n\x10ProtoOATradeSide\x12\x07\n\x03B\
    UY\x10\x01\x12\x08\n\x04SELL\x10\x02*p\n\x10ProtoOAOrderType\x12\n\n\x06\
    MARKET\x10\x01\x12\t\n\x05LIMIT\x10\x02\x12\x08\n\x04STOP\x10\x03\x12\
    \x19\n\x15STOP_LOSS_TAKE_PROFIT\x10\x04\x12\x10\n\x0cMARKET_RANGE\x10\
    \x05\x12\x0e\n\nSTOP_LIMIT\x10\x06*}\n\x12ProtoOATimeInForce\x12\x12\n\
    \x0eGOOD_TILL_DATE\x10\x01\x12\x14\n\x10GOOD_TILL_CANCEL\x10\x02\x12\x17\
    \n\x13IMMEDIATE_OR_CANCEL\x10\x03\x12\x10\n\x0cFILL_OR_KILL\x10\x04\x12\
    \x12\n\x0eMARKET_ON_OPEN\x10\x05*\x99\x01\n\x12ProtoOAOrderStatus\x12\
    \x19\n\x15ORDER_STATUS_ACCEPTED\x10\x01\x12\x17\n\x13ORDER_STATUS_FILLED\
    \x10\x02\x12\x19\n\x15ORDER_STATUS_REJECTED\x10\x03\x12\x18\n\x14ORDER_S\
    TATUS_EXPIRED\x10\x04\x12\x1a\n\x16ORDER_STATUS_CANCELLED\x10\x05*[\n\
    \x19ProtoOAOrderTriggerMethod\x12\t\n\x05TRADE\x10\x01\x12\x0c\n\x08OPPO\
    SITE\x10\x02\x12\x10\n\x0cDOUBLE_TRADE\x10\x03\x12\x13\n\x0fDOUBLE_OPPOS\
    ITE\x10\x04*\xfb\x01\n\x14ProtoOAExecutionType\x12\x12\n\x0eORDER_ACCEPT\
    ED\x10\x02\x12\x10\n\x0cORDER_FILLED\x10\x03\x12\x12\n\x0eORDER_REPLACED\
    \x10\x04\x12\x13\n\x0fORDER_CANCELLED\x10\x05\x12\x11\n\rORDER_EXPIRED\
    \x10\x06\x12\x12\n\x0eORDER_REJECTED\x10\x07\x12\x19\n\x15ORDER_CANCEL_R\
    EJECTED\x10\x08\x12\x08\n\x04SWAP\x10\t\x12\x14\n\x10DEPOSIT_WITHDRAW\
    \x10\n\x12\x16\n\x12ORDER_PARTIAL_FILL\x10\x0b\x12\x1a\n\x16BONUS_DEPOSI\
    T_WITHDRAW\x10\x0c*?\n\x16ProtoOAChangeBonusType\x12\x11\n\rBONUS_DEPOSI\
    T\x10\0\x12\x12\n\x0eBONUS_WITHDRAW\x10\x01*\xb8\n\n\x18ProtoOAChangeBal\
    anceType\x12\x13\n\x0fBALANCE_DEPOSIT\x10\0\x12\x14\n\x10BALANCE_WITHDRA\
    W\x10\x01\x12-\n)BALANCE_DEPOSIT_STRATEGY_COMMISSION_INNER\x10\x03\x12.\
    \n*BALANCE_WITHDRAW_STRATEGY_COMMISSION_INNER\x10\x04\x12\"\n\x1eBALANCE\
    _DEPOSIT_IB_COMMISSIONS\x10\x05\x12)\n%BALANCE_WITHDRAW_IB_SHARED_PERCEN\
    TAGE\x10\x06\x124\n0BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_SUB_IB\x10\
    \x07\x124\n0BALANCE_DEPOSIT_IB_SHARED_PERCENTAGE_FROM_BROKER\x10\x08\x12\
    \x1a\n\x16BALANCE_DEPOSIT_REBATE\x10\t\x12\x1b\n\x17BALANCE_WITHDRAW_REB\
    ATE\x10\n\x12-\n)BALANCE_DEPOSIT_STRATEGY_COMMISSION_OUTER\x10\x0b\x12.\
    \n*BALANCE_WITHDRAW_STRATEGY_COMMISSION_OUTER\x10\x0c\x12'\n#BALANCE_WIT\
    HDRAW_BONUS_COMPENSATION\x10\r\x123\n/BALANCE_WITHDRAW_IB_SHARED_PERCENT\
    AGE_TO_BROKER\x10\x0e\x12\x1d\n\x19BALANCE_DEPOSIT_DIVIDENDS\x10\x0f\x12\
    \x1e\n\x1aBALANCE_WITHDRAW_DIVIDENDS\x10\x10\x12\x1f\n\x1bBALANCE_WITHDR\
    AW_GSL_CHARGE\x10\x11\x12\x1d\n\x19BALANCE_WITHDRAW_ROLLOVER\x10\x12\x12\
    )\n%BALANCE_DEPOSIT_NONWITHDRAWABLE_BONUS\x10\x13\x12*\n&BALANCE_WITHDRA\
    W_NONWITHDRAWABLE_BONUS\x10\x14\x12\x18\n\x14BALANCE_DEPOSIT_SWAP\x10\
    \x15\x12\x19\n\x15BALANCE_WITHDRAW_SWAP\x10\x16\x12\"\n\x1eBALANCE_DEPOS\
    IT_MANAGEMENT_FEE\x10\x1b\x12#\n\x1fBALANCE_WITHDRAW_MANAGEMENT_FEE\x10\
    \x1c\x12#\n\x1fBALANCE_DEPOSIT_PERFORMANCE_FEE\x10\x1d\x12#\n\x1fBALANCE\
    _WITHDRAW_FOR_SUBACCOUNT\x10\x1e\x12!\n\x1dBALANCE_DEPOSIT_TO_SUBACCOUNT\
    \x10\x1f\x12$\n\x20BALANCE_WITHDRAW_FROM_SUBACCOUNT\x10\x20\x12#\n\x1fBA\
    LANCE_DEPOSIT_FROM_SUBACCOUNT\x10!\x12\x1d\n\x19BALANCE_WITHDRAW_COPY_FE\
    E\x10\"\x12#\n\x1fBALANCE_WITHDRAW_INACTIVITY_FEE\x10#\x12\x1c\n\x18BALA\
    NCE_DEPOSIT_TRANSFER\x10$\x12\x1d\n\x19BALANCE_WITHDRAW_TRANSFER\x10%\
    \x12#\n\x1fBALANCE_DEPOSIT_CONVERTED_BONUS\x10&\x12/\n+BALANCE_DEPOSIT_N\
    EGATIVE_BALANCE_PROTECTION\x10'*s\n\x11ProtoOADealStatus\x12\n\n\x06FILL\
    ED\x10\x02\x12\x14\n\x10PARTIALLY_FILLED\x10\x03\x12\x0c\n\x08REJECTED\
    \x10\x04\x12\x17\n\x13INTERNALLY_REJECTED\x10\x05\x12\t\n\x05ERROR\x10\
    \x06\x12\n\n\x06MISSED\x10\x07*\x8c\x01\n\x15ProtoOATrendbarPeriod\x12\
    \x06\n\x02M1\x10\x01\x12\x06\n\x02M2\x10\x02\x12\x06\n\x02M3\x10\x03\x12\
    \x06\n\x02M4\x10\x04\x12\x06\n\x02M5\x10\x05\x12\x07\n\x03M10\x10\x06\
    \x12\x07\n\x03M15\x10\x07\x12\x07\n\x03M30\x10\x08\x12\x06\n\x02H1\x10\t\
    \x12\x06\n\x02H4\x10\n\x12\x07\n\x03H12\x10\x0b\x12\x06\n\x02D1\x10\x0c\
    \x12\x06\n\x02W1\x10\r\x12\x07\n\x03MN1\x10\x0e*$\n\x10ProtoOAQuoteType\
    \x12\x07\n\x03BID\x10\x01\x12\x07\n\x03ASK\x10\x02*?\n\x1cProtoOAClientP\
    ermissionScope\x12\x0e\n\nSCOPE_VIEW\x10\0\x12\x0f\n\x0bSCOPE_TRADE\x10\
    \x01*s\n\x17ProtoOANotificationType\x12\x1c\n\x18MARGIN_LEVEL_THRESHOLD_\
    1\x10=\x12\x1c\n\x18MARGIN_LEVEL_THRESHOLD_2\x10>\x12\x1c\n\x18MARGIN_LE\
    VEL_THRESHOLD_3\x10?*\x8f\t\n\x10ProtoOAErrorCode\x12\x19\n\x15OA_AUTH_T\
    OKEN_EXPIRED\x10\x01\x12\x1a\n\x16ACCOUNT_NOT_AUTHORIZED\x10\x02\x12\x15\
    \n\x11RET_NO_SUCH_LOGIN\x10\x0c\x12\x15\n\x11ALREADY_LOGGED_IN\x10\x0e\
    \x12\x18\n\x14RET_ACCOUNT_DISABLED\x10@\x12\x1a\n\x16CH_CLIENT_AUTH_FAIL\
    URE\x10e\x12\x1f\n\x1bCH_CLIENT_NOT_AUTHENTICATED\x10f\x12#\n\x1fCH_CLIE\
    NT_ALREADY_AUTHENTICATED\x10g\x12\x1b\n\x17CH_ACCESS_TOKEN_INVALID\x10h\
    \x12\x1b\n\x17CH_SERVER_NOT_REACHABLE\x10i\x12$\n\x20CH_CTID_TRADER_ACCO\
    UNT_NOT_FOUND\x10j\x12\x1a\n\x16CH_OA_CLIENT_NOT_FOUND\x10k\x12\x1e\n\
    \x1aREQUEST_FREQUENCY_EXCEEDED\x10l\x12\x1f\n\x1bSERVER_IS_UNDER_MAINTEN\
    ANCE\x10m\x12\x16\n\x12CHANNEL_IS_BLOCKED\x10n\x12\x1e\n\x1aCONNECTIONS_\
    LIMIT_EXCEEDED\x10C\x12\x19\n\x15WORSE_GSL_NOT_ALLOWED\x10D\x12\x16\n\
    \x12SYMBOL_HAS_HOLIDAY\x10E\x12\x1b\n\x17NOT_SUBSCRIBED_TO_SPOTS\x10p\
    \x12\x16\n\x12ALREADY_SUBSCRIBED\x10q\x12\x14\n\x10SYMBOL_NOT_FOUND\x10r\
    \x12\x12\n\x0eUNKNOWN_SYMBOL\x10s\x12\x18\n\x14INCORRECT_BOUNDARIES\x10#\
    \x12\r\n\tNO_QUOTES\x10u\x12\x14\n\x10NOT_ENOUGH_MONEY\x10v\x12\x18\n\
    \x14MAX_EXPOSURE_REACHED\x10w\x12\x16\n\x12POSITION_NOT_FOUND\x10x\x12\
    \x13\n\x0fORDER_NOT_FOUND\x10y\x12\x15\n\x11POSITION_NOT_OPEN\x10z\x12\
    \x13\n\x0fPOSITION_LOCKED\x10{\x12\x16\n\x12TOO_MANY_POSITIONS\x10|\x12\
    \x16\n\x12TRADING_BAD_VOLUME\x10}\x12\x15\n\x11TRADING_BAD_STOPS\x10~\
    \x12\x16\n\x12TRADING_BAD_PRICES\x10\x7f\x12\x16\n\x11TRADING_BAD_STAKE\
    \x10\x80\x01\x12&\n!PROTECTION_IS_TOO_CLOSE_TO_MARKET\x10\x81\x01\x12\
    \x20\n\x1bTRADING_BAD_EXPIRATION_DATE\x10\x82\x01\x12\x16\n\x11PENDING_E\
    XECUTION\x10\x83\x01\x12\x15\n\x10TRADING_DISABLED\x10\x84\x01\x12\x18\n\
    \x13TRADING_NOT_ALLOWED\x10\x85\x01\x12\x1b\n\x16UNABLE_TO_CANCEL_ORDER\
    \x10\x86\x01\x12\x1a\n\x15UNABLE_TO_AMEND_ORDER\x10\x87\x01\x12\x1e\n\
    \x19SHORT_SELLING_NOT_ALLOWED\x10\x88\x01*\x81\x01\n+ProtoOALimitedRiskM\
    arginCalculationStrategy\x12\x19\n\x15ACCORDING_TO_LEVERAGE\x10\0\x12\
    \x14\n\x10ACCORDING_TO_GSL\x10\x01\x12!\n\x1dACCORDING_TO_GSL_AND_LEVERA\
    GE\x10\x02*K\n\x16ProtoOAStopOutStrategy\x12\x1a\n\x16MOST_MARGIN_USED_F\
    IRST\x10\0\x12\x15\n\x11MOST_LOSING_FIRST\x10\x01BW\n%com.xtrader.protoc\
    ol.openapi.v2.modelB\x1fContainerOpenApiV2ModelMessagesP\x01\xa0\x01\x01\
    Z\x08/openapi\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(ProtoOAAsset::generated_message_descriptor_data());
            messages.push(ProtoOASymbol::generated_message_descriptor_data());
            messages.push(ProtoOALightSymbol::generated_message_descriptor_data());
            messages.push(ProtoOAArchivedSymbol::generated_message_descriptor_data());
            messages.push(ProtoOASymbolCategory::generated_message_descriptor_data());
            messages.push(ProtoOAInterval::generated_message_descriptor_data());
            messages.push(ProtoOATrader::generated_message_descriptor_data());
            messages.push(ProtoOAPosition::generated_message_descriptor_data());
            messages.push(ProtoOATradeData::generated_message_descriptor_data());
            messages.push(ProtoOAOrder::generated_message_descriptor_data());
            messages.push(ProtoOABonusDepositWithdraw::generated_message_descriptor_data());
            messages.push(ProtoOADepositWithdraw::generated_message_descriptor_data());
            messages.push(ProtoOADeal::generated_message_descriptor_data());
            messages.push(ProtoOADealOffset::generated_message_descriptor_data());
            messages.push(ProtoOAClosePositionDetail::generated_message_descriptor_data());
            messages.push(ProtoOATrendbar::generated_message_descriptor_data());
            messages.push(ProtoOAExpectedMargin::generated_message_descriptor_data());
            messages.push(ProtoOATickData::generated_message_descriptor_data());
            messages.push(ProtoOACtidProfile::generated_message_descriptor_data());
            messages.push(ProtoOACtidTraderAccount::generated_message_descriptor_data());
            messages.push(ProtoOAAssetClass::generated_message_descriptor_data());
            messages.push(ProtoOADepthQuote::generated_message_descriptor_data());
            messages.push(ProtoOAMarginCall::generated_message_descriptor_data());
            messages.push(ProtoOAHoliday::generated_message_descriptor_data());
            messages.push(ProtoOADynamicLeverage::generated_message_descriptor_data());
            messages.push(ProtoOADynamicLeverageTier::generated_message_descriptor_data());
            messages.push(ProtoOAPositionUnrealizedPnL::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(27);
            enums.push(ProtoOAPayloadType::generated_enum_descriptor_data());
            enums.push(ProtoOADayOfWeek::generated_enum_descriptor_data());
            enums.push(ProtoOACommissionType::generated_enum_descriptor_data());
            enums.push(ProtoOASymbolDistanceType::generated_enum_descriptor_data());
            enums.push(ProtoOAMinCommissionType::generated_enum_descriptor_data());
            enums.push(ProtoOATradingMode::generated_enum_descriptor_data());
            enums.push(ProtoOASwapCalculationType::generated_enum_descriptor_data());
            enums.push(ProtoOAAccessRights::generated_enum_descriptor_data());
            enums.push(ProtoOATotalMarginCalculationType::generated_enum_descriptor_data());
            enums.push(ProtoOAAccountType::generated_enum_descriptor_data());
            enums.push(ProtoOAPositionStatus::generated_enum_descriptor_data());
            enums.push(ProtoOATradeSide::generated_enum_descriptor_data());
            enums.push(ProtoOAOrderType::generated_enum_descriptor_data());
            enums.push(ProtoOATimeInForce::generated_enum_descriptor_data());
            enums.push(ProtoOAOrderStatus::generated_enum_descriptor_data());
            enums.push(ProtoOAOrderTriggerMethod::generated_enum_descriptor_data());
            enums.push(ProtoOAExecutionType::generated_enum_descriptor_data());
            enums.push(ProtoOAChangeBonusType::generated_enum_descriptor_data());
            enums.push(ProtoOAChangeBalanceType::generated_enum_descriptor_data());
            enums.push(ProtoOADealStatus::generated_enum_descriptor_data());
            enums.push(ProtoOATrendbarPeriod::generated_enum_descriptor_data());
            enums.push(ProtoOAQuoteType::generated_enum_descriptor_data());
            enums.push(ProtoOAClientPermissionScope::generated_enum_descriptor_data());
            enums.push(ProtoOANotificationType::generated_enum_descriptor_data());
            enums.push(ProtoOAErrorCode::generated_enum_descriptor_data());
            enums.push(ProtoOALimitedRiskMarginCalculationStrategy::generated_enum_descriptor_data());
            enums.push(ProtoOAStopOutStrategy::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
